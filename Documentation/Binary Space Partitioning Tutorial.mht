From: <Saved by Microsoft Internet Explorer 5>
Subject: Mr-Gamemaker.com BSP Tutorial
Date: Fri, 10 Nov 2000 21:24:10 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	boundary="----=_NextPart_000_0000_01C04B5C.911DD620";
	type="text/html"
X-MimeOLE: Produced By Microsoft MimeOLE V5.50.4133.2400

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: file://E:\Text\Sites\Misc%20Web%20Pages\mrg-bsptut\Mr%20GamerMaker_files\bsppart1.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from =
url=3D(0061)http://www.tasteofhoney.freeserve.co.uk/vsd/bsp/bsppart1.html=
 --><HTML><HEAD><TITLE>Mr-Gamemaker.com BSP Tutorial</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 5.50.4134.600" name=3DGENERATOR></HEAD>
<BODY vLink=3Dblue aLink=3Dblue link=3Dblue>
<CENTER>
<TABLE width=3D"100%" border=3D0>
  <TBODY>
  <TR>
    <TD align=3Dmiddle width=3D118><IMG height=3D70=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bookshelf.gif"=20
      width=3D118></TD>
    <TD align=3Dmiddle bgColor=3Dblue><FONT color=3Dwhite =
size=3D5>Binary Space=20
      Partitioning Tutorial</FONT><BR>
      <CENTER><FONT size=3D2><FONT color=3Dwhite>for=20
      Mr-GameMaker.com</FONT></FONT></CENTER></TD>
    <TD align=3Dmiddle width=3D118><IMG height=3D70=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bookshelf.gif"=20
      width=3D118></TD></TR></TBODY></TABLE></CENTER>
<TABLE width=3D"100%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D320><IMG height=3D240=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bspwall.gif"=20
      width=3D320></TD>
    <TD><BR><BR><FONT color=3Dgreen size=3D4>
      <CENTER><U>Creating a Solid Node Based BSP Tree Compiler &amp;=20
      Renderer</U></CENTER></FONT>
      <CENTER><BR><BR><BR><FONT size=3D2>written by Gary=20
      =
Simmons</FONT><BR><BR></CENTER></TD></TR></TBODY></TABLE><BR><U><FONT=20
color=3Dgreen size=3D5>
<CENTER>Introduction</CENTER></FONT></U><BR>Although Binary Space =
Partitioning=20
has been around for many many years it really became a buzz word when it =
was=20
discovered that John Carmack used BSP trees in Doom and Quake. Although =
the game=20
Doom is now of some age virtually all the latest first person shooters =
still use=20
BSP engines which really goes to show how this technique has stood the =
test of=20
time. The aim of this tutorial is to explain the basics of how a BSP =
works as=20
well as to write the code to a 'Solid Node Based BSP compiler' and =
Renderer.I=20
hope to explain this in such a way that even somebody fairly new to 3D =
graphics=20
will understand it as I feel most other resources on the net leave a lot =
of=20
unanswered questions for the less experienced programmer.<BR><BR>In =
order to=20
understand BSPs though it is an absolute necessity that you be well =
versed in=20
the <A =
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">Dot=20
Product</A> and have a complete understanding of it.If you are yet to =
have any=20
experience with the <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">Dot =
Product</A> it=20
is highly recommended that you read our <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">Dot =
Product</A>=20
tutorial before proceeding with this tutorial.It may also be worth you =
reading=20
our <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/http://www.tasteofhoney.f=
reeserve.co.uk/math_rot2.html">Cross=20
Product</A> tutorial so you fully understand the generation of Polygon =
Normals.=20
<BR><BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D5>What is a BSP tree=20
?</FONT></U></CENTER><BR>During the development of a 3D engine there =
comes a=20
time when you have to decide how you are going to draw all the polygons =
in a=20
frame from the current camera position in the right order. Lets assume =
that your=20
level consists of 10000 polygons (an average quake level) , how are you =
going to=20
draw them all in the right order each frame ? Ok you say, forget the =
order I=20
will just use a Z Buffer. This would certainly work if your level has no =

translucent objects but what if it has.The Translucent objects must be =
rendered=20
after the objects that are underneath it otherwise it will not blend =
correctly.=20
Also performing a for/next loop to sort all your levels polygons every =
frame=20
would result in a performance level where you could probably bake a cake =
in=20
between frame updates.Add to that collision detection of all the =
polygons in=20
your level (having to check if you have hit each one) and then you could =

probably ice the cake as well.Not only that, but sorting your polygons =
based on=20
their distance from the camera does not solve the following =
case.<BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp4.gif"=20
width=3D256></CENTER><BR><BR>The picture above causes a real problem =
when trying=20
to draw your polygons in a back to front order (using the painters =
algorithm)=20
because the RED polygon is both further and closer to the camera than =
the green=20
one.How do you sort this? Well a Z-Buffer sorts this problem of course =
but can=20
be extremely slow if there is no Hardware Acceleration and this still =
does not=20
solve the problem of having to draw your translucent objects in the =
right order=20
but a BSP can sort this problem without the need for a Z Buffer and also =
,=20
storing a level in a BSP Tree can provide many benefits in other areas=20
(collision detection,polygon culling).<BR><BR>Creating a BSP tree of =
your level=20
can solve all these problems by precalculating the order of your =
polygons at=20
development time (not runtime) so all the polygon sorting is =
precalculated .This=20
is the Job of the BSP Compiler that will take an input list of polygons =
and pre=20
sort them.After they have been sorted they are saved to disk in the form =
of a=20
BSP tree which can be loaded at runtime and quickly traversed.Not only =
can a BSP=20
tree be used for drawing all the polygons in your scene in the right =
order=20
(WITHOUT the need for a Z-Buffer) but it can also be used (in my opinion =
more=20
importantly) for culling any unseen objects from the fustrum at =
lightning=20
speed.This is because with a simple test you can check whether a given =
polygon=20
is behind the fustrum, if it is, then all the polygons behind this =
polygon are=20
also rejected in one go rejecting most probably most of the polygons in =
your=20
game level. I dont have to tell you how much faster your engine will run =
if=20
every frame you can reject a couple of thousand polygons with a few =
simple tests=20
and stop them having to be transformed and lit.We will also cover how to =
perform=20
fast collision detection using a BSP tree.For now though we are going to =

concentrate on the first order of business, how to draw the polygons in =
our=20
scene in the right order. We are going to write a BSP compiler later so =
do not=20
panic but first lets have a real good hard look at how a BSP tree =
works.<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>How do they=20
Work</U></FONT></CENTER><BR><BR>Take a look at Figure a) below.This =
shows a=20
simple game level from the top looking down.The black lines are the =
WALLS of a=20
simple game level viewed from the top down and the black arrows coming =
out of=20
them describe the way the wall is facing. <BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp1.gif"=20
width=3D256></CENTER>Above Ca,Cb &amp; Cc are examples of where the =
player in the=20
game (or the camera) could be situated.In order to draw the level in the =
right=20
order we need to be able to Draw the walls farthest from the camera =
first.We=20
certainly do not want to draw a near wall and then have our engine =
render a wall=20
that is supposed to be behind it on top of it.We can see that from the =
three=20
camera positions we should draw the walls in the following =
order.<BR><BR>
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite>Camera Position</FONT></TD>
    <TD bgColor=3Dred><FONT color=3Dwhite>Correct Drawing =
Order</FONT></TD></TR>
  <TR>
    <TD>Ca</TD>
    <TD>D or E in any order, A , C &amp; B is Unclear </TD></TR>
  <TR>
    <TD>Cb</TD>
    <TD>D or E in any order, A , B &amp; C is Unclear</TD></TR>
  <TR>
    <TD>Cc</TD>
    <TD>C &amp; B is Unclear , A , D or E in any=20
order</TD></TR></CENTER></TBODY></TABLE><BR><BR>A BSP Tree stores all =
the=20
polygons in a level so that they are either behind or infront or =
neigbouring=20
polygons but can you see why we have a problem here with walls C &amp; =
B.We can=20
not properly describe it as being either Front or Back because it is in =
fact=20
both.Part of wall C is infront of wall B and part is Behind.This causes =
a real=20
problem for rendering because we can not find a correct drawing order =
that will=20
work from all positions.Because we cant describe wall C as being either =
behind=20
or infront of wall B the BSP Tree algorithm will not work and may get it =
wrong=20
in some places.To deal with this our BSP Compiler must detect that a =
polygon is=20
straddling another and split that polygon into two halves.One half can =
then be=20
placed infront of the polygon and the other half placed behind.This may =
sound a=20
little complicated at the moment but do not worry it will get =
clearer.<BR><BR>A=20
BSP Tree stores its information by splitting the world into two halves =
(a bit=20
like drawing a huge never ending line right through the game world).All =
the=20
polygons are checked to see which side of the split they lie on (front =
or back)=20
and are assigned to the relative half.If a polygon straddles the =
splitter then=20
that polygon is split into two bits, the first bit that lies in front of =
the=20
splitter and second bit that lies behind.These two new polygons are then =

assigned to the relative lists (front or back) of the splitter and the =
original=20
polygon (before it was split) can be discarded and is no longer used in =
the BSP=20
Tree.This is because two new polygons have been created to take its =
place.These=20
two polygons that represent the first though can accurately be described =
as=20
being either front or back of the splitter.<BR><BR>So our first split is =
now=20
complete.We have two lists of polygons one that lies to the front of the =

splitter and one that lies to the back.What we do now is repeat that =
process=20
over and over again creating new front and back lists until we have =
assigned=20
each polygon a unique place in the tree.So for example after we have =
performed=20
the first split we have a front and back list.We now go down the front =
list of=20
polygons and split this list into two using a new splitter.After this we =
have a=20
front and back list for the second spitter so we go down the front and =
back=20
lists of this splitter and find yet another splitter and split these =
lists.Each=20
time we are dividing the split list and making them smaller until there =
are no=20
more polygons left to be assigned.(Dont worry if this is giving you a =
headache=20
it will start to make sense in a minute).<BR><BR>Ok then, so we now know =
that=20
the first thing we have to do is split the original list of polygons =
that=20
describe the game world into two and and assign each polygon to either =
front or=20
back of the splitter.But where does the Splitter come from.We can =
actually use=20
the planes of the polygons in the levels as the splitters.<BR><BR>
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite>In case you dont know what a =
plane is ,=20
      every polygon lies on an infinite plane.Get a piece of A4 paper =
and draw a=20
      small triangle in the middle of it.The triangle is the Polygon but =
the=20
      Paper is the Plane.The plane goes on forever (it has no edges like =
the=20
      paper) though but can you see that if you hold the paper up =
infront of you=20
      and start turning it to different angles the paper is always at =
the same=20
      angle as the triangle.In other words a plane is almost like a =
polygon but=20
      with NO edges around the outside.You can also see that if you are =
sat in=20
      your living room and the paper went on forever it would carve a =
line in=20
      the walls of your house.If you imagine that walls of your house =
are=20
      polygons you can see that after the wall has been split by the =
paper one=20
      half would lie to one side of the paper and the other half would =
lie the=20
      other side (front and back=20
splitting).</FONT></TD></TR></TBODY></TABLE></CENTER><BR><BR>Well we =
will look=20
at choosing a good splitting polygon later but for now lets just say =
that is=20
does not matter and we can use any polygon we like.Another important =
thing is=20
that the actual polygon used as the splitter is not added to any list =
(front or=20
back).This means each time we split we eliminate a polygon and we keep =
on=20
splitting until all polygons in the level has been used as a splitter so =
the=20
front and back lists become empty.At this point our BSP tree is =
built.Lets now=20
have a look at our game level and see how a BSP Compiler might split it=20
up.Remember the order we are choosing the spitters is purely for the =
purposes of=20
explanation at the moment.<BR><BR>
<CENTER>
<TABLE border=3D0>
  <TBODY>
  <TR>
    <TD rowSpan=3D6><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp3.gif"=20
      width=3D256></TD>
    <TD bgColor=3Dyellow>Front List of split (A)</TD>
    <TD width=3D20></TD>
    <TD bgColor=3Dyellow>Back List of Split (A)</TD></TR>
  <TR>
    <TD>B , C</TD>
    <TD></TD>
    <TD>D , E</TD></TR>
  <TR>
    <TD bgColor=3Dyellow>Front List of split (B)</TD>
    <TD width=3D20></TD>
    <TD bgColor=3Dyellow>Back List of Split (B)</TD></TR>
  <TR>
    <TD>Ca</TD>
    <TD></TD>
    <TD>Cb</TD></TR>
  <TR>
    <TD bgColor=3Dyellow>Front List of split (D)</TD>
    <TD width=3D20></TD>
    <TD bgColor=3Dyellow>Back List of Split (D)</TD></TR>
  <TR>
    <TD>E</TD>
    <TD></TD>
    <TD>Nothing</TD></TR></CENTER></TBODY></TABLE><BR><BR>So first we =
pass our=20
compiler a list of 5 walls.First of all we choose wall A as the =
splitter.The=20
GRAY line describes the plane polygon A lies on and carves the world =
up.You can=20
imagine this line (plane) as going on forever (of infinite length) in =
all=20
directions.So with A used to construct our splitter we loop through the =
polygons=20
(ignoring A itself) and test all the polygons against the splitter (A) =
.We keep=20
two lists (Front and Back) so it is easy to see that after this first =
split the=20
front and back lists look like shown above (Front/Back list of Split A). =
Next we=20
do exactly the same thing again but this time instead of using all the =
polygons=20
in the world we use just A's Front list and then A's back List etc.We =
should see=20
by this that a recursive function is needed to build the tree and it is=20
suprising how small the code to a BSP compiler actually is because of =
this.We=20
just call our BuildBSP funtion and pass in the original list of polygons =
and the=20
BuildBSP function seperates the front and back polygons into front and =
back=20
lists and then the function calls itself passing in first the front and =
then the=20
back list.The thing to try and picture in your head is the cascade =
effect of=20
this.The BuildBSP function calls itself with front and back lists which=20
themselves get split into front and back lists and sent to the BuildBSP =
function=20
which again divides these lists into front and back lists etc until all =
the=20
polygons have been made into splitters.Lets have a look now at a =
slightly more=20
complicated example and also show the tree how it would appear in =
memory.Each=20
circle in the following diagram is called a NODE.A Node is just a =
structure=20
defined by you that holds the splitter(which is also the polygon) and =
also=20
pointers to a front and back child Node.We will look at this in much =
more detail=20
in a moment but for now just make sure you understand how the polygons =
(which=20
are also are the splitters in our example) are linked together in the =
BSP=20
Tree.Below is a diagram showing the BSP Tree and the Layout of the =
walls.The=20
walls are laballed alphabetically in the order they were choosen for =
being=20
splitters and the letter F and B in the tree diagram represent two =
pointers=20
Front &amp; Back at each node that points to two other nodes.One to the =
front of=20
the current node and one to the back. <BR><BR>
<TABLE bgColor=3Dred>
  <TBODY>
  <TR>
    <TD><FONT color=3Dwhite size=3D2>Note:<BR>The reason I keep =
reminding you that=20
      the polygons stored at each node are also the splitters is that it =
is=20
      possible to use any arbitrary planes as the splitters.For example, =
you may=20
      wish to devise a tree where all the splitters are planes =
constructed to be=20
      aligned to the principle world axis and in some instances this can =
be=20
      beneficial , but this usually causes more polygons to be split =
which=20
      raises the polygon count.Also its much easier to use the polygons =
as the=20
      splitting planes because we already have=20
them.</FONT><BR></TD></TR></TBODY></TABLE><BR><BR>
<TABLE BORDERr=3D"1">
  <TBODY>
  <TR>
    <TD><IMG height=3D512=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp5.gif"=20
      width=3D512></TD>
    <TD>First we choose polygon R as our splitter.This means that the =
polygons=20
      get divided into two lists (Front &amp; Back).At this point the =
Front list=20
      contains polygons G,H,I,J,K,L,M and the Back list contains =
polygons=20
      A,B,C,D,E,F. So then first we take a look at splitter R's Front =
list.We=20
      then choose another polygon (G in our example) and make Polygon R =
point to=20
      polygon G with its front child pointer .We further split this list =
into=20
      front and back lists.There are no children to the back of polygon =
G so all=20
      the remaining polygons (H,I,J,K,L,M) are put into G's front =
list.We then=20
      choose another splitter (H) and point to this with Polygon G's =
front child=20
      pointer.When the front list is done for each splitter we then do =
the same=20
      with the back list.Study the BSP Tree diagram hard an make sure =
you can=20
      see exactly how the splitters are linked to each other.When you =
have this=20
      in your head carry on =
reading...</TD></TR></TBODY></TABLE><BR><BR>A typical=20
structure for a BSP Node may look something like this.Remember this and =
get it=20
in your head as you will need it to understand the rest of the=20
tutorial:-<BR><BR><FONT size=3D2><CODE>struct BSPNode{<BR>POLYGON=20
*splitter;<BR>BSPNode *FrontChild;<BR>BSPNode=20
*BackChild;<BR>};<BR></CODE></FONT><BR>You can see that this structure=20
represents what the Nodes in the above diagram would need as base =
properties.A=20
splitter which is also the polygon to be rendered at this Node and =
pointers to a=20
Node behind this node and a Node in front of this Node. <BR><BR>By the =
time our=20
BSP compiler has finished compiling the above level each Node in the =
tree will=20
contain a Polygon which is the splitter and will have a Front pointer =
pointing=20
to a Node that is in front of it and a Back pointer pointing to a Node =
that is=20
behind it.These nodes in turn will each have a polygon stored at the =
Node that=20
is the splitter and front and back child pointer nodes pointing to a =
node that=20
is infront and behind of it respectively.Note that not all Nodes will =
have valid=20
Front &amp; Back child pointers.For example in the above diagram G has =
no back=20
children so we set G's back pointer to NULL.The same is true for H,I =
&amp;=20
J.Notice also that K &amp; L have only back children so their FrontChild =

pointers would be set to NULL.Node M is a leaf node because there are no =
other=20
polygons either in front or behind that have not been already used by =
the=20
compiler so both its Front and Back child pointers would be set to NULL. =

<BR><BR>Ok then, we have had just about enough theory for the time being =
lets=20
start to look at how we can actually implement this in code.Lets first =
have a=20
look at the pseudo code to walk a BSP Tree and render it.Its so small =
you will=20
not believe it.<BR><BR><CODE><FONT size=3D1>void RenderBSP (NODE *=20
CurrentNode)<BR>{<BR>int=20
Result;<BR>Result=3DClassifyPoint(CameraPosition,CurrentNode-&gt;Polygon)=
;<BR>if=20
(Result=3D=3DFront)<BR>{<BR>if (CurrentNode-&gt;BackChild!=3DNULL) =
RenderBSP=20
(CurrentNode-&gt;BackChild);<BR>DrawPolygon(CurrentNode-&gt;Polygon);<BR>=
if=20
(CurrentNode-&gt;FrontChild!=3DNULL) RenderBSP=20
(CurrentNode-&gt;FrontChild);<BR>}<BR>else<BR>{<BR>if=20
(CurrentNode-&gt;FrontChild!=3DNULL) RenderBSP=20
(CurrentNode-&gt;FrontChild);<BR>DrawPolygon(CurrentNode-&gt;Polygon);<BR=
>if=20
(CurrentNode-&gt;BackChild!=3DNULL) RenderBSP=20
(CurrentNode-&gt;BackChild);<BR>}<BR>}<BR></FONT></CODE><BR><BR>Thats =
it!! That=20
little snip of recursive code will call itself repeatedly until the =
whole BSP=20
Tree (level of our game) is drawn.We first of all call this function and =
pass in=20
the Root Node that contains the first polygon that was used as a =
splitter in our=20
compiler.The ClassifyPoint function above is a function that we will =
write later=20
that tells us whether the camera is currently on the front side or the =
back side=20
of a polygon.You can see that we test the polygon stored at the Current =
node=20
(our first splitter) and if we are infront of it we draw the polygons =
behind it=20
first (by making this function call itself but this time passing in the=20
BackChild pointer), then draw the polygon actually stored at the node =
(the=20
splitter) and then draw the polygons in front of the Current =
Node.Otherwise we=20
are behind the current node so we reverse the order and draw the =
polygons=20
infront of the current wall first etc.This allows us to always draw =
walls that=20
are the farthest away first so they will always render correctly where =
ever we=20
may be standing in the level. <BR><BR>If you are new to recursive code=20
(functions that call themselves) just try and think of it as each time =
it calls=20
itself it's really just like calling another completely seperate =
function=20
because each time the function calls itself all the local data up to =
that point=20
is stored on the stack so when the current instance of the function =
finally=20
regains control again (because the previous function returned) all the =
data is=20
still in the same state as when the function first called itself and the =

function resumes executing from that point as if the call had simply =
been a call=20
to a printf command for example. Eventually when the recursive process =
ends=20
because we have hit a NODE with no front or back children the function =
returns=20
which gives control back to the previous instance of the function which =
made the=20
call which returns to the previous function which made the call etc =
until we are=20
right back at square one again and all the data has finally been poped =
off the=20
stack and we are back in the first instance of the function which we =
manually=20
called ourselves.Cool eh?. <BR><BR>Ok then lets check this works with a =
diagram=20
that we can manually step through in our heads executing the above =
code.Below=20
once again the walls are laballed in the order they became the splitters =
by the=20
compiler.This of course defines the way they are all linked =
together.Below the=20
RED dot 'C' is the camera position.The view direction of the camera is =
not=20
important.<BR><BR>
<TABLE width=3D"100%" border=3D0>
  <TBODY>
  <TR>
    <TD width=3D256><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp3.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>We first call our function passing in our ROOT =
Node A.=20
      Are we in front of Node A? No we are behind it so examine Node A's =
front=20
      child.This points to node B.Is the camera in front of Node B ? No =
so check=20
      Node B's front Child.This is Node Ca(remember our compiler had to =
split=20
      this line because it straddled B's split line) of which there are =
NO front=20
      or back child Nodes so we render Polygon Ca.We then return to the =
function=20
      that was processing Node B.We draw Node B's polygon and then check =
Node=20
      B's Back child pointer which points to node Cb.This node has no =
front or=20
      back Child Nodes so we render polygon Cb which returns to Node B's =

      function which itself is now finished with its work.So node B's =
function=20
      returns and we are now back in the original function call we made =
to A.We=20
      have rendered all the walls in front of A so now we Render Polygon =
A.We=20
      now step back and examine Node A's Back Child pointer which points =
to Node=20
      D.The camera is in front of Node D so we draw the Back Nodes first =
but=20
      there are none so we simply Draw Node D and then Check for any =
Nodes in=20
      front of D.There is one, Node E.Is the camera in front of E? Yes =
so draw=20
      back wall first but there aren't any so simply draw Polygon E and =
then=20
      check for Nodes that are in front of wall D.There aren't any so we =
are=20
      done and our level has been drawn in the correct order.WOW.=20
  </FONT></TD></TR></TBODY></TABLE><BR><BR>Congratulations you have just =
rendered=20
a BSP Tree in your head.I hope by now you can really understand the =
rendering=20
order.If we are in front of a polygon.Draw all polygons behind it first =
then=20
draw the polygon itself then draw the polygons in front of it.If we are =
behind=20
the polygon then do all that in the reverse order.You should also be =
able to see=20
that each Polygon (also the splitter) also points to at most TWO other =
splitters=20
one in front of it and one behind it.What we have in the end is a level =
where=20
every polygon is linked in a way that is relative to neighbouring =
polygons.All=20
we have to do at each splitter is a cheap test (ClassifyPoint) to =
discover which=20
side of the Splitter our camera is on and take the appropriate actions =
by either=20
walking down the back tree or the front tree at that Node.<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>Making a Solid=20
Tree</U></FONT></CENTER><BR><BR>Now one thing may be starting to confuse =
you a=20
little.When talking about compiling a BSP tree so far we have only =
discussed=20
what happens to polygons that are to the front and back of a splitter =
(they go=20
in the splitters front and back lists) and what happens when a polygon =
straddles=20
a splitter.But what happens when a polygon is on exactly the same plane =
as the=20
splitter.The picture below shows an example of this and it happens very =
often=20
with games like Quake and Unreal where there are a great number of long =
passage=20
ways etc.<BR><BR>
<CENTER><IMG height=3D63=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp20.gif"=20
width=3D198></CENTER><BR><BR>As you can see polygons A,B and C are on =
the same=20
dividing plane so what should we do.Well my first implementation of the =
BSP=20
Compiler decides that if any polygons shared a plane with the splitter =
those=20
polygons would NOT be added to any list and instead would ALL be stored =
in the=20
same node.Because these polygons are on the same plane and BSP Levels =
are depth=20
sorted using planes we know that even if these polygons are over =
completely=20
different sides of the game level from each other they can all be drawn =
at the=20
same time.So in the above example the compiler would use for example =
Polygon A=20
as a splitter but would link polygons B &amp; C to polygon A in the node =

also.Only polygons D and E would be stored in the appropriate lists.This =
speeds=20
up rendering for a number of reasons.Because each polygon sharing a =
plane no=20
longer needs its own Node the tree has less nodes so is quicker to =
traverse.Also=20
imagine in the above example that we are stood in font of polygon A =
which is the=20
Root Node in the tree.The rendering algorithm would be changed slightly =
like=20
this.Are we in front of Node A (YES).Render the Back Nodes of A first =
and then=20
render ALL the polygons stored in Node A in one batch.Then draw front =
walls of=20
node A.The great thing here is we can render ALL the planes polygons in =
one Node=20
saving function call overhead etc.There is a problem though.Polygons can =
share a=20
Plane but be FACING in opposite directions.Look at the picture =
below.<BR><BR>
<CENTER><IMG height=3D46=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp21.gif"=20
width=3D250></CENTER><BR><BR>This is no problem either we just have two =
linked=20
lists in our Node structure.In other words in the above example we would =
have a=20
pointer at the Node containing the polygon used for splitting as usual =
but then=20
we would have two lists one called 'SameFacing' which would be a linked =
list of=20
all the polygons sharing the Node that are facing the same way as the =
Splitter=20
polygon and another list called 'Opposite Facing' which would be a =
pointer to a=20
list containing polygons facing the opposite direction to the Nodes =
splitter=20
polygon.When you render the node you would use a function like so. =
<BR><BR><FONT=20
size=3D1><CODE>void WalkBspTree(NODE *Node,D3DVECTOR =
*pos)<BR>{<BR>POLYGON=20
*shared;<BR>int result=3DClassifyPoint(pos,Node-&gt; =
Splitter);<BR><BR>if=20
(result=3D=3DCP_FRONT)<BR>{<BR><FONT color=3Dred>shared=3DNode-&gt;=20
Splitter-&gt;SameFacingShared;<BR></FONT>if (Node-&gt; Back!=3DNULL)=20
WalkBspTree(Node-&gt; Back,pos);<BR>lpDevice-&gt;=20
DrawIndexedPrimitive(D3DPT_TRIANGLELIST,D3DFVF_LVERTEX,&amp;Node-&gt;=20
Splitter-&gt; VertexList[0],Node-&gt; Splitter-&gt;=20
NumberOfVertices,&amp;Node-&gt; Splitter-&gt;Indices[0],Node-&gt; =
Splitter-&gt;=20
NumberOfIndices,NULL);<BR><BR><FONT color=3Dred>while=20
(shared!=3DNULL)<BR>{<BR>lpDevice-&gt;=20
DrawIndexedPrimitive(D3DPT_TRIANGLELIST,D3DFVF_LVERTEX,&amp;shared-&gt;=20
VertexList[0],shared-&gt; NumberOfVertices,&amp;shared-&gt;=20
Indices[0],shared-&gt; NumberOfIndices,NULL);<BR>shared=3Dshared-&gt;=20
SameFacingShared;<BR>}<BR><BR></FONT>if (Node-&gt;Front!=3DNULL)=20
WalkBspTree(Node-&gt;Front,pos);<BR>return ;<BR>}<BR><BR>// this means =
we are at=20
back of node <BR><FONT=20
color=3Dred>shared=3DNode-&gt;Splitter-&gt;OppositeFacingShared;<BR></FON=
T>if=20
(Node-&gt;Front!=3DNULL) WalkBspTree(Node-&gt;Front,pos);<BR><BR><FONT=20
color=3Dred>while (shared!=3DNULL)<BR>{<BR>lpDevice-&gt;=20
DrawIndexedPrimitive(D3DPT_TRIANGLELIST,D3DFVF_LVERTEX,&amp;shared-&gt;=20
VertexList[0],shared-&gt; NumberOfVertices,&amp;shared-&gt;=20
Indices[0],shared-&gt; NumberOfIndices,NULL);<BR>shared=3Dshared-&gt;=20
OppositeFacingShared;<BR>} <BR><BR></FONT>if (Node-&gt; Back!=3DNULL)=20
WalkBspTree(Node-&gt;Back,pos);<BR>return;<BR>}<BR><BR><BR></CODE></FONT>=
I have=20
highlighted the lines of interest.If we are in front of the current Node =
then we=20
Render the Back Tree first and then the Nodes polygon and also render =
all=20
polygons that are facing the same way.If we are Behind this node then we =
render=20
the front Tree but we DO NOT bother rendering the actual Nodes polygon =
because=20
we know we are behind so will be back face culled anyway.Then we render =
ALL=20
polygons that are facing the opposite way to the Node(in other words =
they are=20
front facing because the node itself is back facing.<BR><BR>I had this =
up and=20
running in my first BSP Demo and it did speed up rendering and BSP =
traversal by=20
a small amount, but whilst I was actually writing this tutorial I =
discovered a=20
way much better than the above way.In other words we are going to use a=20
different and easier way than above.Although the above technique is =
faster for=20
rendering it is not that great for collision detection.Actually that is =
not=20
true, it can give you very accurate collision detection at good speed =
but often=20
you do not need to know exactly what polygon (a wall for example) you =
have hit=20
you only need to know that you have hit something.I did write a =
collision=20
detection routine for the type of tree above and if you want it you can =
contact=20
the webmaster and ask for it but what we are going to do now is use a =
slightly=20
different type of BSP tree called a Solid Tree.If we compile our level =
into a=20
Solid tree we can at lightning speed find out not only if we have hit a =
wall for=20
example but also find out whether two points have a Line of Sight of =
each=20
other.(COOL).So we are going to write our BSP compiler to compile a =
'Node Based=20
Solid BSP Tree'. <BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>Solid BSP Tree ? What's the=20
Difference</U></FONT></CENTER><BR><BR>There are hardly any differences =
between a=20
Solid BSP and a Normal BSP tree but the differences are important.This =
is them:-=20

<OL><LH></LH>
  <LI>The First difference comes in the way we deal with the last =
polygon in a=20
  Front or Back list during compilation.Up until now if a polygon has no =
front=20
  or back child Nodes we just set these pointers to NULL.What we will do =
now is=20
  if a Node has no front or back child we will create an extra node and =
attach=20
  it to the parents front or back list.This node though will have no =
polygon or=20
  splitter stored in it but instead we will add two more fields to our =
Node=20
  structure called 'IsLeaf' and 'IsSolid'.We will set 'IsLeaf' to true =
letting=20
  us know that NO polygons live in this node and if this new node is to =
the=20
  front of the parent (the parent being the last poly in the current =
poly list)=20
  we will set 'IsSolid' to false meaning that we are in an empty space =
(a space=20
  we can walk in).If this new node is to the back of the parent then we =
will set=20
  is 'IsSolid' to true.This means that the space behind a wall is =
bounded by=20
  walls so is solid and cannot be walked through.Now if you are totally =
confused=20
  you should be which is why I am going to show some pictures to expain=20
  it.<BR><BR>The typical level we have been looking at and using as an =
example=20
  up until now has not been very realistic.I mean look at the picture =
below.When=20
  have you ever walked around a Quake level and just seen a load of =
walls=20
  without any BACKS to them.<BR><BR>
  <CENTER><IMG height=3D256=20
  =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp1.gif"=20
  width=3D256> </CENTER><BR><BR>Because remember that the backs of walls =
can never=20
  been seen because they are back face culled.In other words if you =
walked=20
  behind wall A in the above picture and then turned around 180 degrees =
you=20
  would not see the back of wall A.Levels are designed in such a way =
that if you=20
  wanted a wall to stand alone in the middle of a level it would =
actually be=20
  made up of 4 or 5 faces like so:-<BR><BR>
  <CENTER><IMG height=3D95=20
  =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp22.gif"=20
  width=3D123></CENTER><BR><BR>Can you see that the faces of the wall =
are all=20
  facing outwards from the center.This means that if we are Behind all =
those=20
  walls we are in a solid space.An we should not be there.We will look =
at more=20
  examples of this in a moment. <BR><BR>
  <LI>The second difference in a Node based Solid tree is in the dealing =
of=20
  polygons that share the plane with the splitter.Remember above we went =
through=20
  all the pain of keeping two linked lists at each Node containing same =
facing=20
  and opposite facing shared polygons.Well we dont have to do that =
now.All our=20
  compiler will do if we find a polygon in the List that is sharing the =
plane=20
  with the splitter is send it down the splitters Front List.This may =
sound=20
  strange but it is important to do this so we can correctly identify =
Solid and=20
  Empty Spaces.In other words if you are in a space that is bounded by =
outward=20
  facing polygons then you are in solid space and probably cast in =
stone. Anyway=20
  its a lot easier than the first way we looked at. You may be thinking =
that if=20
  we feed shared planed polygons down the front list then we are =
creating extra=20
  nodes and possibly extra splits and you would be correct.However the =
speed=20
  increase in performing collision detection and Line of Sight =
determination far=20
  far outweighs the traversal of a few extra =
nodes.<BR><BR></LI></OL>Lets run=20
through in our heads then with the aid of a couple of pictures what our =
compiler=20
will do .Below shows a picture of a typical piece of corridor section =
from a=20
game level.Do not worry about the order that I choose the splits for now =
it is=20
just for demonstation.The solid spaces are enclosed by outward facing =
walls and=20
the walls are lablelled in the order we will choose them as splitters =
.To=20
clarify it further the red dot shows a typical position where the player =
could=20
stand.All the white space outside the two solid areas are empty space =
that the=20
player can walk about in.The enclosed blocks represent solid areas as if =
they=20
were made out of solid brick.We are now going to compile this level into =
a Solid=20
BSP tree in our heads step by step.This should make understanding the =
compiler=20
code simple after that.<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp10.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>Ok then, our compiler function is passed all the =
polygons=20
      A through M to compile.It choose splitter A as the first split and =
stores=20
      it in the Root Node.We then test all the polygons against polygon =
A so=20
      that they are put into the respective Front and Back Lists.Node =
A's front=20
      List will contain Polygons E through M and A's back list will =
contain=20
      polygons B through D.Lets just concentrate on polygon A's back =
list for=20
      now.The Compiler function creates a new node and calls itself with =
this=20
      new node and poygon A's back list B,C,D.The compiler then chooses =
another=20
      wall as a splitter from this list .Wall B in our example.This wall =
is then=20
      stored in the new Node we passed in to the function and linked to =
Node A's=20
      Back Pointer.</FONT></TD></TR>
  <TR>
    <TD><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp11.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>Now with Node B stored we then test the remaining =
walls=20
      in the list (C &amp; D) against wall B and as you can see they =
both go in=20
      wall B's back list.There are no walls in front of Node B so =
instead of=20
      just setting it to NULL we create New node and add it to Node B's =
Front=20
      Pointer.This Node has no polygon though because it is a =
leaf.Instead we=20
      just set the variable 'IsLeaf' to true and because this leaf is in =
front=20
      of its parent node (B) we set 'IsSolid' to false.This is an empty =
space=20
      that can be walked in.If we traverse the tree and end up in this =
leaf then=20
      this means we are somewhere in the Blue box shown opposite.There =
are walls=20
      however in Node B's front list so the compiler function calls =
itself again=20
      once again passing in the Front list (walls C&amp;D) and a newly =
created=20
      Node.</FONT> </TD></TR>
  <TR>
    <TD><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp12.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>This time through the compiler function has a =
choice of=20
      either wall C or wall D as a splitter.It chooses wall C and stores =
it in=20
      the newly passed node (which was attached to B's Back =
pointer).There are=20
      no walls in front of C so once again a new leaf node is created =
and added=20
      to Node C's Front Pointer .Once again 'IsSolid' is set to false =
because it=20
      is in front of C and 'IsLeaf' is set to true so we know that this =
is leaf=20
      and no polygon is stored here.Node C does have a back wall though =
(D) so=20
      once again the function called itself passing in wall D as the =
polygon=20
      list and also creates a new node that is attached to C's Back =
Pointer.This=20
      is passed to the function also and will end up containing D as the =

      splitter because it is the only one left in the =
list.</FONT></TD></TR>
  <TR>
    <TD><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp13.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>Now we choose splitter D because it is the only =
one left=20
      in the list.There are no front walls so once again a new leaf Node =
is=20
      created and attached to Node D's front pointer once again setting=20
      'IsSolid' to false.If we end up in this leaf then we are somewhere =
within=20
      the green box shown opposite.However, there are no walls behind =
Node D=20
      either so once again we create a new leaf node and attach it to =
Node D's=20
      back list but because this leaf is BEHIND node D we set 'IsSolid' =
to=20
      true.If we end up in this leaf then we are in the soild area =
bounded by=20
      walls A,B,C,D and this is not allowed. Its important to realize =
how a leaf=20
      is bounded by its parent Nodes to create an atomic space.(convex =
Hull in=20
      other words).The function returns to Node C's function which in =
turn=20
      returns to Node B's function which ends up back at A (Root node =
and the=20
      first instance of the function that we called) where we have only=20
      processed the back list.Now we process Node A's front list which =
if you=20
      remember consited of walls E through M.</FONT></TD></TR>
  <TR>
    <TD><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp14.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>The compiler function now recursivly calls itself =
again=20
      with Node A's front list.We choose wall E as the splitter,store it =
in a=20
      new node and again attach it to Node A's front pointer.The =
remaining=20
      polygons are tested against wall E and we end up with a back list =
of=20
      polygon F &amp; G and a front list for E containing polygons H =
through=20
      M.Lets have a look at the back list first.The compiler function =
calls=20
      itself passing in the back list of E and a new node and this time =
wall F=20
      is selected and stored in the new node and the new node is =
conected to=20
      Node E's Back pointer.There are no walls in front of wall F so =
once again=20
      a new leaf is created and added to Node F's Front pointer once =
again=20
      setting 'IsLeaf' to true and because this leaf node is in front of =
wall F=20
      once again 'IsSolid' is set to false because this is an empty =
space.If we=20
      end up in this leaf we are in the dark red box to the right of =
wall F. G=20
      is the last wall sent which has no front or back walls.Once again =
a front=20
      leaf is created as being empty and attached to G's front Pointer =
and a=20
      Solid leaf is created and attached to G's back pointer.This leaf=20
      represents the solid are bounded by walls E,F &amp; G.You can now =
see the=20
      top solid area is now completely represented in the tree. =
</FONT></TD></TR>
  <TR>
    <TD><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp15.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>Here is this section finished being compiled.You =
step=20
      through the other splits in your head and make sure that you fully =

      understand the THEORY of whats going on even if you do not know =
how to=20
      code it yet.The most important point to remember is that a =
splitter is not=20
      in ANY of its own lists.For example wall A may look like it is =
behind wall=20
      B but remember that wall B is a child of A and can only divide =
wall A's=20
      back subspace.Wall A is not in B's lists at all.Just like wall C =
is a=20
      child of B so wall C can not SEE B because it can only divide wall =
B's=20
      back sub space.This is the very core process to spacial sub =
division other=20
      wise the compiler could not section off bits of=20
space.</FONT></TD></TR></TBODY></TABLE><BR><BR>Lets now have a look at =
how our=20
Node structure will look.Remember a BSP tree is nothing more than a mass =
of=20
Nodes pointing to each other in an order that makes sense.<BR><BR>struct =
NODE=20
<BR>{<BR>POLYGON * Splitter;<BR>NODE * Front;<BR>NODE * Back;<BR>BOOL=20
IsLeaf;<BR>BOOL IsSolid;<BR>};<BR><BR>Nothing much to explain here we =
have just=20
added two variables to signal if this is a leaf.We need to know this so =
we do=20
not try and render a polygon at this node because 'Splitter' will be set =
to NULL=20
for a leaf.We have discussed what 'IsSolid' does above. <BR><BR><U><FONT =

color=3Dgreen size=3D5>
<CENTER>Other Benefits of a Solid BSP =
Tree</CENTER></FONT></U><BR><BR>Now I do=20
not want to get into collision detection with a BSP tree to heavily yet =
but lets=20
just have a look at some of the benefits.Imagine the above level was =
much larger=20
and instead of there only being two or three walls either side of the =
root=20
splitter A imagine instead there were 5000 polygons (therefore 10000 =
Nodes in=20
our BSP Tree.We will just forget about the extra polygons created from =
splits=20
for now).Imagine we want to check if we have are about to move into a =
wall.=20
Without the BSP you would have to test each polygon all 10000 of them to =
see if=20
you are about to intersect with one.Not only that but polygon collision=20
detection normally involves a lot of cpu intensive maths like square =
roots=20
etc.Well its just not going to happen is it.Now lets have a look at this =
the BSP=20
way.We have the point we are about to move to.We now start testing it =
against=20
the polygons (Nodes) in the BSP.Is it to the front or back of Node A. If =
its to=20
the front of Node A then every single polygon behind Node A is rejected =
after=20
just one test because we can not possibly hit them.We have just rejected =
5000=20
polygons after one simple test.Because we are in front of A we go down =
A's front=20
tree doing the same at each Node.At each Node we are rejecting half that =
nodes=20
polygons (this is assuming a perfectly balanced tree which is hardly =
ever the=20
case but serves us for this example).Rejecting half a Nodes polygons at =
every=20
node will make you eventually pop out at a leaf after about 15-25 Nodes =
even in=20
a big level.Once you pop out at a leaf (assuming we are using a Solid =
BSP as=20
described above as we will be) we simply check that leafs 'IsSolid' =
variable and=20
if it is set to true we can not walk that way.The great thing about this =
though=20
is the fact that we are loosing HALF each nodes polygons at every =
test.Not only=20
that but because we have a solid tree with leaves that tell us they are =
solid we=20
do not even have to do any complicated ray intersection.This is =
lightning=20
fast.Not only that but exactly the same technique can be used for =
detecting Line=20
if Sight.Later on once we have written our compiler we will write a =
collision=20
detection/line if sight function to use the tree the way we have =
described. Now=20
that does sound tempting does it not? <BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite size=3D2><U>Note:</U><BR>The =
above=20
      technique is a simplified version of how collision detection and =
line of=20
      sight works.Ofcourse it does not allow for the fact that the point =
you are=20
      about to move to is empty but there may be something in between =
your=20
      current position and the position you are about to move to.We will =
cover=20
      this in detail later when we write our LineOfSight function and =
its still=20
      very easy to solve but I do not want to confuse you any more than =
you=20
      probably already are at the=20
moment.</FONT><BR></TD></TR></TBODY></TABLE><BR><BR>I hope by now you =
have a=20
firm grasp on the whole BSP Tree theory and how it sub divides =
space.Hopefully=20
when you see the actual code for the Compiler and Renderer all the un =
answered=20
questions will start to fall into place.The theory lesson is now over =
and it is=20
time to look at some raw code.We are now going to go step by step =
through the=20
lines of code used in my BSP Demo.This demo is downloadable at the =
bottom of=20
this page and is a fully working 3D BSP compiler that compiles a list of =
polys=20
into a BSP Tree and then lets you walk around the level it creates. =
<BR><BR>
<CENTER><U><FONT size=3D5><FONT color=3Dgreen>A Slight Diversion - =
Setting up the=20
Geometry for our BSP Demo</FONT></FONT></U></CENTER><BR><BR>Many BSP =
Tree=20
resources on the web only provide you with theory or little bits of code =
and you=20
are left worrying how exactly you work this code into your own =
program.To=20
hopefully stop that happening this time we are (together) going to write =
a fully=20
fledged BSP Demo.This demo will actually Compile the BSP Tree and then =
render it=20
and let you walk around it just like in a real game.You can then use =
this code=20
as a basis for your program. However in order for us to write a BSP =
Compiler we=20
must have something for it to compile otherwise how will we know if it=20
works.What we are now going to do is take a slight detour away from BSP =
Trees=20
for just a couple of minutes while I explain how the polygons for the =
demo are=20
created and stored.The reason I am explaining this and not just letting =
you=20
download the source for a look (which you can do at the bottom of this =
page=20
anyway) is because the way the Polygons are stored is of major =
importance to HOW=20
we write our compiler.So we are going to take a look at a few =
initialization=20
routines that create the polygons and link them altogether in a Linked =
List to=20
send to the BSP Compiler.<BR><BR>The first thing for us to look at =
however is=20
the structure we will use to hold Polygon Data.Each polygon structure =
will=20
represent one polygon.It looks like this.<BR><BR><BR><BR>struct POLYGON=20
<BR>{<BR>D3DLVERTEX VertexList[10];<BR>D3DVECTOR Normal;<BR>WORD=20
NumberOfVertices;<BR>WORD NumberOfIndices;<BR>WORD =
Indices[30];<BR>POLYGON *=20
Next;<BR>};<BR><BR>The polygon structure holds an array of D3DLVERTEX =
structures=20
which describes the vertices in the polygon.The actual Polygon will =
internally=20
be rendered using Indices into the vertex array.This is what the Indcies =
array=20
is for in the structure.This will allow us to simply pass any shape =
(convex)=20
polygons to our AddPolygon function (we will write this in a minute) =
containing=20
any number of vertices and our AddPolygon function will break each =
polygon into=20
multiple triangles so it can be passed to the DrawIndexedPrimitive =
function.If=20
you are not familiar with Indices it may well be worth looking them up =
in the=20
SDK docs.Indices allow you to build multiple triangles using shared =
vertices=20
.Below shows an example of such a polygon.<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD><IMG height=3D155=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/xf1.gif"=20
      width=3D159></TD>
    <TD><FONT size=3D2>You can see that this polygon is made up of 5 =
vertices=20
      but has to be broken into three triangles in order to be =
rendered.Although=20
      this shape has 5 vertices it will need 9 indices to describe it to =
the=20
      renderer because the renderer needs to render triangles and each =
triangle=20
      needs 3 points.The nine indices would be as follows=20
      v1,v2,v3,v1,v3,v4,v1,v4,v5.You can calculate the number of indices =
needed=20
      with the following=20
      =
equation:-<BR><BR>NumberOfIndices=3D(NumberOfVertices-2)*3;<BR><BR>This =
of=20
      course has nothing whatsoever to do with BSP Trees but I am =
explaining how=20
      our BSP Compiler expects to see the polygons represented.<BR>This =
polygon=20
      can be rendered using the following line:-<BR><BR></FONT><FONT=20
      =
size=3D2>lpDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST,D3DFVF_LVER=
TEX,pVertexList,=20
      5 ,pIndices, 9 ,NULL);</FONT><BR><BR><BR><FONT size=3D2>As you can =
see the=20
      above shape may render three triangles and that would normally =
mean 9=20
      vertices have to be transformed and lit.However because we are =
using=20
      indices to describe the triangle only five vertices actually get=20
      transformed and lit and are re used by faces that share them.We =
will look=20
      at the code responsable for breaking up the polygons into multiple =

      triangles later when we write our AddPolygon function which will =
add=20
      polygons to the =
scene.</FONT><BR><BR></TD></TR></TBODY></TABLE><BR>Once you=20
understand the BSP Compiler it will be easy to modify it to take any =
polygon=20
format you want.What makes our POLYGON structure weird above is that it =
is multi=20
purpose because in our example we compile and render the tree all at =
runtime=20
(because the level is not very big).Also in our POLYGON structure you =
can see=20
that there is a pointer to a POLYGON called 'Next'.This member is used =
in the=20
compilation process as we will send all the polygons in our scene to our =
BSP=20
Compiler in the form of a Linked list.This means that polygon 1 will =
have a Next=20
pointer that points to Polygon 2 and polygon 2's Next pointer will point =
to=20
Polygon 3 etc.Eventually the last polygon in the list will have its Next =
pointer=20
set to NULL.The AddPolygon function we will write will also handle the =
linking=20
process.We simply pass in the new polygon and the previous polygon and =
it will=20
link the previous polygons Next pointer to point at the newly =
constructed=20
polygon.<BR>One point worthy of note is that this pointer is only used =
in BSP=20
compilation and is not used once the tree is compiled .That is what I =
meant by a=20
multi purpose structure that is used for compiling and rendering.If you =
saved=20
your BSP to disk and loaded it back in you could ommit this field from =
the=20
POLYGON structure.You may also notice that the POLYGON structure has a =
Normal=20
member which is just a vector that is perpendicular to the polygon and =
describes=20
the direction the polygon is facing.Once again our AddPolygon function =
will=20
generate the Normal for the polygon automatically and stuff it in the =
polygon=20
structure.(Hopefully you have read our Cross Product &amp; Dot Product =
tutorials=20
and the word Normal is not new to you.If you do not know what a normal =
is then=20
stop reading this now and read our Cross Product and Dot Product =
tutorials or=20
none of this will make any sense to you). <BR><BR>We now know how we are =
going=20
to store the polygons and pass them to the BSP Compiler but how are we =
going to=20
create the polygons in the first place.We certainly are not ready to =
talk about=20
importing levels from various editors which is just as well because I =
know=20
nothing about the various file formats of the various BSP Level editors=20
(although you can find some info on how Quake levels are stored at <A=20
href=3D"http://www.flipcode.com/">http://www.flipcode.com/</A> which =
also happens=20
to be a bloody excellent site, well done kurt). <BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>Setting up the Polygons ready =
for=20
Compilation</U></FONT></CENTER><BR><BR>In my BSP demo (that can be down =
loaded=20
at the bottom of this page) I needed a way to quickly knock up some =
polygons to=20
test my compiler with.I defined an array like so in my code.Below shows =
just a=20
fragment of the array as staring at lots of zeros and ones does not =
exactly make=20
great reading unless you are a Binar.(ST:TNG series 1 I think, well =
Tasha Yar=20
was still alive anyway)<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD>BYTE BSPMAP []=3D<BR><FONT=20
      =
size=3D1>{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<BR>0,0,2,0,0,0,0,0,0,0=
,0,3,0,0,0,0,0,0,0,0,<BR>0,2,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,<BR>1,0,=
0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,<BR>0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0=
,1,0,1,<BR>0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,<BR>0,1,1,0,0,0,0,1,0,=
0,0,0,0,0,0,0,0,0,3,1,<BR>0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,<BR>1,0=
,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,<BR>0,1,0,0,0,0,1,2,0,0,0,1,0,0,0,1,=
0,0,0,1,<BR>0,1,0,0,0,1,2,0,0,0,0,1,1,0,0,0,0,0,0,1,<BR>0,1,0,0,0,1,0,0,0=
,0,0,3,1,0,0,0,0,0,0,1,<BR>0,1,0,1,1,2,0,0,0,0,0,0,1,0,0,0,0,0,0,1,<BR>1,=
2,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,=20
      =
<BR>1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,<BR>1,0,0,1,2,0,0,0,0,0,0,0,0=
,0,0,1,0,0,0,1,<BR>1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,<BR>1,1,1,1,1,=
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};<BR></FONT><BR></TD>
    <TD><FONT size=3D2>With this array we are going to build a function =
that=20
      will loop through each element of the array.One entry in the array =

      represents 1 unit squared of 3D World Space so when a 1 is =
encountered=20
      with zeros all around it 4 polygons are created for the four walls =
of a=20
      cube all facing outwards. If a number other than zero is to any =
side of=20
      the 1 then a wall is not built for that side because it is covered =
up by=20
      an adjacent wall.So in other words each 1 digit represent a 1x1 =
cube in=20
      world space and we will texture the four walls (n,s,e &amp; w) =
with some=20
      brick wall texture.The 2 and 3's in the map were just put in there =
by me=20
      at the last minute to give the map a few angles.A 2 digit =
represents a NE=20
      facing wall and a 3 represents a NW facing wall.I didn't bother to =
create=20
      SW or SE but you can do that yourself if you want.Just build them =
the same=20
      as the NW and NE walls but reverse the winding order of the =
vertices.The=20
      polygons are created in WORLD space with the center of space 0,0,0 =
being=20
      in the middle of the map and each digit as I said represents 1x1 =
unit in=20
      space.The full grid is 20x40 in dimensions (not all shown=20
      here).</FONT><BR><BR><FONT size=3D2><U>Note:-</U><BR><BR>For those =
of you=20
      reading this and thinking what a dodgy way to make a level you are =
of=20
      course right.But all I needed was an easy way to create lots of =
polygons=20
      to throw at the BSP Compiler.Also the last thing we need right now =
is a=20
      tutorial on how to import levels from various editors which =
actually is=20
      just as well because I have not got a clue.=20
</FONT></TD></TR></TBODY></TABLE><BR><BR>After we have set up our 3D =
environment=20
(initialized D3D etc) the first function we call is our InitPolygons =
Function=20
which looks like so:-<BR><BR><FONT size=3D1><CODE>void=20
InitPolygons(void)<BR>{<BR>D3DLVERTEX =
VERTLIST[4][4];<BR>PolygonList=3DNULL;//=20
this is a GLOBAL pointer<BR>POLYGON *child=3DNULL;<BR>int =
direction[4];<BR>for=20
(int y=3D0;y&lt; 40;y++)<BR>{<BR>for (int x=3D0;x&lt;=20
20;x++)<BR>{<BR>ZeroMemory(direction,sizeof(int)*4);<BR>int=20
offset=3D(y*20)+x;<BR>// check what the digit is in the current map =
location<BR>if=20
(BSPMAP[offset]!=3D0)<BR>{<BR>if (BSPMAP[offset]=3D=3D2)// North East =
Wall<BR>{=20
<BR>VERTLIST[0][0]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,3.0f,(20.0f-y)-0.5f),RG=
B_MAKE(=20
255, 255,=20
255),0,0,0);<BR>VERTLIST[0][1]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,3.0f,(20.0f-=
y)+0.5f),RGB_MAKE(=20
255, 255,=20
255),0,1,0);<BR>VERTLIST[0][2]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,0.0f,(20.0f-=
y)+0.5f),RGB_MAKE(=20
255, 255,=20
255),0,1,1);<BR>VERTLIST[0][3]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,0.0f,(20.0f=
-y)-0.5f),RGB_MAKE(=20
255, 255, 255),0,0,1);<BR>direction[0]=3D1;<BR>}<BR>if =
(BSPMAP[offset]=3D=3D3)// North=20
West Wall<BR>{=20
<BR>VERTLIST[0][0]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,3.0f,(20.0f-y)+0.5f),RG=
B_MAKE(=20
255, 255,=20
255),0,0,0);<BR>VERTLIST[0][1]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,3.0f,(20.0f-=
y)-0.5f),RGB_MAKE(=20
255, 255,=20
255),0,1,0);<BR>VERTLIST[0][2]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,0.0f,(20.0f-=
y)-0.5f),RGB_MAKE(=20
255, 255,=20
255),0,1,1);<BR>VERTLIST[0][3]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,0.0f,(20.0f=
-y)+0.5f),RGB_MAKE(=20
255, 255, 255),0,0,1);<BR>direction[0]=3D1;<BR>} <BR><BR>if =
(BSPMAP[offset]=3D=3D1)//=20
Its a Standared wall<BR>{<BR>if (x &gt; 0)<BR>{<BR>if =
(BSPMAP[offset-1]=3D=3D0)// if=20
theres nothing to the left add a left facing=20
wall<BR>{<BR>VERTLIST[0][0]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,3.0f,(20.0f-y)=
+0.5f),RGB_MAKE(255,255,255),0,0,0);<BR>VERTLIST[0][1]=3DD3DLVERTEX(D3DVE=
CTOR(x-10.5f,3.0f,(20.0f-y)-0.5f),RGB_MAKE(255,255,255),0,1,0);<BR>VERTLI=
ST[0][2]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,0.0f,(20.0f-y)-0.5f),RGB_MAKE(255=
,255,255),0,1,1);<BR>VERTLIST[0][3]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,0.0f,(=
20.0f-y)+0.5f),RGB_MAKE(255,255,255),0,0,1);<BR>direction[0]=3D1;<BR>}<BR=
>}<BR>if=20
(x &lt; 19)<BR>{<BR>if (BSPMAP[offset+1]=3D=3D0)// if there is nothing =
to the right=20
add a right facing=20
wall<BR>{<BR>VERTLIST[1][0]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,3.0f,(20.0f-y)-=
0.5f),RGB_MAKE(255,255,255),0,0,0);<BR>VERTLIST[1][1]=3DD3DLVERTEX(D3DVEC=
TOR(x-9.5f,3.0f,(20.0f-y)+0.5f),RGB_MAKE(255,255,255),0,1,0);<BR>VERTLIST=
[1][2]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,0.0f,(20.0f-y)+0.5f),RGB_MAKE(255,25=
5,255),0,1,1);<BR>VERTLIST[1][3]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,0.0f,(20.0=
f-y)-0.5f),RGB_MAKE(255,255,255),0,0,1);<BR>direction[1]=3D1;<BR>}<BR>}<B=
R>if=20
(y &gt; 0)<BR>{<BR>if (BSPMAP[offset-20]=3D=3D0)// if there is nothing =
south add a=20
south facing=20
wall<BR>{<BR>VERTLIST[2][0]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,3.0f,(20.0f-y)+=
0.5f),RGB_MAKE(255,255,255),0,0,0);<BR>VERTLIST[2][1]=3DD3DLVERTEX(D3DVEC=
TOR(x-10.5f,3.0f,(20.0f-y)+0.5f),RGB_MAKE(255,255,255),0,1,0);<BR>VERTLIS=
T[2][2]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,0.0f,(20.0f-y)+0.5f),RGB_MAKE(255,=
255,255),0,1,1);<BR>VERTLIST[2][3]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,0.0f,(20=
.0f-y)+0.5f),RGB_MAKE(=20
255, 255, 255),0,0,1);<BR>direction[2]=3D1;;<BR>}<BR>}<BR>if(y &lt; =
39)<BR>{=20
<BR>if (BSPMAP[offset+20]=3D=3D0)// if there is nothing to the north add =
a north=20
facing=20
wall<BR>{<BR>VERTLIST[3][0]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,3.0f,(20.0f-y)=
-0.5f),RGB_MAKE(255,255,255),0,0,0);<BR>VERTLIST[3][1]=3DD3DLVERTEX(D3DVE=
CTOR(x-9.5f,3.0f,(20.0f-y)-0.5f),RGB_MAKE(255,=20
255,=20
255),0,1,0);<BR>VERTLIST[3][2]=3DD3DLVERTEX(D3DVECTOR(x-9.5f,0.0f,(20.0f-=
y)-0.5f),RGB_MAKE(=20
255, 255,=20
255),0,1,1);<BR>VERTLIST[3][3]=3DD3DLVERTEX(D3DVECTOR(x-10.5f,0.0f,(20.0f=
-y)-0.5f),RGB_MAKE(=20
255, 255, 255),0,0,1);<BR>direction[3]=3D1;;<BR>}<BR>} <BR>}// end for =
if=20
offset=3D=3D1<BR><BR>// build the polygons<BR><BR>for (int=20
a=3D0;a&lt;4;a++)<BR>{<BR>if (direction[a]!=3D0)<BR>{<BR>if=20
(PolygonList=3D=3DNULL)<BR>{<BR>PolygonList=3DAddPolygon(NULL,&amp;VERTLI=
ST[a][0],4);<BR>child=3DPolygonList;<BR>}<BR>else<BR>{<BR>child=3DAddPoly=
gon(child,&amp;VERTLIST[a][0],4);<BR>}<BR>}//<BR>}////<BR>}//=20
end for if offset!=3D0<BR>}<BR>}<BR>BSPTreeRootNode=3Dnew=20
NODE;<BR>BuildBspTree(BSPTreeRootNode,PolygonList);<BR>}</FONT></CODE> =
<BR>With=20
the exception of the last two line which we will cover later, this =
function does=20
not take much explanation.All it does is loops through the BSPMAP =
array,reads in=20
the digits and sets up some vertices for the walls.Notice how each wall =
has four=20
vertices described in a clockwise manner and how the position into the =
map is=20
used to place each vertices in world space.At each digit that returns =
'1' we=20
check the area to the left,right,north and south of the digit if there =
are any=20
zeros at that location it means this wall is an external wall and can be =
seen by=20
the player so vertices are setup at that location defined in a way that =
is=20
clockwise when you are looking at it.We then loop through the Direction =
array=20
and for each element set to 1 we know some vertices have been set up for =
a wall=20
so we pass these four vertices to our AddPolygon function (see this in a =

minute).The AddPolygon function takes a pointer to a PARENT polygon, =
array of=20
vertices and the number of vertices in the array.Notice above that the=20
PolygonList pointer is a Global pointer that will point to the ROOT of =
our=20
linked list of polygons.If this polygon=3D=3DNULL then this is the first =
polygon and=20
had no parent so we just pass NULL as the parent.For every other polygon =
bar the=20
first though we pass in the previously created polygon as the new =
polygons=20
parent.The AddPolygon function returns a pointer to a POLYGON structure =
that has=20
had its Normal generated,Has been split into multiple triangles and has =
been=20
linked to the parent passed into the function by the parents 'Next' =
pointer.This=20
new polygon then becomes the Parent in the call to the next polygon to =
be=20
created.In other words, the first polygons 'Next' pointer points to the =
second=20
polygons 'Next' pointer and so on.<BR><BR>By the time we have reached =
the end of=20
the for/next loops that loop through the rows and columns of the BSPMAP =
we have=20
all the POLYGONS generated and linked together in a linked list.All we =
need is a=20
pointer to the ROOT of this list so we can pass it to the BSP =
Compiler.We have=20
this in the global pointer 'PolygonList' which we used to store the =
POLYGON=20
structure returned from the FIRST call to AddPolygon.We will later pass =
this=20
List of polygons to our BSP Compiler that will compile a BSP Tree out of =

them.<BR><BR>Also notice above that the vertices are of type D3DLVERTEX =
and the=20
diffuse color is just set to bright white,specular to zero and the =
texture=20
coordinates are set so any texture loaded when the polygons are rendered =
will be=20
stretched over the entire polygon.This is of course because our texture=20
coordinates range from 0,0 (top left) to 1,1(bottom right).Texture =
coordinates=20
are in the range of 0 to 1 so this means map the entire texture over the =
wall=20
like a table cloth.In our Demo I have used a texture of a brick wall to =
map onto=20
all the walls so I just set this texture at start up in texture stage 0 =
and=20
leave it there so all walls are rendered using it.<BR><BR>The obvious =
missing=20
piece to the puzzle in the above function 'InitPolygons' is the call to =
the=20
AddPolygons function.This function actually does quite a bit of work.It=20
generates a Normal for the Polygon , but more importantly it constructs =
a=20
polygon using multiple triangles to represent our desired shape.For =
example, we=20
are passing in square walls with four vertices so this function has to =
break=20
this up so that it can be rendered as two triangles.But this is just =
standard=20
D3D stuff anyway.Lets have a look at it a couple of lines at a=20
time.<BR><BR><FONT size=3D2><CODE>POLYGON * AddPolygon(POLYGON* =
Parent,D3DLVERTEX=20
*Vertices,WORD NOV)<BR>{<BR>int loop;<BR>POLYGON * Child=3Dnew=20
POLYGON;<BR>Child-&gt; NumberOfVertices=3DNOV;<BR>Child-&gt;=20
NumberOfIndices=3D(NOV-2)*3;<BR>Child-&gt; Next=3DNULL;<BR>for =
(loop=3D0;loop&lt;=20
NOV;loop++)<BR>{<BR>Child-&gt;=20
VertexList[loop]=3DVertices[loop];<BR>}</CODE></FONT> <BR><BR>The first =
thing this=20
function does is create a new POLYGON structure to hold the polygon that =
is=20
about to be made by this function.We then copy over the number of =
vertices in=20
the polygon (NOV) and also calculate how many Indices we will =
need.Remember we=20
looked at this little formula earlier but for all the walls in our demo =
(which=20
contain 4 vertices) this will be equal to (4-2)*3=3D6 indices.This is =
because a=20
square wall will have to be broken down into two triangles.Each triangle =
is made=20
up of 3 points 3*2=3D6 obviously.We set all the other pointers in the =
POLYGON=20
structure to NULL for now .We then copy all the vertices from the array =
passed=20
into this function over into the polygon structure.Lets have a look at =
the next=20
bit.This is the bit where we are going to fill in the indices array with =
the six=20
points that make up the two triangles that make up our original square=20
wall.Actually you should make sure you understand this code as this code =
will=20
break any complex convex polygon into simple triangles and will probably =
be used=20
many times throughout your applications development.For example the X =
File=20
format stores its polygons in complex format so if you load X files in =
you will=20
have to use code like this to break the faces of an object into=20
triangles.Remember that in the following listing we are calculating the =
contents=20
of the Indices array.Each element in this a ray is a numerical reference =
to a=20
vertex in the vertex list.Heres the code. <BR><BR><FONT =
size=3D2><CODE>//calculate=20
indices<BR>WORD v0,v1,v2;<BR>for (loop=3D0;loop&lt; Child-&gt;=20
NumberOfIndices/3;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>=
v1=3Dv2;<BR>v2++;<BR>}<BR>Child-&gt;=20
Indices[loop*3]=3Dv0;<BR>Child-&gt; =
Indices[(loop*3)+1]=3Dv1;<BR>Child-&gt;=20
Indices[(loop*3)+2]=3Dv2;<BR>}<BR><BR></FONT></CODE>Not very long this =
bit is it=20
when you think how clever it is.Can you see whats happening each time =
through=20
the loop? Get a pen and paper and try it drawing a square with four =
vertices (or=20
any convex shape) and have a look at the indices list you get.Actually =
forget=20
the pen and paper I will fire up my paint package and show you exactly =
what is=20
happening to our wall (square polygon) in this loop. <BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD><IMG height=3D128=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp6.gif"=20
      width=3D128></TD>
    <TD>You can see that the two triangles are created out of the square =
yet=20
      only four Vertices are needed to describe them.The Indices list =
for our=20
      wall would hold 6 entries like =
so:-<BR><BR>v1,v2,v3,v1,v3,v4<BR><BR>Three=20
      Indicies a triangle so two triangles need six Indices.=20
</TD></TR></TBODY></TABLE><BR><BR>So our AddPolygon function has now set =
up the=20
POLYGON structure and filled in the Indices array, the vertex Array and =
filled=20
in the Number of vertices and Indices etc.Our next task is to Generate a =
Normal=20
for the polgon using two edges of the polygon and the <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot2.html">Cross=20
Product</A>.(If you are unfamiliar with the <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot2.html">Cross =
Product</A>=20
please read our Tutorial).As I hope you know at this point a Normal is a =
vector=20
that describes the way the polygon is facing.Although we do not use this =
pre=20
calculated Normal to render the polygon we will need it in many places =
to=20
calculate <A =
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">Dot=20
Product</A> operations later on.<BR><BR><FONT size=3D2><CODE>// generate =
polygon=20
normal<BR>D3DVECTOR * vec0=3D(D3DVECTOR *)=20
&amp;Child-&gt;VertexList[0];<BR>D3DVECTOR * vec1=3D(D3DVECTOR *)=20
&amp;Child-&gt;VertexList[1];<BR>D3DVECTOR * vec2=3D(D3DVECTOR *)=20
&amp;Child-&gt;VertexList[Child-&gt;NumberOfVertices-1];// the last=20
vert<BR>D3DVECTOR edge1=3D(*vec1)-(*vec0);<BR>D3DVECTOR=20
edge2=3D(*vec2)-(*vec0);<BR>Child-&gt;Normal=3DCrossProduct(edge1,edge2);=
<BR>Child-&gt;Normal=3DNormalize(Child-&gt;Normal);<BR><BR></CODE></FONT>=
<BR><BR>As=20
you can see the generated Normal is stored in the POLYGON structures =
'Normal'=20
field which is just a Vector.<BR><BR>Our last job is to link this child =
to the=20
parent (previous polygon we created) which was passed into this function =
as a=20
parameter.This allows each new polygon we create (by calling this =
function) to=20
LINK to the previous polygon created using the previous polygons 'Next'=20
pointer.We must check that the Parent passed in is not NULL though =
because=20
remember the first time we call this function the first polygon will not =
have a=20
parent so we will pass in null.Also notice that this function returns a =
pointer=20
to the child which can then be used as the parent the next time this =
function is=20
called to create a new polygon. The code in the previous function =
'InitPolygons'=20
should now make a lot more sense as you should now see how the linked =
list is=20
created.Heres the last bit of code that assigns the parent.<BR><BR><FONT =

size=3D2><CODE>if =
(Parent!=3DNULL)<BR>{<BR>Parent-&gt;Next=3DChild;<BR>}<BR>return=20
Child;<BR>}<BR></CODE></FONT><BR>Just for completeness here is the above =
code to=20
AddPolygon in its entirety.<BR><BR><FONT size=3D2><CODE>POLYGON *=20
AddPolygon(POLYGON* Parent,D3DLVERTEX *Vertices,WORD NOV)<BR>{<BR>int=20
loop;<BR>POLYGON * Child=3Dnew POLYGON;<BR>Child-&gt;=20
NumberOfVertices=3DNOV;<BR>Child-&gt; =
NumberOfIndices=3D(NOV-2)*3;<BR>Child-&gt;=20
Next=3DNULL;<BR>for (loop=3D0;loop&lt; NOV;loop++)<BR>{<BR>Child-&gt;=20
VertexList[loop]=3DVertices[loop];<BR>}</CODE></FONT> <FONT=20
size=3D2><CODE>//calculate indices<BR>WORD v0,v1,v2;<BR>for =
(loop=3D0;loop&lt;=20
Child-&gt; NumberOfIndices/3;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>=
v1=3Dv2;<BR>v2++;<BR>}<BR>Child-&gt;=20
Indices[loop*3]=3Dv0;<BR>Child-&gt; =
Indices[(loop*3)+1]=3Dv1;<BR>Child-&gt;=20
Indices[(loop*3)+2]=3Dv2;<BR>}</FONT> <FONT size=3D2><CODE>// generate =
polygon=20
normal<BR>D3DVECTOR * vec0=3D(D3DVECTOR *)=20
&amp;Child-&gt;VertexList[0];<BR>D3DVECTOR * vec1=3D(D3DVECTOR *)=20
&amp;Child-&gt;VertexList[1];<BR>D3DVECTOR * vec2=3D(D3DVECTOR *)=20
&amp;Child-&gt;VertexList[Child-&gt;NumberOfVertices-1];// the last=20
vert<BR>D3DVECTOR edge1=3D(*vec1)-(*vec0);<BR>D3DVECTOR=20
edge2=3D(*vec2)-(*vec0);<BR>Child-&gt;Normal=3DCrossProduct(edge1,edge2);=
<BR>Child-&gt;Normal=3DNormalize(Child-&gt;Normal);<BR></CODE></FONT></CO=
DE><FONT=20
size=3D2><CODE>if =
(Parent!=3DNULL)<BR>{<BR>Parent-&gt;Next=3DChild;<BR>}<BR>return=20
Child;<BR>}<BR></FONT></CODE><BR><BR>Ok, we have waffled on forever here =
when=20
this stuff has nothing to do with compiling the actual BSP Tree but it =
was=20
important (I feel) that you understood the way the polygons were =
represented in=20
order to understand the BSP Compiler that will work on them.Just =
remember that=20
each Polygon structure points to the next one with its 'Next' pointer =
and we=20
have a pointer to the root (First poly in the List) .<BR><BR><FONT =
color=3Dgreen=20
size=3D5>
<CENTER><U>Lets Build a BSP Compiler =
Function</U></CENTER></FONT><BR><BR>Ok=20
then, lets get back on track.We have a list of polygons and we want a =
function=20
that is going to build a BSP Tree. Before we call our function we have =
to=20
allocate memory for a Single Node.You may have noticed earlier in our=20
InitPolygons routine that this is where I allocated the memory for the =
Node=20
.Remember that Node structure is exactly what I showed you earlier.It =
has just=20
five fields.A pointer to a POLYGON structure , two pointers to front and =
back=20
nodes and two boolean variables stating whether this node is a leaf and =
if its=20
solid or not.We pass this newly created Node (still empty as none of its =
fields=20
have been set up yet) to our BSP Compiler function along with our list =
of=20
Polygons.When the function returns the BSP Tree will be built and the =
Node we=20
passed into the function will be the Root node in the tree.This is the =
Node we=20
will pass to our render and line of sight functions that will take care =
of=20
traversing down the tree to all the other Nodes in the correct =
order.<BR>Just in=20
case you do not feel like scrolling back up to the InitPolygons function =
the=20
last two lines of that function were as follows.<BR><BR><FONT=20
size=3D2><CODE>BSPTreeRootNode=3Dnew=20
NODE;<BR>BuildBspTree(BSPTreeRootNode,PolygonList);<BR></CODE></FONT><BR>=
That is=20
all we have to do to setup the tree once our BuildBspTree function is=20
written.<BR><BR>Before we write the main Compiler function (which is =
actually=20
quite small) we need a few helper functions that the compiler function =
will need=20
to call.The first function we will write is a small function called=20
'ClassifyPoint'.You may remember that we will also need this function =
when we=20
render the tree also because it checks which side of a Plane a point =
lies on.A=20
point is said to lay behind a plane if it is on the opposite side of the =
plane=20
to the side the plane Normal is facing.In other words if a plane faces =
left=20
(because the Normal faces left) a point on the right side of the plane =
will be=20
Behind the plane.If it is on the right side of this plane then the point =
is said=20
to lay In Front of the plane.If the point lay exactly on the plane then =
it is=20
said to be 'Coincident' with the plane and is neither in front or behind =
the=20
plane .This means we need a function that will take a Point in 3D space =
and a=20
Plane and return one of three results.The result I have defined as =
global=20
integers are CP_BACK,CP_FRONT &amp; CP_ONPLANE. The correct name for the =
3rd=20
integer is really CP_COINCIDENT but I think CP_ONPLANE is much easier to =

understand.This means our 'ClassifyPoint' function will need to return =
one of=20
these three integers as a result.<BR><BR>In case you are starting to =
panic that=20
you do not know how to construct a plane you do not have to.Every =
polygon lies=20
on an infinite plane and as long as you know the Normal for the plane =
(the=20
polygon Normal will do) and we also know the position of a point that is =
known=20
to be on the plane (any vertex in the Polygon will do) we have a Plane =
and can=20
use the DotProduct to find the results.This means our function will take =
a Point=20
in 3D space and a Polygon as its parameters.The function will construct =
the=20
plane from the polygon we pass in .Here is the code:-<BR><BR><FONT=20
size=3D2><CODE>int ClassifyPoint(D3DVECTOR *pos,POLYGON * =
Plane)<BR>{<BR>float=20
result;<BR>D3DVECTOR *vec1=3D(D3DVECTOR *)&amp;Plane-&gt;=20
VertexList[0];<BR>D3DVECTOR=20
Direction=3D(*vec1)-(*pos);<BR>result=3DDotProduct(Direction,Plane-&gt;No=
rmal);<BR>if=20
(result&lt; -0.001) return CP_FRONT;<BR>if (result&gt; 0.001) return=20
CP_BACK;<BR>return CP_ONPLANE;</CODE><BR>}<BR><BR></FONT>This is just =
standard=20
Dot Product stuff so you should know this by now so ill just go over it=20
briefly.First we calculate the direction vector from the position in =
space to a=20
Vertex in the polygon.We then pug this into the Dot Product along with =
the=20
polygons Normal and we have returned the distance to the plane.In this =
code=20
above if the return value is negative (&lt; 0) then the point is in =
front of the=20
plane.If the result is a positive number then we are Behind the polygons =

plane.If the result is zero the point is on the plane (just like one of =
the=20
polygons vertices would be).Notice that because of the accuracy problems =
with=20
floating point numbers (rounding errors) it is possible for the point to =
be on=20
the plane but the result not be EXACTLY zero.For example 0.00001.Because =
of this=20
problem we make the Plane Thicker by using a Fuzzy compare.That's what =
0.001 and=20
the -0.001 is all about.It is a compare that has tolerance for floating =
point=20
rounding errors.<BR><BR>That's our first helper function done.This =
function will=20
be used both in our compiler function and our Render function.For =
example, in=20
our render function we will call ClassifyPoint at each Node in the BSP =
Tree and=20
pass in the Nodes polygon and the current Camera position.If we are in =
front of=20
the current nodes polygon(splitter) we will go down the Nodes Back tree =
first=20
and if we are Behind the Nodes polygon we will go down the current Nodes =
front=20
tree first.<BR><BR>The next function we are going to write will allow us =
to test=20
an entire polygon against a plane.This function will be called 'Classify =
poly'=20
and will step through each vertex in the input polygon and classify that =
point=20
with the plane.This will be used by our BSP Compiler function for =
finding out if=20
a Polygon needs to be split because it straddles another polygons =
Infinite=20
plane.If all the points in the polygon are behind the plane (splitter) =
then the=20
polygon does not need to be split and can be added to the Nodes back =
list.If all=20
the points are in front of the plane then the polygon once again does =
not=20
straddle the plane and can be added un altered to the Node front list of =

polygon.If however some of the points are behind and some of the points =
are in=20
front of the plane then the polygon will have to be split into two and =
the front=20
bit gets added to the front list and the back bit gets added to the back =
bit.We=20
will talk a little later about what happens when the polygon is actually =
sharing=20
the plane with another polygon as we will make a special case for =
this.However=20
if you wanted to you could just choose to send it down any list , front =
or=20
back.<BR><BR>Here is the code to 'ClassifyPolygon' which just does what =
Classify=20
Point does but for every point in the polygon.I could have made =
ClassifyPolygon=20
call ClassifyPoint for each vertex but the code is not that big so I =
duplicated=20
it in the ClassifyPolygon routine as this will save on function call =
over head.=20
<BR><BR><STRONG><U>Note:-</U><BR><BR><FONT size=3D2>There is something a =
little=20
bit strange about OUR 'ClassifyPoly' routine.Normally a function like =
this would=20
return either CP_FRONT,CP_BACK,CP_SPANNING or CP_ONPLANE.The first three =
it will=20
return pointing out that the polygon is either to the Front or Back of =
the plane=20
or is spanning the plane and needs to be split.However you may remember =
that=20
Rule 1 for a Solid BSP was that if a polygon shares a Splitters plane =
then it is=20
to be treated like a Front face and added to the front list.Therefore =
the=20
following code returns CP_FRONT instead of CP_ONPLANE.If you are NOT =
making a=20
Solid BSP you would return CP_ONPLANE and make it share the node as =
shown=20
earlier. </FONT></STRONG><BR><BR><FONT size=3D2><CODE>int =
ClassifyPoly(POLYGON=20
*Plane,POLYGON * Poly)<BR>{<BR>int Infront=3D0;<BR>int =
Behind=3D0;<BR>int=20
OnPlane=3D0;<BR>float result;<BR>D3DVECTOR *vec1=3D(D3DVECTOR=20
*)&amp;Plane-&gt;VertexList[0];<BR>for (int=20
a=3D0;a<POLY->NumberOfVertices;a++)<BR>{<BR>D3DVECTOR *vec2=3D(D3DVECTOR =

*)&amp;Poly-&gt;VertexList[a];<BR>D3DVECTOR=20
Direction=3D(*vec1)-(*vec2);<BR>result=3DDotProduct(Direction,Plane-&gt;N=
ormal);<BR>if=20
(result&gt; 0.001)<BR>{<BR>Behind++;<BR>}<BR>else<BR>if (result&lt;=20
-0.001)<BR>{<BR>Infront++;<BR>}<BR>else<BR>{<BR>OnPlane++;<BR>Infront++;<=
BR>Behind++;<BR>}<BR>}<BR>if=20
(OnPlane=3D=3DPoly-&gt; NumberOfVertices) return CP_FRONT;// this would =
nomrally be=20
CP_ONPLANE<BR>if (Behind=3D=3DPoly-&gt; NumberOfVertices) return =
CP_BACK;<BR>if=20
(Infront=3D=3DPoly-&gt; NumberOfVertices) return CP_FRONT;<BR>return=20
CP_SPANNING;<BR>}<BR><BR></CODE></FONT>Not a lot to explain here.It just =

classifies each point in the Polygon with the Plane (which is passed in =
as a=20
polygon itself) and for each point behind,in front or on the plane a =
counter is=20
kept.At the end of the function if all the vertices are not on the plane =
and all=20
the vertices are not in front of the plane and all the vertices are not =
behind=20
the plane then it means that vertices must be on opposing sides of the =
plane=20
meaning a split will have to be performed.In this case the function =
returns=20
CP_SPANNING.This will tell our compiler function that the polygon needs =
to be=20
split.<BR><BR>There are two more helper functions that need to be =
written=20
also.One of them is 'SplitPolygon' which our compiler will call to split =
a=20
polygon if it straddles a Nodes Polygon(splitter).In other words if=20
ClassifyPolygon returns CP_SPANNING.The SplitPolygon routine though we =
will look=20
at AFTER we have written the BSP Compiler but just be aware of what it =
does.Its=20
prototype is as follows:-<BR><BR><FONT size=3D2><CODE>void =
SplitPolygon(POLYGON=20
*Poly,POLYGON *Plane,POLYGON *FrontSplit,POLYGON=20
*BackSplit);</CODE></FONT><BR><BR>This function takes to Polygon and =
splits the=20
first polygon against the Plane of the second polygon.The function =
splits the=20
first polygon into two new and unique polygons and pointers are returned =
by the=20
function in the FrontSplit and BackSplit pointers.As I said we will look =
at this=20
function later on after we have written the compiler function because I =
want to=20
concentrate on the BSP issue first.<BR><BR>The last helper function we =
will need=20
to write that will be used by our BSP Compiler function will be called=20
'SelectBestSplitter' and will be passed a group of polygons and decide =
which one=20
of these will make the best choice to become the Next splitter.Once the =
splitter=20
is chosen it will be placed in a new Node and all the remaining polygons =
in the=20
list will be assigned to either its front or back list .<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>How Do We Choose the the Best=20
Splitter</U></FONT></CENTER><BR><BR>As you have no doubt grasped by now =
our=20
compiler will call itself repeatedly with sets of polygons and each time =
will=20
choose a polygon out of that list to become the Splitter for that =
node.All the=20
other polygons are assigned to front or back lists which themselves will =
be=20
split and so on until every polygon has been choosen as a splitter.The =
last=20
polygon left in a list will not actually split anything but will just =
create two=20
LEAF nodes that it will add to its own front and back Pointers .The back =
leaf=20
will be a Solid leaf and the front leaf will be an Empty leaf.This Node =
will=20
point to NO other nodes.But how do we decide each time our BSP Compiler =
function=20
is called which single polygon should be used next in the list to split =
the=20
others by.We could actually randomly pick a splitter each time from the =
list but=20
there are good choices and bad choices.<BR><BR>Every time we select a =
new=20
Splitter to divide a given subspace any polygons in the list straddling =
over the=20
splitter (Splitter Polygons Plane) will have to be split into two.That =
means all=20
of a sudden one polygon becomes two polygons.Imagine for example that =
you choose=20
a splitter that intersected every other polygon in the list.Every =
polygon in the=20
list would have to be split in to two.If this was your entire polygon =
set then=20
with the first call to our function we have just DOUBLED the polygon =
count.If=20
you have not caught on yet THIS IS BAD.Now imagine that those split =
polygons=20
have now been assigned to front and back list of the splitter and the =
BSP=20
Compiler function calls itself to find another splitter to divide the =
sub=20
lists.Image the function chooses a splitter in the front list that once =
again=20
intersects every other polygon in the front list and all those polygons =
which=20
are themselves splits from the original list will have to be split =
doubling the=20
size of this list etc.Imagine the same for the original back list and =
within=20
only TWO calls to our BSP Compiler function the polygon count of your 3D =
world=20
has just been QUADRUPLED. Then remember that the BSP Compiler function =
will call=20
itself repeatedly until no polygons remain in front or back list (in =
other words=20
the function will call itself a lot of times for a 10000 polygon level) =
and you=20
can imagine all the splits taking place at each level in the tree would =
leave=20
you with a polygon count that would only allow frame updates =
Sundays.<BR><BR>Now=20
of course the above example is taking it to the extreme but the point is =
that=20
some of the polygons in your levels will need to be split into two and =
these=20
splits may have to be further split into two pieces further down the =
tree.So to=20
build the ultimate BSP Tree then we need our function to calculate which =
order=20
the Splitters should be chosen that creates the least amount of splits. =
You=20
would think this would be a case of building a BSP tree in every single=20
combination at every single node but you would not believe the number of =

combinations that would exist in a simple 5000 set of polygons.If you =
set your=20
computer to figure it out now you would have died of old age before it =
had=20
finished (I'm not joking).This means clearly we are going to have to =
forget=20
about building the perfect BSP Tree and just try and get a good one.What =
we will=20
do is each time the BSP Compiler function repeatedly calls itself with =
polygon=20
lists we will just loop through and choose each one as a splitter in =
turn and=20
record how many polygons it splits.In other words we will decide at each =
level=20
in the tree which polygon splits the least amount of polygons in the =
immediate=20
list.Although at first this may sound the same as the perfect tree you =
must=20
remember that choosing a splitter that causes not many splits at one =
level of=20
the tree could actually cause more splits further down the tree than =
perhaps a=20
splitter which first of all split more polygons. However there is not a =
lot we=20
can do about this so this is the technique we shall use. All sorted then =
? Not=20
quite.<BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D5>What is the Balance of a=20
Tree?</FONT></U></CENTER><BR><BR>Although choosing a splitter that =
creates the=20
least amount of splits is the property most important in my opinion =
there is=20
also the Balance of the tree to consider.A perfectly balanced tree =
(which is=20
hardly ever possible to create) is a bsp tree with exactly the same =
number of=20
nodes behind it and in front of it.The diagram below shows a balanced =
and an=20
unbalanced tree .<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD vAlign=3Dtop align=3Dmiddle width=3D437><BR>
      <CENTER><U><FONT size=3D4><FONT color=3Dgreen>Example of a =
Balanced and=20
      Unbalanced tree showing both the Tree and Wall=20
      layout</FONT></FONT></U></CENTER><BR><BR><BR><IMG height=3D332=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp7.gif"=20
      width=3D435></TD>
    <TD><FONT size=3D2>As you can see the left tree has exactly one node =
behind=20
      the root and one node in front of the root.The right most tree has =
no=20
      nodes in front of it but has two nodes behind it.One very =
important thing=20
      to notice here is that the left most tree has a depth of 1 but the =
right=20
      most tree actually has a depth of 2.By the depth I mean in the =
diagram the=20
      number of nodes vertically descending from the root node.The =
deeper a tree=20
      (the more nodes you have to traverse before you reach a node) the =
more=20
      time it takes to traverse the tree.Sometimes frame rate =
consistency is=20
      more important than out right speed.For example it is better to =
have a=20
      game engine run at 30 fps consistently throughout the level than =
have a=20
      level run at 90fps in some places and drop to 7fps in others.This =
is where=20
      the Balance of the tree comes into play.Although the balance of =
the tree=20
      does not effect OUR rendering routines because we will be using =
the=20
      painters algorithm to draw back to front which means every node =
will be=20
      visited anyway (until we implemement Fustrum rejection bounding =
boxes.more=20
      on this later), the balance will effect the collision detection =
routines=20
      we write later.Look at the right most example in the above =
picture.If we=20
      are in front of R we no longer have to check any walls because =
there are=20
      no front walls in Rs list.However if we are behind wall R we will =
have to=20
      descend into the tree and visit the nodes down the back list.Now =
imagine=20
      this simple example being converted to thousands of polygons and =
you can=20
      see that the frame rate would drop if we were behind wall R and =
speed up=20
      in front of wall R.The balanced tree above would be consistent =
because it=20
      would be equally deep at each leaf node.</FONT>=20
</TD></TR></TBODY></TABLE><BR><BR>There is a problem though because a =
more=20
balanced splitter option may cause more splits in the list.What I =
suggest is=20
this.We will loop through each polygon in the polygon list an score the =
wall=20
with the following formula.The wall with the lowest score in the list =
wins and=20
becomes the splitter for that node.Here's the formula:-<BR><BR><STRONG>
<CENTER><FONT=20
size=3D4>score=3Dabs(frontfaces-backfaces)+(splits*8)</FONT></CENTER></ST=
RONG><BR><BR>You=20
can see that we subtract the front faces with the back faces and get the =

absolute value which will be higher the more un balanced the tree will =
be with=20
this polygon and we then add on to that the number of splits that would =
take=20
place and then multiply this by an amount you think gives more =
importance to=20
splitting.I have used a value of eight here because I think the number =
of splits=20
should be a much higher priority than the balance of the =
tree.<BR><BR>The actual=20
function our compiler will call to choose the best splitter in a given =
list is=20
quite easy to understand.We have already written 'ClassifyPoint' and=20
'ClassifyPolygon' which does the hard work for us.This loops through the =
list of=20
polygons passed in and each time chooses a different splitter and tests =
it=20
against the rest of the polygons in the list.Each time a splitter has =
been=20
considered we end up with the number of splits and the number of front =
and back=20
polygons in the respective lists.We then build the score using the above =
formula=20
and if the score is lower than any previous then we remember this =
polygon.When=20
the function ends it returns a pointer to the polygon in the list with =
the=20
lowest score.Heres the code:- <BR><BR><FONT size=3D2><CODE>POLYGON *=20
SelectBestSplitter(POLYGON *PolyList)<BR>{<BR>POLYGON*=20
Splitter=3DPolyList;<BR>POLYGON* CurrentPoly=3DNULL;<BR>unsigned long=20
BestScore=3D100000;// just set to a very high value to begin<BR>POLYGON =
*=20
SelectedPoly=3DNULL; <BR>while=20
(Splitter!=3DNULL)<BR>{<BR>CurrentPoly=3DPolyList;<BR>unsigned long=20
score,splits,backfaces,frontfaces;<BR>score=3Dsplits=3Dbackfaces=3Dfrontf=
aces=3D0;<BR>while=20
(CurrentPoly!=3DNULL)<BR>{<BR>if (CurrentPoly!=3DSplitter)<BR>{<BR>int=20
result=3DClassifyPoly(Splitter,CurrentPoly);<BR>switch ( =
result)<BR>{<BR>case=20
CP_ONPLANE:<BR>break;<BR>case =
CP_FRONT:<BR>frontfaces++;<BR>break;<BR>case=20
CP_BACK:<BR>backfaces++;<BR>break;<BR>case=20
CP_SPANNING:<BR>splits++;<BR>break;<BR>default:<BR>break;<BR>}<BR>}<BR>Cu=
rrentPoly=3DCurrentPoly-&gt;=20
Next;<BR>}// end while current=20
poly<BR>score=3Dabs(frontfaces-backfaces)+(splits*8);<BR>if (score&lt;=20
BestScore)<BR>{<BR>BestScore=3Dscore;<BR>SelectedPoly=3DSplitter;<BR>}<BR=
>Splitter=3DSplitter-&gt;=20
Next;<BR>}// end while splitter =3D=3D null <BR>return=20
SelectedPoly;<BR>}<BR></CODE></FONT><BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>The BuildBSPTree=20
function</U></FONT></CENTER><BR><BR>The time has come to build the =
actual BSP=20
Compiler function now that we have written all the little helper =
functions=20
(except SplitPolygon which we will write later) that the Compiler =
Needs.So here=20
goes a couple of line at a time.<BR><BR><FONT size=3D2><CODE>void=20
BuildBspTree(NODE * CurrentNode,POLYGON * PolyList)<BR>{<BR>POLYGON=20
*polyTest=3DNULL;<BR>POLYGON *FrontList=3DNULL;<BR>POLYGON=20
*BackList=3DNULL;<BR>POLYGON *NextPolygon=3DNULL;<BR>POLYGON=20
*FrontSplit=3DNULL;<BR>POLYGON *BackSplit=3DNULL;<BR>D3DVECTOR=20
vec1,vec2;<BR>CurrentNode-&gt;=20
Splitter=3DSelectBestSplitter(PolyList);<BR>polyTest=3DPolyList;<BR></COD=
E><BR></FONT>As=20
you can see the function is passed a list of polygons and an empty =
node.Remember=20
that each node has a pointer to a polygon called Splitter.Aboce you can =
see that=20
we fill this Nodes splitter with a pointer returned from the =
SelectBestSplitter=20
function.This is the function we have just written so at this point the =
new Node=20
now has a pointer to a splitter that has been selected rfom the polygon =
list=20
passed into the function. We will se what these other tempory polygon =
pointers=20
are for in a moment.The last thing we do above is assign a tempory =
pointer=20
(polyTest) to PolyList.PolyList after all is the pointer to the polygon =
list so=20
we do not want to manipulate it directly or we will never be able to get =
back to=20
the root of the polygon list.<BR><BR>Next up we have to step through =
each=20
Polygon in the the Polygon list (now pointed at by polyTest) and call=20
'ClassifyPoly' for each polygon to see if it is to the back,front or =
spanning=20
the splitter(Polygon we have just selected and stored in the Node).If =
polyTest=20
equalls NULL then we are at the end of the polygon list so we have to =
check for=20
this.We also use the 'NextPolygon' pointer to point to the next polygon =
to be=20
tested in the list.You will see in a moment that after a polygon has =
been tested=20
as assigned to the relative group (front or back etc) that polygons =
'Next'=20
pointer is altered so that it points to the Next polygon in the front or =
back=20
list and NOT the next polygon in the Global list passed into the =
function.Thats=20
why we have to make a copy of it before it is altered so we can still =
loop=20
through all the polygons in the global list.Also notice the check to =
make sure=20
the the Current Polygon being tested against the splitter is not the =
Splitters=20
itself.If this is the case then the polygon is ignored and skip over it=20
performing no action.This makes sure that the splitter NEVER ends up in =
any of=20
its own lists and it what makes the polygon lists finally empty because =
each=20
time through this function we are loosing a polygon from the list (the=20
splitter).<BR><BR><FONT size=3D2><CODE>while=20
(polyTest!=3DNULL)<BR>{<BR>NextPolygon=3DpolyTest-&gt; Next;// remember =
because=20
polytest-&gt; Next will be altered<BR>if (polyTest!=3DCurrentNode-&gt;=20
Splitter)<BR>{<BR>switch (ClassifyPoly(CurrentNode-&gt;=20
Splitter,polyTest))<BR>{<BR><BR>case CP_FRONT:<BR>polyTest-&gt;=20
Next=3DFrontList;<BR>FrontList=3DpolyTest; <BR>break;<BR><BR>case=20
CP_BACK:<BR>polyTest-&gt; Next=3DBackList;<BR>BackList=3DpolyTest;=20
<BR>break;<BR><BR></CODE></FONT>Nothing special with the first two =
cases.If the=20
polygon is behind or front of the splitter it is added to the =
appropriate=20
lists.Just in case you are confused by the switching around I will =
explain it.In=20
the case of CP_FRONT above, the Current Polygon being tested has its =
next=20
pointer set to point at the 'FrontList' pointer.This will be NULL the =
first time=20
a polygon is assigned to the front list.Then the FrontList pointer is =
altered to=20
point at the newly assigned polygon.In other words the new polygon is =
added to=20
the top of the list and the polygons 'Next' pointer is set to point at =
whatever=20
FrontList pointed at before so we still have a linked list.Notice that =
we have=20
changed the 'Next' Pointer of the polygon which we would normally use to =
look at=20
the next polygon in the global polygon list.We cannot do this now =
because it=20
only points to the back list.This is why we made a copy of this pointer =
above so=20
that we can still step through and access the rest of the =
polygons.<BR><BR>Lets=20
have a look at what happens if the ClassifyPoly function returns=20
CP_SPANNING.This section of code also ties up all the while loops we =
just=20
started.<BR><BR><FONT size=3D2><CODE>case =
CP_SPANNING:<BR>FrontSplit=3Dnew=20
POLYGON;<BR>BackSplit=3Dnew=20
POLYGON;<BR>ZeroMemory(FrontSplit,sizeof(POLYGON));<BR>ZeroMemory(BackSpl=
it,sizeof(POLYGON));<BR>FrontSplit-&gt;=20
DeleteIfSplit=3Dtrue;<BR>BackSplit-&gt;=20
DeleteIfSplit=3Dtrue;<BR>SplitPolygon(polyTest,CurrentNode-&gt;=20
Splitter,FrontSplit,BackSplit);<BR>delete polyTest;<BR>FrontSplit-&gt;=20
Next=3DFrontList;<BR>FrontList=3DFrontSplit;<BR>BackSplit-&gt;=20
Next=3DBackList;<BR>BackList=3DBackSplit;<BR>break;<BR>default:<BR>break;=
<BR>}<BR>}//=20
end if =
polypoint!=3DCurrentNodesplitter<BR>polyTest=3DNextPolygon;<BR>}// end =
while=20
loop<BR><BR></CODE></FONT>If the current polygon being tested does =
straddle the=20
splitter then we create two new polygons and zero the memory.We then =
send these=20
pointers along with the polygons that needs to be split and the Splitter =
it=20
needs to be split against to the 'SplitPolygon' function which will when =
returns=20
will have split the polygon into two halves and they will be pointed to =
by the=20
FrontSplit and BackSplit pointers.Interestingly enough we no longer need =
the=20
orginal polygon so we free up the memory.This may sound strange at first =
but=20
remember a polygon isn't in the tree until it is used as a splitter and =
I may=20
have been split many times by different splitters at this point.If a =
polygon is=20
split and then those to splits are split the first two splits not only =
are not=20
used by the tree anymore but we also loose pointers to them in memory so =
we must=20
free them up here while a valid temporary pointer to the unsplit polygon =
still=20
exists.The FrontSplit and BackSplit pointers which now point to the two =
newly=20
created splits are added to the front list and back list =
respectively.After this=20
polyTest is then reloaded with the orginal 'Next' pointers value which =
of course=20
is the next polygon in the input list.We do this loop for every polygon =
in the=20
input list (ignoring the splitter itself of course so this does not get =
added to=20
any list).<BR><BR>At this point we have divided all the polygons in the =
list to=20
either front or back of the Nodes Splitter.If there are NO polygons in =
the front=20
list then a new Leaf NOde is created and attached to the current nodes =
Front=20
Pointer.This leaf Node is set to be Empty (space you CAN walk about =
in).If there=20
are NO walls in the Back List then once again a new node is created and =
attached=20
to the current nodes Back pointer.Because this node is Behind the =
current Node=20
it is set to be a solid leaf.<BR>If there are polygons in the front list =
a new=20
Node is created and and attched to the Current Nodes Front pointer.This =
function=20
then calls itself sending in the new node and the current node and the =
Front=20
list as the polygon list.Exactly the same happen if there are polygons =
in the=20
Back list except the newly created node is attached to the current nodes =
Back=20
pointer instead of the front obviously.Heres the last bit of the=20
function.<BR><BR><FONT size=3D2><CODE>if =
(FrontList=3D=3DNULL)<BR>{<BR>NODE=20
*leafnode=3Dnew =
NODE;<BR>ZeroMemory(leafnode,sizeof(leafnode));<BR>leafnode-&gt;=20
IsLeaf=3Dtrue;<BR>leafnode-&gt; IsSolid=3Dfalse; <BR>CurrentNode-&gt;=20
Front=3Dleafnode;<BR>}<BR>else<BR>{<BR>NODE * newnode=3Dnew=20
NODE;<BR>ZeroMemory(newnode,sizeof(newnode));<BR>newnode-&gt;=20
IsLeaf=3Dfalse;<BR>CurrentNode-&gt;=20
Front=3Dnewnode;<BR>BuildBspTree(newnode,FrontList);<BR>}<BR>if=20
(BackList=3D=3DNULL)<BR>{<BR>NODE *leafnode=3Dnew=20
NODE;<BR>ZeroMemory(leafnode,sizeof(leafnode));<BR>leafnode-&gt;=20
IsLeaf=3Dtrue;<BR>leafnode-&gt; IsSolid=3Dtrue; <BR>CurrentNode-&gt;=20
Back=3Dleafnode;;<BR>}<BR>else<BR>{<BR>NODE * newnode=3Dnew=20
NODE;<BR>ZeroMemory(newnode,sizeof(newnode));<BR>newnode-&gt;=20
IsLeaf=3Dfalse;<BR>CurrentNode-&gt;=20
Back=3Dnewnode;<BR>BuildBspTree(newnode,BackList);<BR>}<BR>}// end=20
function</CODE><BR><BR></FONT>And that is the compiler totally built.For =

completeness here is the BSP Compiler function in its =
entirety:-<BR><BR><FONT=20
size=3D2><CODE>void BuildBspTree(NODE * CurrentNode,POLYGON *=20
PolyList)<BR>{<BR>POLYGON *polyTest=3DNULL;<BR>POLYGON =
*FrontList=3DNULL;<BR>POLYGON=20
*BackList=3DNULL;<BR>POLYGON *NextPolygon=3DNULL;<BR>POLYGON=20
*FrontSplit=3DNULL;<BR>POLYGON *BackSplit=3DNULL;<BR>D3DVECTOR=20
vec1,vec2;<BR>CurrentNode-&gt;=20
Splitter=3DSelectBestSplitter(PolyList);<BR>polyTest=3DPolyList;<BR></COD=
E><BR></FONT><FONT=20
size=3D2><CODE>while =
(polyTest!=3DNULL)<BR>{<BR>NextPolygon=3DpolyTest-&gt; Next;//=20
remember because polytest-&gt; Next will be altered<BR>if=20
(polyTest!=3DCurrentNode-&gt; Splitter)<BR>{<BR>switch=20
(ClassifyPoly(CurrentNode-&gt; Splitter,polyTest))<BR>{<BR><BR>case=20
CP_FRONT:<BR>polyTest-&gt; Next=3DFrontList;<BR>FrontList=3DpolyTest;=20
<BR>break;<BR><BR>case CP_BACK:<BR>polyTest-&gt;=20
Next=3DBackList;<BR>BackList=3DpolyTest; =
<BR>break;<BR><BR></CODE></FONT><FONT=20
size=3D2><CODE>case CP_SPANNING:<BR>FrontSplit=3Dnew =
POLYGON;<BR>BackSplit=3Dnew=20
POLYGON;<BR>ZeroMemory(FrontSplit,sizeof(POLYGON));<BR>ZeroMemory(BackSpl=
it,sizeof(POLYGON));<BR>FrontSplit-&gt;=20
DeleteIfSplit=3Dtrue;<BR>BackSplit-&gt;=20
DeleteIfSplit=3Dtrue;<BR>SplitPolygon(polyTest,CurrentNode-&gt;=20
Splitter,FrontSplit,BackSplit);<BR>delete polyTest;<BR>FrontSplit-&gt;=20
Next=3DFrontList;<BR>FrontList=3DFrontSplit;<BR>BackSplit-&gt;=20
Next=3DBackList;<BR>BackList=3DBackSplit;<BR>break;<BR>default:<BR>break;=
<BR>}<BR>}//=20
end if =
polypoint!=3DCurrentNodesplitter<BR>polyTest=3DNextPolygon;<BR>}// end =
while=20
loop<BR><BR></CODE></FONT><FONT size=3D2><CODE>if =
(FrontList=3D=3DNULL)<BR>{<BR>NODE=20
*leafnode=3Dnew =
NODE;<BR>ZeroMemory(leafnode,sizeof(leafnode));<BR>leafnode-&gt;=20
IsLeaf=3Dtrue;<BR>leafnode-&gt; IsSolid=3Dfalse; <BR>CurrentNode-&gt;=20
Front=3Dleafnode;<BR>}<BR>else<BR>{<BR>NODE * newnode=3Dnew=20
NODE;<BR>ZeroMemory(newnode,sizeof(newnode));<BR>newnode-&gt;=20
IsLeaf=3Dfalse;<BR>CurrentNode-&gt;=20
Front=3Dnewnode;<BR>BuildBspTree(newnode,FrontList);<BR>}<BR>if=20
(BackList=3D=3DNULL)<BR>{<BR>NODE *leafnode=3Dnew=20
NODE;<BR>ZeroMemory(leafnode,sizeof(leafnode));<BR>leafnode-&gt;=20
IsLeaf=3Dtrue;<BR>leafnode-&gt; IsSolid=3Dtrue; <BR>CurrentNode-&gt;=20
Back=3Dleafnode;;<BR>}<BR>else<BR>{<BR>NODE * newnode=3Dnew=20
NODE;<BR>ZeroMemory(newnode,sizeof(newnode));<BR>newnode-&gt;=20
IsLeaf=3Dfalse;<BR>CurrentNode-&gt;=20
Back=3Dnewnode;<BR>BuildBspTree(newnode,BackList);<BR>}<BR>}// end=20
function</CODE><BR><BR></FONT>Not very big is it when you consider what =
it is=20
doing?The recursive nature of this type of function can confuse some =
people but=20
just remember that the functions calls itself at each node for both the =
front=20
and back lists.Look through it and make sure you really now whats going=20
on.Remember we only call this function once from our InitPolygons =
routine=20
passing in the Complete list of polygons for the game world and a newly =
created=20
Root Node. When the function returns the Root Node contains a valid =
pointer to=20
the entire BSP Tree.<BR><BR>Now of course there is a call to =
'SplitPolygon' in=20
the above function which we have not yet addressed.Lets address it now =
and get=20
it out of the way and then we will look at some more exciting stuff like =

rendering the tree and performing Line of Sight/Collision detection with =
the BSP=20
Tree.<BR><BR><FONT color=3Dgreen size=3D5><U>
<CENTER>Splitting a Polygon with a Plane</CENTER></U></FONT><BR><BR>In =
our <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">Dot =
Product</A>=20
tutorial (which I hope you have either read or fully understand) we =
wrote a=20
function to intersect a Ray with a Plane.This function will be needed by =
our=20
SplitPolygon routine.This is because to intersect a Polygon with a plane =
we=20
simply treat each edge of the polygon as a seperate ray.Although I am =
not going=20
to explain the 'GetIntersect' routine here because it is fully explained =
in our=20
Dot Product tutorial I will show you the code for the function for=20
completeness.The following function is slightly different from the one =
in our=20
DotProduct tutorial as it takes an extra parameter.The function accepts =
six=20
parameters.The start and End of the Ray in world coordinates and a Point =
on the=20
plane that needs to be tested against the ray and the plane normal.The =
last two=20
parameters are filled by the function on return.If the function returns =
true=20
then an intersection between the start point and the end point has =
occured with=20
the plane.If this is the case on return then 'intersection' will point =
to a=20
vector containing the point in world coordinates that the ray hit the =
plane and=20
'percentage' is the new parameter we have added since the Dot Product=20
tutorial.This will point to a float that represents how far down the ray =
from=20
start point the intersection has happened as a percentage of the overall =
ray=20
length.This value is between 0 (0%=3Dline start) and 1(100%=3Dline =
end).This reason=20
we need this percentage returned is because when we carve our polygon up =
we will=20
need to carve up and add new texture coordinates as well.We will see how =
this=20
value is used then. <BR><BR><FONT size=3D1><CODE>bool Get_Intersect =
(D3DVECTOR=20
*linestart,D3DVECTOR *lineend,D3DVECTOR *vertex,D3DVECTOR =
*normal,D3DVECTOR *=20
intersection, float *percentage)<BR>{<BR>D3DVECTOR =
direction,L1;<BR>float=20
linelength,dist_from_plane;<BR><BR>direction.x=3Dlineend-&gt;x-linestart-=
&gt;x;<BR>direction.y=3Dlineend-&gt;y-linestart-&gt;y;<BR>direction.z=3Dl=
ineend-&gt;z-linestart-&gt;z;<BR><BR>linelength=3DDotProduct(direction,*n=
ormal);<BR><BR>if=20
(fabsf(linelength)&lt;0.0001)<BR>{<BR>return=20
false;<BR>}<BR><BR>L1.x=3Dvertex-&gt;x-linestart-&gt;x;<BR>L1.y=3Dvertex-=
&gt;y-linestart-&gt;y;<BR>L1.z=3Dvertex-&gt;z-linestart-&gt;z;<BR><BR>dis=
t_from_plane=3DDotProduct(L1,*normal);<BR>*percentage=3Ddist_from_plane/l=
inelength;=20
<BR><BR>if (*percentage&lt;0.0f) <BR>{<BR>return =
false;<BR>}<BR>else<BR>if=20
(*percentage&gt;1.0f) <BR>{<BR>return false;<BR>}<BR>else=20
<BR><BR>intersection-&gt;x=3Dlinestart-&gt;x+direction.x*(*percentage);<B=
R>intersection-&gt;y=3Dlinestart-&gt;y+direction.y*(*percentage);<BR>inte=
rsection-&gt;z=3Dlinestart-&gt;z+direction.z*(*percentage);<BR>return=20
true;<BR>}</CODE></FONT><BR><BR>Like I said earlier, if the above code =
looks a=20
little strange to you our <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">Dot =
Product</A>=20
tutorial will take you through it Line by Line.<BR><BR>Now lets write =
that=20
SplitPolygon routine.You might imagine it would be difficult but with =
our=20
GetIntersect function above we simply have to step through each edge of =
the test=20
polygon and treat it as a ray and call GetIntersect above to retrieve =
the=20
intersection point.Remember that we are testing a polygon against the =
Splitter=20
at each node so the when we cal GetIntersect above we pas in the two =
vertices=20
that make up the current edge of the polygon, then we need to pass the=20
GetIntersect routine some information about the Plane.This ofcourse is =
the plane=20
that our Splitter polygon lays on so we simply pass in any vertex in the =

Splitter polygon (vertex[0] will do?) and the Normal of the splitter.We =
have all=20
this information stored in the splitter so thats no problem.<BR><BR>Lets =
now=20
look at the 'SplitPolygon' routine a couple of lines at a =
time.<BR><BR><FONT=20
size=3D2><CODE>void SplitPolygon(POLYGON *Poly,POLYGON *Plane,POLYGON=20
*FrontSplit,POLYGON *BackSplit)<BR>{<BR></CODE></FONT><BR>Just to =
refresh your=20
memory, this function is called from our BuildBSPTree function when a =
polygon=20
has been tested against the current splitter and is found to be spanning =

it.Parameter 1 (Poly) is the polygon that needs to be split into two and =

parameter 2(plane) is the Splitter polygon that needs to divide the =
polygon in=20
two.The last two parameters are empty at the moment and will be filled =
in by=20
this function and will return two new polygons that are the result of =
the=20
split.<BR><BR>First we set up some local variables that will be used =
throughout=20
the function.FrontList and BackList are arrays of vertices to contains =
the=20
vertices for the newly created front and back polygon splits.As each =
point is=20
classified as point to the front or the back of the plane it will be =
added to=20
these lists.<BR><BR><FONT size=3D2><CODE>D3DLVERTEX=20
FrontList[20],BackList[20],FirstVertex;<BR>D3DVECTOR=20
PlaneNormal,IntersectPoint,PointOnPlane,PointA,PointB;<BR>WORD=20
FrontCounter=3D0,BackCounter=3D0,loop=3D0,CurrentVertex=3D0;<BR>float =
percent;=20
<BR><BR><FONT color=3Dgreen>// Find any vertex on the plane to use later =
in plane=20
intersect routine</FONT><BR>PointOnPlane=3D*(D3DVECTOR=20
*)&amp;Plane-&gt;VertexList[0];<BR><BR></CODE></FONT>The first thing we =
do above=20
is store the first vertex of the splitter polygon in the PointOnPlane =
vector.The=20
line may look a bit weird with all its casting etc but remember that the =
first=20
part of a D3DLVERTEX structure is just a vector so can be cast as =
such.We will=20
use this PointOnPlane variable later when we call the GetIntersect=20
routine.<BR><BR>The first thing we must do is take a look at the First =
Vertex in=20
the polygon (not the Splitter polygon, the one we are trying to split) =
and find=20
which side of the Splitter this point is on and add that vertex to the=20
respective vertex array (Frontlist or Backlist).This means that if a =
point is in=20
front of the Splitter then that vertex will be in the Front polygon =
created.Vice=20
versa for the Back list.If the vertex is on the plane (sharing the plane =
with=20
Splitter) then the same vertex is added to BOTH lists because it will be =
needed=20
in both polygons:-<BR><BR><FONT size=3D2><CODE><FONT color=3Dgreen>// =
first we find=20
out if the first vertex belongs in front or back=20
list</FONT><BR>FirstVertex=3DPoly-&gt;VertexList[0];<BR>switch =
(ClassifyPoint(=20
(D3DVECTOR *)&amp;FirstVertex,Plane))<BR>{<BR>case=20
CP_FRONT:<BR>FrontList[FrontCounter++]=3DFirstVertex;<BR>break;<BR>case=20
CP_BACK:<BR>BackList[BackCounter++]=3DFirstVertex;<BR>break;<BR>case=20
CP_ONPLANE:<BR>BackList[BackCounter++]=3DFirstVertex;<BR>FrontList[FrontC=
ounter++]=3DFirstVertex;<BR>break;<BR>default:<BR>break;<BR>}<BR><BR></CO=
DE></FONT>As=20
you have probably gathered the whole purpose of this function is just to =

classify edges of the polygon to the splitter and assigned them to the =
relative=20
lists.Once we have done this we we have two lists which we can then =
construct=20
the polygons out of.<BR><BR>Now that we have the first vertex in the =
correct=20
list(or lists if on plane) we now have to loop through the rest of the =
vertex.We=20
start though at the second vertex in the polygon and compare it to the =
previous=20
vertex.If they are on opposing sides of the splitter then an =
intersection with=20
the plane has occurred and a new vertex needs to be created and added to =
both=20
lists.Lists have a look at a picture and we will have a look at the =
splitting=20
technique in more detail.<BR><BR>
<TABLE border=3D1 <TR>
  <TBODY>
  <TR>
    <TD><U><FONT color=3Dgreen>
      <CENTER>Splitting a Polygon with a=20
      Plane</CENTER></FONT></U><BR><BR><BR><BR><BR><IMG height=3D256=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp30.gif"=20
      width=3D256></TD>
    <TD><FONT size=3D2>We have already assigned V0 to the front list in =
our=20
      example with the preceeding code.Now we loop through vertices 1 =
though=20
      0(again) and each edge being tested is the Current Vertex with the =

      previous.So for example we test point 1 &amp; 0 then point 2 &amp; =
1=20
      etc.<BR>This is how it works using the example opposite.We test v1 =
and v0=20
      and discover they are both on the front side of the splitter so v1 =
gets=20
      added to the Front list (which already contains v0) and so all is=20
      done.Next we compare v2 with v1 and discover they are on opposing =
sides of=20
      the splitter so we call GetIntersect which will return the =
position of the=20
      new vertex on the split line (v1a opposite).This intersection is =
added to=20
      both lists and v2 is added to the back list.<BR><BR>Front List so =
far=20
      contains : v0,v1,v1a <BR>Back List so far contains : =
v1a,v2.<BR><BR>Now=20
      next time through the loop we test v3 with v2 and they are both =
behind the=20
      plane so v3 gets added to the back list.We then loop round to =
compare v4=20
      with v3 and find another intersection.The intersection (v3a) is =
added to=20
      the back list and the front list and v4 is added to the front list =

      also.<BR><BR>Front List so far contains : v0,v1,v1a,v3a,v4<BR>Back =
List so=20
      far contains : v1a,v2,v3,v3a<BR><BR>We then loop through again but =
roll=20
      back over to test zero and the previous vertex (v4) there is no =
split they=20
      are both on the same side of the plane but because this is vertex =
zero=20
      which is already in the list it does not get added to any list and =
we are=20
      done.However had there been a split between v4 &amp; v0 (lets call =
it v4a)=20
      then v4a would have been added to both front and back =
lists.</FONT>=20
  </TD></TR></TBODY></TABLE><BR><BR>So we are now going to loop through =
from=20
vertices one (not zero because its already in the list) through zero =
putting in=20
a bit of logic to make sure that we roll back over to zero after the =
last=20
vertex.<BR><BR><FONT size=3D2><CODE>for=20
(loop=3D1;loop&lt;Poly-&gt;NumberOfVertices+1;loop++)<BR>{<BR>if=20
(loop=3D=3DPoly-&gt;NumberOfVertices)=20
<BR>{<BR>CurrentVertex=3D0;<BR>}<BR>else<BR>{<BR>CurrentVertex=3Dloop;<BR=
>}<BR>PointA=3D*(D3DVECTOR=20
*)&amp;Poly-&gt;VertexList[loop-1];<BR>PointB=3D*(D3DVECTOR=20
*)&amp;Poly-&gt;VertexList[CurrentVertex];<BR><BR></CODE></FONT>As you =
can see=20
we loop through the vertices of the polygon that needs to be split.The =
current=20
vertex to be worked on is equal to the current value of the loop unless =
it we=20
have rolled over the last vertex which means we set the current vertex =
to zero.=20
At this point we now know the two vertices that make up the edge we are =
going to=20
test.PointA a takes the previous vertex in the polygon (which would have =
already=20
been assigned to a list) and casts it to a D3DVECTOR so that we can use =
it with=20
all our functions and PointB casts the current vertex (not in any list =
yet) to a=20
D3DVECTOR.In other words, the first time through the loop PointA will =
hold=20
vertex zero and PointB will hold vertex one.This ofcourse makes up the =
first=20
edge.<BR><BR>Next up we classify PointB with the plane to get which side =
of the=20
plane it is on.If it is actually ON the plane then this vertex is added =
to both=20
lists. <FONT size=3D2><CODE>PlaneNormal=3DPlane-&gt;Normal;<BR>int=20
Result=3DClassifyPoint(&amp;PointB,Plane);<BR>if=20
(Result=3D=3DCP_ONPLANE)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;Verte=
xList[CurrentVertex];<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexList[=
CurrentVertex];<BR>}<BR>else<BR>{<BR><BR></CODE></FONT>If=20
PointB is not on the plane then we test for an intersection with the =
plane.We=20
call GetIntersect passing in PointA,PointB and the Ray start and end and =
also=20
pass in the Point on the plane we got earlier (first vertex in the =
splitter) and=20
the Plane Normal(splitters Normal).If this function returns 'true' =
IntersecPoint=20
will hold the X,Y,Z of the new vertex created by the split that is on =
the plane=20
(v1a or v3a in the above example).We can create a new vertex out of this =

vector.Also if the function returns 'true' the float 'percentage' will =
hold how=20
far down the ray from the start (as a percentage between 0 and 1) the=20
intersection occurred.We will use this for generating a NEW texture =
coordinate=20
for the NEW vertex.<BR><BR><FONT size=3D2><CODE>if=20
(Get_Intersect(&amp;PointA,&amp;PointB,&amp;PointOnPlane,&amp;PlaneNormal=
,&amp;IntersectPoint,=20
&amp;percent)=3D=3Dtrue)<BR>{<BR><BR></CODE></FONT>If we pass the test =
and a=20
collision has occurred we already have the new vertex position in=20
'IntersectPoint'.When I First wrote my compiler the level was not =
texture=20
mapped.I simply created a new vertex out of the IntersectPoint returned =
and fely=20
very happy with my self until I tried to to texture the level and all =
the=20
textures screwed up.I forgot that the new vertex is going to need a new =
Texture=20
Coordinate.This was quite easy to overcome (after a bit of thought) =
which is why=20
the 'GetIntersect' function was modified to also return a =
percentage.Lets see=20
how it works.(I assume you are familiar with the Normalized Texture =
Coordinates=20
that D3D uses).<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD vAlign=3Dtop><BR><FONT color=3Dgreen>
      <CENTER><U>Interpolating the New Texture=20
      Coordinate</U></CENTER></FONT><BR><BR><IMG height=3D195=20
      =
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp31.gif"=20
      width=3D219></TD>
    <TD><FONT size=3D2>The picture opposite shows how a triangle polygon =
may be=20
      mapped to a texture.You can see the texture coordinates for v1 and =
v2.The=20
      red line shows where an intersection with the plane has occurred =
with this=20
      polygon and infact shows the point that a new texture coordinate =
needs to=20
      be created for.First of all we subtract the first vertex texture=20
      coordintes from the second and we end up with the Vector Length of =
the=20
      line between v1 and v2 on the texture.You can see opposite that=20
      &lt;0.8,0.7&gt;-&lt;0.4,0.2&gt;=3D&lt;0.4,0.5&gt; which is the =
direction and=20
      the length between texture coordinate 1 &amp; 2.Now the great =
thing is=20
      that our GetIntersect function returned a percentage from the =
start of the=20
      line that the intersect occurred.We can reuse this value for =
texture=20
      coordinates as well.For example imagine that the percentage =
returned by=20
      GetIntersect is 0.5 meaning that the plane intersect the polygon =
exactly=20
      half way between vertex 1 &amp; vertex 2.If we multiply the Vector =

      opposite (vector length) by the percentage (0.5 in this example) =
we get a=20
      vector of <BR><BR>
      <CENTER>&lt;0.4*0.5 , 0.5 * 0.5&gt;.=3D&lt;0.2 , 0.25&gt; =
</CENTER><BR>Now=20
      just add this vector so it is relative to the start point (the =
start of=20
      the ray or in our case the first vertices texture =
coordinates)<BR><BR>New=20
      Texture Coordinates=3D&lt;0.4 , 0.2&gt; + &lt;0.2 , =
0.25&gt;=3D&lt;0.6 ,=20
      0.45&gt;<BR><BR>This same interpolation could also be used for =
calculating=20
      a Vertex light value as=20
well.<BR><BR></FONT></TD></TR></FONT></TBODY></TABLE><BR>Here's the code =
that=20
calculates the new texture coordinates and creates a new =
vertex.<BR><BR><FONT=20
size=3D2><CODE>float=20
deltax,deltay,texx,texy;<BR>deltax=3DPoly-&gt;VertexList[CurrentVertex].t=
u-Poly-&gt;VertexList[loop-1].tu;<BR>deltay=3DPoly-&gt;VertexList[Current=
Vertex].tv-Poly-&gt;VertexList[loop-1].tv;<BR>texx=3DPoly-&gt;VertexList[=
loop-1].tu+(deltax*percent);<BR>texy=3DPoly-&gt;VertexList[loop-1].tv+(de=
ltay*percent);<BR>D3DLVERTEX=20
copy=3DD3DLVERTEX(IntersectPoint,RGB_MAKE(255,255,255),0,texx,texy);<BR><=
BR></CODE></FONT>Now=20
we have the new Vertex and we know we have to add it to both front and =
back=20
polygon list (because it belongs in both the front split and the back =
split=20
polygons) but we also have to put the Current Vertex into the correct =
list=20
also.If PointB is in front of the splitter then we add the New Vertex to =
Both=20
lists and then add PointB to the Front List AS LONG AS the current =
vertex is NOT=20
vertex zero because this one would already be in the list.The same is =
true if=20
PointB is behind the splitter but the other way around obviously. =
<BR><BR><FONT=20
size=3D2><CODE>if (Result=3D=3DCP_FRONT=20
)<BR>{<BR>BackList[BackCounter++]=3Dcopy;<BR>FrontList[FrontCounter++]=3D=
copy;<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexL=
ist[CurrentVertex];<BR>}<BR>}=20
<BR><BR>if=20
(Result=3D=3DCP_BACK)<BR>{<BR>FrontList[FrontCounter++]=3Dcopy;<BR>BackLi=
st[BackCounter++]=3Dcopy;=20
<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;VertexLis=
t[CurrentVertex];<BR>}<BR>}=20
<BR><BR>}// end if intersection (get=20
intersect=3D=3Dtrue)<BR><BR>else<BR></CODE></FONT><BR>Ok then thats the =
code taken=20
care of for if an edge intersects the splitter , but if this is not the =
case=20
then the Current Vertex and the Last previous vertex are both to one =
side if the=20
plane.If this is the case we simply stick the Current Vertex into the=20
appropriate lists.Once again though only if the Current Vertex is NOT =
vertex=20
zero because this was put in the list at the start of the =
function<BR><BR>.=20
<FONT size=3D2><CODE>{<BR>if (Result=3D=3DCP_FRONT)<BR>{<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexL=
ist[CurrentVertex];<BR>}<BR>}<BR><BR>if=20
(Result=3D=3DCP_BACK) <BR>{<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;VertexLis=
t[CurrentVertex];<BR>}<BR>}<BR>}<BR><BR>}<BR>}//end=20
loop through each edge<BR><BR><BR></CODE></FONT>At this point in the =
function we=20
all the loops have ended and we have two lists of vertices.One for the =
front=20
split polygon and one for the back split polygon.The remainder of the =
function=20
simply builds the polygons using exactly the same technique as we used =
earlier=20
in our AddPolygon routine.It copies the Vertex Lists in to the Front and =
Back=20
split polygon structures, Calculates the indices (because remember even =
if a=20
triangle is split with a plane one of the splits will now have four =
vertices)=20
and cuilds the indices for each polygon.Then as a last step it generates =
the=20
polygon Normals for the two polygons.Heres the rest of the=20
function:-<BR><BR><FONT size=3D2><CODE><FONT color=3Dgreen>//OK THEN =
LETS BUILD=20
THESE TWO POLYGONAL BAD=20
BOYS</FONT><BR><BR>FrontSplit-&gt;NumberOfVertices=3D0;<BR>BackSplit-&gt;=
NumberOfVertices=3D0;<BR><BR>for=20
(loop=3D0;loop&lt;FrontCounter;loop++)<BR>{<BR>FrontSplit-&gt;NumberOfVer=
tices++;<BR>FrontSplit-&gt;VertexList[loop]=3DFrontList[loop];<BR>}<BR><B=
R>for=20
(loop=3D0;loop&lt;BackCounter;loop++)<BR>{<BR>BackSplit-&gt;NumberOfVerti=
ces++;<BR>BackSplit-&gt;VertexList[loop]=3DBackList[loop];<BR>}<BR><BR>Ba=
ckSplit-&gt;NumberOfIndices=3D(BackSplit-&gt;NumberOfVertices-2)*3;<BR>Fr=
ontSplit-&gt;NumberOfIndices=3D(FrontSplit-&gt;NumberOfVertices-2)*3;<BR>=
<BR><FONT=20
color=3Dgreen>// Fill in the Indices Array</FONT><BR><BR>WORD =
v0,v1,v2;<BR>for=20
(loop=3D0;loop&lt;FrontSplit-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>=
v1=3Dv2;<BR>v2++;<BR>}<BR>FrontSplit-&gt;Indices[loop*3]=3Dv0;<BR>FrontSp=
lit-&gt;Indices[(loop*3)+1]=3Dv1;<BR>FrontSplit-&gt;Indices[(loop*3)+2]=3D=
v2;<BR>}<BR><BR>for=20
(loop=3D0;loop&lt;BackSplit-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if =
(loop=3D=3D0)=20
<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>v1=3Dv2;<BR>v=
2++;<BR>}<BR>BackSplit-&gt;Indices[loop*3]=3Dv0;<BR>BackSplit-&gt;Indices=
[(loop*3)+1]=3Dv1;<BR>BackSplit-&gt;Indices[(loop*3)+2]=3Dv2;<BR>}<BR><BR=
><FONT=20
color=3Dgreen>// calculate polygon Normals</FONT><BR><BR>D3DVECTOR=20
edge1,edge2;<BR>edge1=3D*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[1]]-*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[0]];<BR><BR>edge2=
=3D*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[FrontSplit-&gt;Nu=
mberOfIndices-1]]-*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[0]];<BR><BR>Front=
Split-&gt;Normal=3DCrossProduct(edge1,edge2);<BR>FrontSplit-&gt;Normal=3D=
Normalize(FrontSplit-&gt;Normal);<BR><BR>edge1=3D*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[1]]-*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[0]];<BR><BR>edge2=3D=
*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[BackSplit-&gt;Numbe=
rOfIndices-1]]-*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[0]];<BR><BR>BackSpl=
it-&gt;Normal=3DCrossProduct(edge1,edge2);<BR>BackSplit-&gt;Normal=3DNorm=
alize(BackSplit-&gt;Normal);<BR>}<BR><BR></CODE></FONT>Phew,=20
that function was larger than the actual BSP Compiler function.But it is =
the=20
last function needed to make our BSP Compiler function work.Once again =
then ,=20
here is the Split Polygon Function in its entirety.<BR><BR><FONT=20
size=3D1><CODE>void SplitPolygon(POLYGON *Poly,POLYGON *Plane,POLYGON=20
*FrontSplit,POLYGON *BackSplit)<BR>{<BR>D3DLVERTEX=20
FrontList[20],BackList[20],FirstVertex;<BR>D3DVECTOR=20
PlaneNormal,IntersectPoint,PointOnPlane,PointA,PointB;<BR>WORD=20
FrontCounter=3D0,BackCounter=3D0,loop=3D0,CurrentVertex=3D0;<BR>float =
percent;=20
<BR><BR><FONT color=3Dgreen>// Find any vertex on the plane to use later =
in plane=20
intersect routine</FONT><BR>PointOnPlane=3D*(D3DVECTOR=20
*)&amp;Plane-&gt;VertexList[0];<BR><BR></CODE></FONT><FONT =
size=3D1><CODE><FONT=20
color=3Dgreen>// first we find out if the first vertex belongs in front =
or back=20
list</FONT><BR>FirstVertex=3DPoly-&gt;VertexList[0];<BR>switch =
(ClassifyPoint(=20
(D3DVECTOR *)&amp;FirstVertex,Plane))<BR>{<BR>case=20
CP_FRONT:<BR>FrontList[FrontCounter++]=3DFirstVertex;<BR>break;<BR>case=20
CP_BACK:<BR>BackList[BackCounter++]=3DFirstVertex;<BR>break;<BR>case=20
CP_ONPLANE:<BR>BackList[BackCounter++]=3DFirstVertex;<BR>FrontList[FrontC=
ounter++]=3DFirstVertex;<BR>break;<BR>default:<BR>break;<BR>}<BR><BR></CO=
DE></FONT><FONT=20
size=3D1><CODE>for =
(loop=3D1;loop&lt;Poly-&gt;NumberOfVertices+1;loop++)<BR>{<BR>if=20
(loop=3D=3DPoly-&gt;NumberOfVertices)=20
<BR>{<BR>CurrentVertex=3D0;<BR>}<BR>else<BR>{<BR>CurrentVertex=3Dloop;<BR=
>}<BR>PointA=3D*(D3DVECTOR=20
*)&amp;Poly-&gt;VertexList[loop-1];<BR>PointB=3D*(D3DVECTOR=20
*)&amp;Poly-&gt;VertexList[CurrentVertex];<BR><BR></CODE></FONT><FONT=20
size=3D1><CODE>PlaneNormal=3DPlane-&gt;Normal;<BR>int=20
Result=3DClassifyPoint(&amp;PointB,Plane);<BR>if=20
(Result=3D=3DCP_ONPLANE)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;Verte=
xList[CurrentVertex];<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexList[=
CurrentVertex];<BR>}<BR>else<BR>{<BR><BR></CODE></FONT><FONT=20
size=3D1><CODE>if=20
(Get_Intersect(&amp;PointA,&amp;PointB,&amp;PointOnPlane,&amp;PlaneNormal=
,&amp;IntersectPoint,=20
&amp;percent)=3D=3Dtrue)<BR>{<BR><BR></CODE></FONT><FONT =
size=3D1><CODE>float=20
deltax,deltay,texx,texy;<BR>deltax=3DPoly-&gt;VertexList[CurrentVertex].t=
u-Poly-&gt;VertexList[loop-1].tu;<BR>deltay=3DPoly-&gt;VertexList[Current=
Vertex].tv-Poly-&gt;VertexList[loop-1].tv;<BR>texx=3DPoly-&gt;VertexList[=
loop-1].tu+(deltax*percent);<BR>texy=3DPoly-&gt;VertexList[loop-1].tv+(de=
ltay*percent);<BR>D3DLVERTEX=20
copy=3DD3DLVERTEX(IntersectPoint,RGB_MAKE(255,255,255),0,texx,texy);<BR><=
BR></CODE></FONT><FONT=20
size=3D1><CODE>if (Result=3D=3DCP_FRONT=20
)<BR>{<BR>BackList[BackCounter++]=3Dcopy;<BR>FrontList[FrontCounter++]=3D=
copy;<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexL=
ist[CurrentVertex];<BR>}<BR>}=20
<BR><BR>if=20
(Result=3D=3DCP_BACK)<BR>{<BR>FrontList[FrontCounter++]=3Dcopy;<BR>BackLi=
st[BackCounter++]=3Dcopy;=20
<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;VertexLis=
t[CurrentVertex];<BR>}<BR>}=20
<BR><BR>}// end if intersection (get=20
intersect=3D=3Dtrue)<BR><BR>else<BR></CODE></FONT><FONT =
size=3D1><CODE>{<BR>if=20
(Result=3D=3DCP_FRONT)<BR>{<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexL=
ist[CurrentVertex];<BR>}<BR>}<BR><BR>if=20
(Result=3D=3DCP_BACK) <BR>{<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;VertexLis=
t[CurrentVertex];<BR>}<BR>}<BR>}<BR><BR>}<BR>}//end=20
loop through each edge<BR><BR><BR>//OK THEN LETS BUILD THESE TWO =
POLYGONAL BAD=20
BOYS<BR><BR>FrontSplit-&gt;NumberOfVertices=3D0;<BR>BackSplit-&gt;NumberO=
fVertices=3D0;<BR><BR>for=20
(loop=3D0;loop&lt;FrontCounter;loop++)<BR>{<BR>FrontSplit-&gt;NumberOfVer=
tices++;<BR>FrontSplit-&gt;VertexList[loop]=3DFrontList[loop];<BR>}<BR><B=
R>for=20
(loop=3D0;loop&lt;BackCounter;loop++)<BR>{<BR>BackSplit-&gt;NumberOfVerti=
ces++;<BR>BackSplit-&gt;VertexList[loop]=3DBackList[loop];<BR>}<BR><BR>Ba=
ckSplit-&gt;NumberOfIndices=3D(BackSplit-&gt;NumberOfVertices-2)*3;<BR>Fr=
ontSplit-&gt;NumberOfIndices=3D(FrontSplit-&gt;NumberOfVertices-2)*3;<BR>=
<BR><FONT=20
color=3Dgreen>// Fill in the Indices Array</FONT><BR><BR>WORD =
v0,v1,v2;<BR>for=20
(loop=3D0;loop&lt;FrontSplit-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>=
v1=3Dv2;<BR>v2++;<BR>}<BR>FrontSplit-&gt;Indices[loop*3]=3Dv0;<BR>FrontSp=
lit-&gt;Indices[(loop*3)+1]=3Dv1;<BR>FrontSplit-&gt;Indices[(loop*3)+2]=3D=
v2;<BR>}<BR><BR>for=20
(loop=3D0;loop&lt;BackSplit-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if =
(loop=3D=3D0)=20
<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>v1=3Dv2;<BR>v=
2++;<BR>}<BR>BackSplit-&gt;Indices[loop*3]=3Dv0;<BR>BackSplit-&gt;Indices=
[(loop*3)+1]=3Dv1;<BR>BackSplit-&gt;Indices[(loop*3)+2]=3Dv2;<BR>}<BR><BR=
><FONT=20
color=3Dgreen>// calculate polygon Normals</FONT><BR><BR>D3DVECTOR=20
edge1,edge2;<BR>edge1=3D*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[1]]-*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[0]];<BR><BR>edge2=
=3D*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[FrontSplit-&gt;Nu=
mberOfIndices-1]]-*(D3DVECTOR=20
*)&amp;FrontSplit-&gt;VertexList[FrontSplit-&gt;Indices[0]];<BR><BR>Front=
Split-&gt;Normal=3DCrossProduct(edge1,edge2);<BR>FrontSplit-&gt;Normal=3D=
Normalize(FrontSplit-&gt;Normal);<BR><BR>edge1=3D*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[1]]-*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[0]];<BR><BR>edge2=3D=
*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[BackSplit-&gt;Numbe=
rOfIndices-1]]-*(D3DVECTOR=20
*)&amp;BackSplit-&gt;VertexList[BackSplit-&gt;Indices[0]];<BR><BR>BackSpl=
it-&gt;Normal=3DCrossProduct(edge1,edge2);<BR>BackSplit-&gt;Normal=3DNorm=
alize(BackSplit-&gt;Normal);<BR>}<BR><BR></CODE></FONT><BR><BR>If=20
you have never done any sort of polygon clipping before then that was =
probably=20
pretty hard going for you but the same function can be reused in other=20
applications.For example the same function could be used to clip =
polygons to the=20
plane of the View Fustrum although you would want to optimize it to make =
it=20
faster .However all our splitting is done at the start of the =
application (and=20
would normally be done in development) so it's not a problem.<BR><BR>If =
you have=20
stayed with me up to here then first of all give youself a pat on the =
back.We=20
now have created all the functions to build a BSP tree.All we have to do =
is call=20
BuildBSPTree and pass in an empty root node and a list of polygon and =
whent he=20
function returns all the polygons will be split and assigned to the =
appropriate=20
nodes in the tree.You are now ready to start using that BSPTree to =
render your=20
level and perform Line of Sight/Collision determination. <BR><BR>
<CENTER><U><FONT size=3D5><FONT color=3Dgreen>We have a BSP Tree but How =
do we=20
Render It</FONT></FONT></U></CENTER><BR><BR>Rendering is easy.We will =
now build=20
a function that will be passed the Root node to the tree and will render =
the=20
entire level in Back to Front order.Note that you can also render in =
Front to=20
Back order if a Z-Buffer is being used (or some other VSD method).Using =
a=20
Z-Buffer and drawing front to back will reduce overdraw and speed up =
drawing but=20
will not cater for Translucent objects which must still be rendered back =
to=20
front.There for our function will render back to front so a Z-Buffer is =
not=20
needed and Translucent objects will display correctly (windows,glass, =
etc).The=20
function is so small that changing it from a Back to Font renderer to a =
Front to=20
Back renderer should be a piece of cake for you.Here is the function =
that will=20
be called every frame to render the entire BSP Tree.It is called =
WalkBspTree and=20
I just know how impressed you are going to be at how small this =
recursive=20
function is. <BR><BR><FONT size=3D2><CODE>void WalkBspTree(NODE =
*Node,D3DVECTOR=20
*pos)<BR>{<BR>if (Node-&gt;IsLeaf=3D=3Dtrue) return;<BR>int=20
result=3DClassifyPoint(pos,Node-&gt;Splitter);<BR>if =
(result=3D=3DCP_FRONT)<BR>{<BR>if=20
(Node-&gt;Back!=3DNULL)=20
WalkBspTree(Node-&gt;Back,pos);<BR>lpDevice-&gt;DrawIndexedPrimitive(D3DP=
T_TRIANGLELIST,D3DFVF_LVERTEX,&amp;Node-&gt;Splitter-&gt;VertexList[0],No=
de-&gt;Splitter-&gt;NumberOfVertices,&amp;Node-&gt;Splitter-&gt;Indices[0=
],Node-&gt;Splitter-&gt;NumberOfIndices,NULL);<BR>if=20
(Node-&gt;Front!=3DNULL) WalkBspTree(Node-&gt;Front,pos);<BR>return =
;<BR>} // this=20
happens if we are at back or on plane<BR>if (Node-&gt;Front!=3DNULL)=20
WalkBspTree(Node-&gt;Front,pos);<BR>if (Node-&gt;Back!=3DNULL)=20
WalkBspTree(Node-&gt;Back,pos);<BR>return;<BR>}<BR><BR></CODE></FONT><BR>=
<BR>Thats=20
it!!. I hope by now this makes sense to you and you can see what is =
happening.We=20
pass in to the function the Root Node to the tree and Camera Position.If =
the=20
current Node is a leaf it has no polygons so returns.If we are in front =
of the=20
current node we draw all the walls behind the node , then draw the node =
itself=20
and then draw the nodes in front of the current node.This is what makes =
it a=20
Back to Front renderer.Notice that if we are not infront of the node =
then we are=20
behind it (or maybe on it) and we reverse the drawing =
order.<BR><BR>Believe it=20
or not to make this a Front to Back renderer (instead of a Back to =
Front) all=20
you have to do is change two lines.<BR><BR>if (result=3D=3DCP_FRONT) =
should be=20
changed to<BR>if (result=3D=3DCP_BACK).<BR><BR>and the line that =
actually draws the=20
polygon (DrawIndexedPrimitve) should be moved from its current location =
down the=20
listing so it is sandwiched between the 'if (Node-&gt;Front!=3DNULL)' =
and=20
'if(Node-&gt;Back!=3DNULL)' so it is situated two lines up from the last =
return=20
command.<BR><BR>Please remember though that if you do decide to change =
the code=20
to make it a Front to Back renderer you will need a Z-Buffer (or some =
other form=20
of VSD method) to correctly render the world.Otherwise walls that are =
further=20
away would be draw over walls that are nearer to the camera.<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>Line of Sight and Collision=20
Detection</U></FONT></CENTER><BR><BR>Well I did mention that I was going =
to show=20
you how to do some cheap collision detection with a Solid Bsp Tree and =
although=20
I was going to leave this subject until the Second Tutorial in the =
series I have=20
since changed my mind and have decided to discuss it now.<BR><BR>Because =
the=20
space in our game world has now been divided up into ares that are =
either Solid=20
or Empty it becomes very simple to determine if a given position in the =
world=20
can be stood in or is in fact a solid wall.We are going to develop a =
function=20
called 'LineOfSight' that will take a Start point and a End point and =
return=20
true if there is NO obstruction in between them.This can be used for =
example to=20
determine weather a monster in your game world can SEE the player and =
start to=20
chase him and even better is that it can also be used for collision=20
detection.<BR><BR>In order to use the function for collision detection =
you just=20
pass in the Current Camera (or monster) position and the position you =
are about=20
to move into and the function will return 'TRUE' is the path is clear. =
Now I bet=20
you are thinking that this is going to be some massive function but in =
fact its=20
very very small thanks to its (you guessed it) Recursive =
Nature.<BR><BR>The=20
problem with Recursion is that it is difficult to Draw Pictures of whats =
going=20
on but I am going to have to explain this function to you somehow so I =
will try=20
Diagram approach again.The picture of the world below contains 4 walls =
facing=20
outward that bound a solid area.The wall as labelled in the order they =
are=20
linked in the tree with the orange line A being the Root Node.Remember =
if a Node=20
has no Remaining walls either behind it or infront of it then it points =
to leafs=20
that are either Solid or Empty respectively.You can see that the RED =
area below=20
is behind all walls so is Solid space.The two point (S &amp; E) below =
describe=20
two points in 3D space (start and end).The current camera position could =
be=20
described as S for example and the position the camera is about to move =
in to=20
could be described as E.This is how it works.<BR><BR>
<CENTER><IMG height=3D127=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp40.gif"=20
width=3D329></CENTER><BR><BR>First we call our function with the Root =
node and=20
pass in the start and End points we wish to check.If both points are in =
front of=20
the Node then the function calls itself passing in the two points(S =
&amp; E) and=20
the Nodes front pointer.We also send them down the Front node if both =
points lay=20
on the plane of the Node.If both points are behind the plane then we do =
the same=20
but send both points down the Back Node instead.This is all standared =
the sort=20
of standard traversal we have been doing throughout this tutorial.The =
function=20
calls itself recursively and if both points pop out in a leaf and the =
leaf is=20
empty then the function returns True indicating that there is Line of =
sight.If=20
both points pop out in a solid leaf then the function returns =
false.<BR>The real=20
majic happens however if the the start and end points are on opposing =
sides of=20
the Node being tested.Lets step through the above diagram in our=20
heads.<BR><BR>First we check Node A and both points are behind it so the =

function calls itself passing in Node A's 'Back' pointer (which points =
to Node=20
B) as the Node parameter.This time we check against Node B and again =
both points=20
are behind Node B.So the function calls itself again this time passing =
in Node=20
B's 'Back' pointer (which points to Node C) as the Node Parameter.This =
time=20
though the two points are on opposing sides of Node C so we computer the =

intersection between Start &amp; End with Node C (the X in the first =
picture)=20
using our GetIntersect function.Heres the picture again so you can look =
at it=20
while you are reading. <BR><NR>
<CENTER><IMG height=3D127=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/bsp40.gif"=20
width=3D329></CENTER><BR><BR>The function now calls itself twice , once =
for the=20
Back split (S to X) and Once for the Front split (X to E).If both these=20
functions return true then this function returns true (and there is line =
of=20
sight.).In other words in the above example the function would call =
itself=20
passing in (Start &amp; X) as the start and end points and would send =
the=20
current Nodes Back pointer as the Node to be tested which would be C.At =
the Same=20
time we would send End &amp; X down the Front Pointer but would pop out =
at and=20
empty leaf because there are no Front Nodes infront of C so this =
instance of the=20
function would return true because there are no obstructions bewteen x =
and=20
E.<BR>Remember though that we sent S &amp; X down Node C's back pointer =
which=20
means these two point get tested against Node D. There was an =
intersection=20
against S and X so a new intersection is generated on Node D.Now the =
function=20
checks both (S &amp; bottomX) and (X &amp; topmostX).S &amp; bottomMost =
X are=20
sent down Node D's front pointer.There are no walls in front of Node D =
so we pop=20
out in an empty leaf so true is returned meaning there are no =
obstructions=20
between S and bottomX.We the send both bottomX and topmostX down Node =
D's Back=20
pointer.There are No walls here so both these points are in a Solid leaf =
meaning=20
Line of Sight is obstructed.Because this instance of the function =
returns false=20
all the other one do to because both segments of the ray have to return =
true for=20
the function to return true.<BR><BR>If that has confused you a little =
bit=20
perhaps looking at the code may help.It is very small and I like it a =
lot=20
because every time both points are in one side of a Node every single =
Node on=20
the other side of that node is eliminated from the testing process also. =
Dont=20
you just love Hierarchies.<BR><BR><FONT size=3D2><CODE>bool LineOfSight =
(D3DVECTOR=20
*Start,D3DVECTOR *End, NODE *Node)<BR>{<BR>float temp;<BR>D3DVECTOR=20
intersection;<BR>if (Node-&gt;IsLeaf=3D=3Dtrue)<BR>{<BR>return=20
!Node-&gt;IsSolid;<BR>}<BR><BR>int=20
PointA=3DClassifyPoint(Start,Node-&gt;Splitter);<BR>int=20
PointB=3DClassifyPoint(End,Node-&gt;Splitter);<BR><BR>if =
(PointA=3D=3DCP_ONPLANE=20
&amp;&amp; PointB=3D=3DCP_ONPLANE)<BR>{<BR>return=20
LineOfSight(Start,End,Node-&gt;Front);<BR>}<BR><BR>if =
(PointA=3D=3DCP_FRONT=20
&amp;&amp; PointB=3D=3DCP_BACK)<BR>{<BR>Get_Intersect =
(Start,End,(D3DVECTOR *)=20
&amp;Node-&gt;Splitter-&gt;VertexList[0],&amp;Node-&gt;Splitter-&gt;Norma=
l,&amp;intersection,&amp;temp);<BR>return=20
LineOfSight(Start,&amp;intersection,Node-&gt;Front) &amp;&amp;=20
LineOfSight(End,&amp;intersection,Node-&gt;Back) ;<BR>}<BR><BR>if=20
(PointA=3D=3DCP_BACK &amp;&amp; =
PointB=3D=3DCP_FRONT)<BR>{<BR>Get_Intersect=20
(Start,End,(D3DVECTOR *)=20
&amp;Node-&gt;Splitter-&gt;VertexList[0],&amp;Node-&gt;Splitter-&gt;Norma=
l,&amp;intersection,&amp;temp);<BR>return=20
LineOfSight(End,&amp;intersection,Node-&gt;Front) &amp;&amp;=20
LineOfSight(Start,&amp;intersection,Node-&gt;Back) ;<BR>}<BR><BR><BR>// =
if we=20
get here one of the points is on the plane<BR>if (PointA=3D=3DCP_FRONT =
||=20
PointB=3D=3DCP_FRONT)<BR>{<BR>return=20
LineOfSight(Start,End,Node-&gt;Front);<BR>}<BR>else<BR>{<BR>return=20
LineOfSight(Start,End,Node-&gt;Back);<BR>}<BR>return=20
true;<BR>}<BR><BR></CODE></FONT>With a little help from the GetIntersect =

function the above code sorts out the whole collision detection thing in =
just a=20
couple of lines of code by just recursively calling itself until every =
section=20
of the reay ends up in a leaf (either solid or empty).It's quick =
too.<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>End of Part =
I</U></FONT></CENTER><BR>Well=20
this brings us to the End of the first in a series (hopefully) of =
tutorials=20
using BSP Trees.We have learned how to Compile Solid Node Based BSP Tree =
and=20
Render it either in Back to Front or Front to Back order.As a the final =
iceing=20
on the cake we have written a Line of Sight routine that will allow us =
to walk=20
our camera around the scene and accurately collide with the walls,floors =
and=20
ceilings of our world. This Tutorial has taken me So Long to write I =
hope it has=20
been some use to you.It has taken me about four weeks to finish this =
tutorial=20
because up until then I had never implemented a BSP Tree =
myself.<BR><BR><U>
<CENTER><FONT color=3Dgreen size=3D5>Part II Coming =
shortly</FONT></CENTER></U><BR>I=20
have already started work on the second part of this tutorial.We will =
look at=20
making a LEAFY tree to improve tree traversal and storage and we will =
also take=20
a look at how to use Axis Aligned Bounding Boxes to peform very quick =
Fustrum=20
Rejection of entire sections of the tree speeding up rendering by a very =
large=20
amount.We will also take a look at saving a BSP Tree to a disk file. =
<BR><BR>If=20
you have any questions please either post them on the <A=20
href=3D"http://pluto.beseen.com/boardroom/h/48539/">message board</A> or =
email me=20
at <A href=3D"mailto:gary@mr-gamemaker.com">gary@mr-gamemaker.com</A>. =
<BR>
<HR>
<BR><BR><FONT color=3Dgreen size=3D5>
<CENTER><U>BSP Compiler Demo and Source =
Code</U></CENTER></FONT><BR><BR>The=20
following Link will allow you to download the BspCompiler demo and the =
source=20
code of the Demo containing all the functions we have written throughout =
this=20
tutorial.The demo allows you walk around a Game Level of castle walls =
using the=20
keyboard. <BR><BR>
<CENTER><A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/vsd/bsp/solidnodebsp.zip"=
>Download=20
BspDemo and Source Code</A></CENTER><BR>
<HR>
<BR>
<CENTER><A target=3D_top=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/index.html">Home =
Page</A></CENTER>
<CENTER><BR>Thanks For Visiting Mr-GameMaker.com<BR><A target=3D_top=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/index.html"><IMG =
height=3D60=20
src=3D"file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMake=
r_files/bsppart1_files/gamemaker.gif"=20
width=3D468></A></CENTER></BODY></HTML>

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bookshelf.gif

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
gGsEQQAAOw==

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bspwall.gif

R0lGODlhQAHwALMAAAAAAAAIAA0NCkIAQiYpIjo6MkJBO0JKQklJQEpaSlJOSlhXSlxaVmBmW21r
YpWWkiwAAAAAQAHwAAAE/tA1xlpLONmsmPsXIh7IURzYdTCYgiQd5iCU17yHmWIsMn2OHMyRYCU+
lVLicPsQUh+AdEqtWq/YrHbL7Xq/4LB4TJ4GHA/gR+agTDgauPomUiQQhVNxaXTBjEEUGm1LOnF7
PhUfSgpEGUg3KExHDgV2Ew0EZZucnZ6foKFfBA1oIBIHjW0VRjB2ckAPdK8GeTQlPQwiNDIoLKUU
OXqtd3uLF40ZlBsnPkcWl4Oi09TV1tdkAiilSHs5axqtCnYvMJQfaTd2LLUFuga5d+VHvoMeKM2t
InseCET+di5JmNAsxQYDNzxowsawocOHZUhh8CeBAYpC4PZMJNfinKkP/uvu5MlhYKKReUEyAHNU
MAOJGBQa6Uq5zkI/PUVsGphhA6LPn0AfElCVgwYhSSQyKnuh6w4KNXM0miDJb+Kjiz7aEGnQUgOK
DrxkFsmxQpGHBDgVNWDyQkLQt3DjclIjJFwhSUoTyN3Lt6/ftwW4fbjIhAVZE6WU6X3AuLHjx5Aj
S55MubLly5P/at48TcAzwXEuOiW5QRkAzKhTq17N+gHn17CzAdFgYWuCkj1IFlZ8urXv38Avxx5O
PAsBJkRsH8FwwEDAEgYQvjEdvLr16sWza1c8MMXFWjCUxCG22PEWAjuvq7euvT1sUi9eddfwioAe
Xl4VH+jdGIyA9QCy/ubegH4J8AYJQgy0zUX2TWLEWmQxxx9jU1g2BQEBZigcgRzCJUBFd33D3IgM
FODPBScdJsmErklxmQJSKCCZAwsJYEBmLqahiQAyOpYJANpQVokAQBaQWodI/lQSiHrUVUIBS9BW
SgNgIXhYCSxWuCGLC2UB2YVYtHjFYw5ssWWSaFpzxgUWqMDcRXlYMkibKbWgIpaPaWlhjhTy+VgB
UjBgXqCPNTAFGo6VCWRjC2EI2UJGUpbmpNSQQgQTGxBG1kge8QCPS1ful6efkvJpAKmjTqjnoCz2
yd+qqVZG6ayeDCXBpW1GKYkBwtTGDQkMfKpCqFmiKpmeYLAaGayu/vZnbLOl0iqtGB/SWUymKm5T
kU3AIiRBiAgW2+qypEpxI2rMiknuq8+qG+208HLhbU6O0IZAO2RNSUQNFvmAqWHExjoZAlP899ip
hCZ6qLJfGrtqwY8R2a6z8VZ8RbUV0HuIRXGWo0YKwXhVQ7ZLiMuFoJPth0WPDAvsMsVWYGbxzFRY
apsHWl1w2wmBsXlrToaNJQjJompodIY0zwylVvUe8cByUCKgQJs3PMNCBSGM9WYGShR99NfXJV3x
GWskVk5ivLqzzGD+aGQ2PXfx4NK4YNe9mtjwppcYfeXcw+sBQEy51nIqEcFrCKkYIUjJdjfuG960
fhh4CDpjgJAO/g2k0QYmO6h0Qy2KZ1yEEV47brrMkE9KQFQhkN5clBWkAbvOWEfJVR42cMNDK3Sf
7nuqqSP5VOBxzBOhzw+0IjptS4gwElS08/779DgG3+E/SulcV04+N61YBrrsc86UIGfQO/W+W89h
AWu0RVgQZJm19/yiQXELFFQT8oz56vePpABqYQ78UnCCcSyjNKV4QdX2AThCZGVzG5gOCDz3i2+9
STxx4FYqJKEAQ9RjOtxISAmEYDw2GWSCOztEMSgxlSHIoET+Q5KllnOPEEEoMYJzRAI1gAOyAMEo
q6hc0FBImwpasDnbY9MEisJBD2pEcbNpSpRwsISmYaJsmDsJ/hvwkCA2ACqGBMIPPxxQEuhcZDYX
IB59wIWcRQDBInYJGvmkZEQF/U0lUioKczoIJdh1hHubY8qI8CK3Nwiug3JTxhos8hQ2qAyM2gkA
4oqnAQOM4Bt0mckPeSgMIUxtNiBQgv5GmKtBfEswa4jQDnJFguXw0SopyskRPHC1YAgBcHaRYJsI
w50aREmHM4CkdgLTr22s8DhKSAwFeEKRf+AgThdBJdB+qYwclMaUA4HeOESjxMotwxCJRGTGkmOT
oUEJlxNIhAzaRDpzlO8DS4MCA4RJHImMpZVRwgABcGGTJSSwNqncVDRvNZsdGBNb10QlVCz4PebR
CwR9lCWJ/mTgA3Ya4QSTSKdGtuIGRr7CLuDYVw3oGRsDDW5wXRNCYLgnCX0FjgRN6hzOQFKSaxbv
BAkF6EJpNx1/8jRwEbWBMhhghxnk7xc8W4tGHxGONo1wIoZ0RBAmQAGSvmZOC3IJTpS5wgYSr18r
VaExPKAAeIBIV1zMqU6zSTuG1uOhEggqEYnqA2eY0is6KIwYOVqbERaFqsAIBu2sqhkAJudBOWAk
Tgfy0T2EcHN8oEg13yoBmFgEjp3MlEMF4yseDMRN4ONGGqKJM2+KQKnMEVyE9CqIsyixDR0UQjnL
WY95ErYvq4uDBddyzlRkExfl24BrX+sIKm60arpiJEwx/mW7n2azIrlj6AkRpTOCmjY/I0KHbBM3
uiLczCbDYt444Xi12+4lt/X6WYkw+sZ7CrWaz0BCReCXCtqt8zBowSBOQRu9z06OrRrJIHXnhEKw
jCi7aBjcpfr2QhRJaVhJcGwpWmko83qobH6oDZROsMyyMdKmlkQON05UAWFM7Q8UFWhg6rXffIJP
qDP9L4oimALG+Aw0fyhHNIcnu2eUYB6ja4W1RMngUriACRZ+y0xRsAt2qE0rlGAFsFTwJO+q4UQj
4hX4qujXlQJjwswVzTreq9DOqgUZpSXwBMFihx17JIBOCa2QrWVMudEysUn+iWc0l1+rIFFzFiBx
CHiB/ocOtgUqCGmnk5yyliUtR3C8DQ0cDAKFOZBPEWvowAQh/a0VSG1wTLCmjDNgyTuwAnwAVszV
NofkPD+EfZ9RgIkw0AwmpEO3MuiqCdygUPJaJZ+SmLXuIOEGcIp5y5W+la+uOMGZLluBkZ1aSXCJ
KRDoziu8qqjytjKfLZe21a5myJScEdvmWVMDT1slReEB3FNY+1JSOTAJomODUwxuZBE9diKxmb/8
bVrGyJ2itL9hwv1Njo/sW5x37wBZSbSWaZ+Zj76w5h4BWPziAgiAxqug8QBgHOMECLnIRx7yOHVC
cgwtdfwiWC8TAg50WCNozvYmFaQ0p3UfG5H2IqqM/o8qL4QPohPxOBvBHjK5ktb05recvU21XS3X
NGAB/OAh9c1Z94gZBIR2SjI6X70bKqj+iBo0928LBk7ZkCYwOwGniBfgboMg+KQKqUSDPIB9c9Ft
8AVXsLc3Vq1fiON6Q/ddwZ4Kveyf9fPrFPi3yhV1Xx+zQ9Su1sgV3FfLj/bIHA/KAjtoB0LFEA0w
T1GUQy9U2WbvRilLe0rOu2Qrg8vDJ0W8cG9SlQ2KGHN8W36pbVwRsG5gCgmGJfjBK29OQmYD4lHo
1ztCyEEwEDHri4uW0JN1g5+JkG3mcEp/7m8JASjOtLP1lCn9IjGiyR2mu6kzdkrJs8rOD5tcVydL
/ixtMJ/JoFNOfMBlvhjTdaELmvZcKnE1wvcCI1R8ihENhYQED2I7/wU9o4FE1tRSUoFlE4QEPYQD
14dIP/RjTdAIqJRG+QQiKFAc4TURCTJHubYcJXAgX7EEH1U/K4QS8acCaTQdkqBPBsEO3zQ4GJEc
kLVwnsMmORANP7BpQ9UR/TIaCthzKmREgqBZpqRQxEMWf7MCO3iBEbQBjZA8E2FJmnZJbMAc7GYb
tZEGOFOEuvBIsPEpGHQXpYRHobEbtySDLvFr5WCDGViCOogW+GCEMEU+wdYC8uUA61BUOlY5vKU7
XrcDRDUiUtOETvGEcCBEpjSF8MY9VniFFKiF/p50UVlBY19YLyYgAkYlW8sxA38DWT3QBr73d62g
KLDhDRsEiktRF1SSAQXgHLmRV77nC0D2R22ihhmRK3ZQC7j0D1MEAipCG/JlERPgAqZIDtvgbJVD
BPznBz0AFgh4ApYYfZOgDNygifkkZKcXd5+oWO7UZ90QEGrkV6l4ULM0QjXQZoERW39jC5dlAbEh
eCORB0vAK/sITYVQBCUXHk+SNphyS6tlbq/oYoVgS6LmYK9Ags1TE1YWfMhwBH51L22EaYqBZnsY
YIUATTTIAdujSKswCCs0Z+koiInVSb5XasAQHl4FDM9EJZEwHrMUCQpXFzCFUSuwWxLDGSlB/pRT
QX4jIQlMUQAN4gJPohsWcIqhEjeIoY/CACXB0krfgh9GyBN8Fw4dcBaJMIubAkjd4D1ohhVP12VE
OXjl9j2L5JLDqFunJ5NIgVG0YZMOxAcg0Q23YQ4jIGRncQcocko/0wGloDln9Bo7gSBzgDXnRzWW
CRIO1RTR5E17UFaLEzRR0pRF6WOsRnNTVHU8cEY/YBX+cISQMBsMSIe24w2i+YwNNZfiQwmFs0Lk
GHGscxHJuJTj0ADO4ZKhRwmfZEGYBVzFIFRSs5EAVWnpoHWcAWaPBUF1dJ0RWEjQGJPD82+JwZgf
MWFbEXWFUALQpT8ftTdHxgfjA0q/1puH/vB8JlBqh7aSGoGbVJQR7fM9FqGYQ0daDJkKbSYQclN+
UxNC9HCHv7Zmo9MdyKAt3Tclm7Ek36A4mFCVbHBpdOIzKNZNMLmWABVzo8dnUueTSLShbTMiA+hX
FxFj4xSFXBMapmglEjoYNFg7ToID5lmGKfmfN7ZpAzWVBJpPQgRHPKRT4XlOebihKHZ2QzVHyaEX
mnEWgMOZ3LObPJVG/cKKLkGG58kCozVnJoRIQOdY9ICIiZWExOkmQeUUefAGrDcJynEEjWUYNQoy
mIaj20OZ+cRAPdpAEzlUuIR8G7BbjvCQFrg7lpdhYMcVQil63dBGZ9d+zIgibsgX7nBS/kgaWoy4
LzxwqF16L+LAmyUwNQiQBub5QKYJZztQCU9HCM5oEls4kf5Qb7dCp5xzfTpWRf4ELCCwp7ylSn7K
NTy6OMgxkaXxn+bQTzloLXk4be7JB9L4nN1pbU8FHYCgO14Vf3GWNadGi3yRKYnqUP45h+9XeQqq
RD1wq+kQrNCDqIg5VOyTQG1wIkBoeaFpD6rANFVZQePRhrXmYoQgGJQZDErpe+TBHIG6HGvqCMx6
kaTjX03zAtIKikXJFm12qFd2B0e2E22RO86gQ/TZQ/ZyBH5xCYWaChLVjgahdH+pAh31R1wjc3kJ
DsmEYiw7J39HA8IFbCUhgpg5S5Dg/rOH6Tq1xpO3YkRc6jokY5KggqwOy3czgGsXqT1fVzn+AogY
65Hq4H1FSU57YCI70YJcqkC/cIpcpAdKdRF9sS/OQJ8OmZv6caUiwCubmGV69IJ2sZEkeyXmhknW
Fommpj8DNAj9GoCHmRCcE31+hT++8gvMoz8q+LQSyRxS23uDoECMRWlrgXiUE2oOaU0I2GYcU3u0
dS9S9aRXhDWINEXb0Ah6wBdrVLXw04sC+Ymu+Q9PFydc6bGHUQtS00m9Gg5oyxwmMhXg+HgZERDP
IASXxW0RpEc+Vlcr2kGGdi2WtlsbRR4uuj346XvUpLgE5jleIaUBqj1cWz9BowMP/thPvhoHYAEV
NlB1WMOIr8MX2lhiHimRYran/elOQIQJvmRnBRhjtbGGUWdX1wpfk/BKz9V+RfBjDBcJkCoPrztL
yrd0ePSApvq9oEK9sZhripuDJGuEpWR1WzGOtKZKSVeIhmGpLbAP+jCCEnBoU/h3NAIjchEHN9Jc
N9Zvp2d66Qg9CLwSp4cz9uutCXQSBXobYRudikHBbNc8OEEOK6Fbe+Oz0EYHpSoPtslGslUamtt1
8QUyKCxBMddUKvG4hVAa7ouHVfQ0F8CVtod2a5EVU9iGcUWlcUE7T4OKN4xsNbFQ2BREVBNdVRM4
ZxGTixBlJ/pLbZMiwwdxiPtr/npkecq7mUp8M33LQ6HKYAIMwm+iImwrwSU8Pk2FCvDLa+yEQPdk
ssoAJSHgB4BDxxxzw+RAol7BFOLArBcgF8mwE4YjWbdkjen3Mf/Sht/ze5O4O5D3WUpMnMiBWKQV
iQgYqmtAsgaUh3dro76wSLSEWu7XC1skN+JzSaqkK4fRi+dWh76cRtb2e/+yO+8nkg6mmS96BLSc
xziwzSzAlXvIy3kcqgLkBkEgF/C0mu5QrgfpTbOIiLOWMdrSeatWNQ5GOMEanUEgyiQSCfmyzY7A
f8VTS5WYbfN6RQF2WQ9mDikxYlyDGNqDX4PkzvVZFyemShz7Wb5ieaFDaYUH/qoapM2Yksc+xG0z
OsExlnUq9BSJIK5A0ZCYQALOwGA4YQ6fecOCoJw6wxGoAGRlmTGJuc366k0vigcrBQTJum8SvATJ
q0ec4zMIOIk+3biAI6FgHCfWJo6iEWxcR9OvoNPdc5lr0QfdZQ9Bt2noxwdf9tVJV12JCix9I7N8
VzsDuUhQ/ROB6LBGxUg5gZ/ouBYcUcBo+l4doS0/gGkn6oDw9ca62QYrdpEqoYWPO4pn8XSHKYNI
qnC/+i9onW3N1G15WJ9v0os0+zriZZm14WKv8CBH8QhlY34QSCdWIsESkG46UAf0UaulpApLExcC
lKa6QGV9rWOa4pEm8rjA/kIYkxgJZuRJWKFAiMRNnaaLIdQ2zEWCgS3aL4FKtJRIeaqFf2h08/Cc
gmxp/eTXxa0HM3jKnJg/Rnq1Cexiw2Z+7WeZR/Y+yyELRWAJReoKu7BlCNg+FfYWn5tBENJ7fBm8
lvTbUzlCGPXW51kEhtZJtQa4RTFrEsWVEDdeu0ElHMOBqilNiODSPDDQk8CjH+mc4rlTIbRzf20C
V428fX2/ELSJjCiqwEY+g6tE+Wcl4Z1rR1FtjOxsUlfU7APeyXCiZ6OJzSYYLqBpe0oJD0QM0xdY
p7RWq6AG2wqxCjdVQ/MkOGBCp+B/VV0MsjqjmtKLo+hdek6xa7VLi75V/nFw1ZvJNKiwAyJ4qKAl
vkInz5vnwhsAEHvDPo58dghhGnCRfYTAx/52dm/UYfEazTztddYFaWWGwMbpy5EF6GTxJLnThRJ0
LVKpwTOQzXcoW/MF62WeQ5UKA5nCKfpn6e6UhJkuv9vyvLy0rAdkb3dxqgomA8lZuFLV1ZeQg8ZA
MHBxAx4qgzY1HhCrteIVYaB3NdINccCQoEkoda0s3L5gGD0AJdlrDHvdgy/E623Bzr8u1gkCdhsM
XZ1IPqqgApRex19h2IWDCpIrglsNhM0lN5DujEwUajQ03gWVaTbFEQkEbX+sfAKEiCMpUaIDR8JF
79BLL2/Q47CYK31n/u7fZyejQ9Wy1kdGAQjdF6qrFrDy0HvgsTvyfH5qVERWA8DvhgxzQI8W/wec
GYuedinQpZsz6oXrVIVvNPIeOFTbPCeHDT4vCPCl0PIJdyluMGl4VJaB7QeYyxQ/9nPTTFUaH1VE
lfLF8AqTGNBNUs2npjhPpGo8FIl5xX9QhA78qYFKgKeAtVO6SamLTDWAqPWeI76EtMyZX7MduUpr
1XlkIU4NGjq5LUTwJlRuse5JoWkZldSUVjwv8ZKl6xR7+J3+PFNMcfmyKTp904ZTYbTlXBZyeu6L
U7X4ILywZ2WHd4zIYFxJh9ASmEqcRcSyEIqfen7V10e7gZqisaKK/jSf7XVPSQRkCjR/Q8WYK4R/
tmXiDb0OQUC5NIiDEN03u0/B3woBTR6EWHMOpcu8S8Im5EDlEJODUpzOkcbj5C4ygZkQaYrCSFR0
IEwmhsokQYmGLsQ4MBCoW1E5yqhwxpDysXyORK7RJFFYFZqcknYnvoGWVrHuYECtxIpgJaGomFkR
HKSCaUABUFxkbHR8hIxUxHE6yLBsOElDmQqJgrlZ2ZgJVDkoCFwJHWxCPWga8fh7stCZ2pBpynLR
sRHkq+wCQfAJUhBDuJKYQxFT4n1SaegMorq42tJShsn4igNlIutCQTslcZIh4bnpwhHBWF6botB7
5WP/2wCkoq7t/jiQFFDgQADJnDBwkQzRIDTzPOFApgLPPB8GKBqoOGjUqQJBfqDgE0gToXkUYlC6
xG6EQziCQkzc8EfCFy5MMIyjYpLbDTtiVqoacygbkiTxuoHbAgqDDRwz8JgLoiXdGxKG3NmUABEG
tXpB4Ci5sCYJQg1RuhQgmFatIlifXFAJxSacCCdMTJHYhzfqDj87clKIBigfv5hb1pRhYLGKXXan
iCFUEJJsUaFUMYU4QQ0MQkRsfsIt4gwEUSPwHDxAnTUpty/OnCKgERUoXMYqNsjRkRXLUA5TOnOW
qQsxB9OXqGBYm1yghx66tREXZuVQaXShbT7jEjbGTc5gJQzJ/kDW+rkEiqUyiWngREcQCJm0Lv59
771Xcl2lQBFWVWE34cBloIEO01CjaRnKUAPFgdcyq6qQe2qjBwoXhFoGug5swoOBB0Y4BryYYorl
pvoQUq5ESNSbhSxUsmLKiG3IQEeJ67CLxQjm2jtEuBqImzCHWMizR6oZyomisyuSUICzaQ7C7Bg3
nChAMCYKmZKTxoISTYFi4hkQwekOLPCBl2ADrMFCmhEhQkvcK4O777IQsYEN8/sji1AqePArE/dk
ZAowzJhmClnCqi2aKnIrQxxZJIiJqQd7wUIDvhpl7kcnTuiMhhl4mq61FjLYoIOO0OSjPtB60PTM
KmnzBMT//hzQEpXruixQOhi8lBMWO/i748w8GIvCEs94JOGwcHKDAahkwGi1k9wY6IiBSCyIIQlh
jppQFyP4CA8SS8DwrVW4tFuDp0B3jFGWJ5KNag9AHv20MdiSZKIuJzrxYQWhwjoNR3ZBiQmqm0pd
CbZZfvV1nRlUazUoFbLwARc6uqn1GelynQyfO0pSBagU2oPIg7rA+DbSu+qEpt5ACnOgowYiIRJO
ErJlDAx2b/IWjBUlHWQW4phTpwSgmPOjl3ZhSBKYUPPRJ4gsDkolhXMQwGiimYuKdIklcqomjTG0
sOcUlxAehA/rGLbN4ZJFmZEbi221NTxrCZXIob9WMNud/iG+Y8BJko0yTodP1d2qjxpVkNbbh8Bu
AAjZVqoLA2ElgOQmqj/pbCVP5NPYEqCSEFSuP0RuRgbJHuo7PGem2UuMXn+wABArrnEGIhZfMViT
Mwwrb4W+xS7vDI+fDQ0e4jT372FQBLvGRYv9c/6ZpHjMip5fpTiTW0Oqr/fvau0URbUyVXWhKZg7
wkhsFAjYFKMees6jnI4gMboWDmJrMOh+8qAg44526AO1AKODDPmsAhWA0/i4AjwAYocIZXgFUarC
uiZ8ggcuOMFTTIEHaRzHaNWiw/GkgKWSMa0ExcGGfwwkPS4YJU2o49hs3pGOCW3qOAaqUi34YwpU
oEFk/rCKhOowYbEvWctOPaKfIepivUKg4Q9pyBcxGEKBDRCjaj7A4pDyxZEpVAQjxTBFE7e4OCsk
pVz0AgUa7MQ6rISjQivQ4AykgAg4ZEUOlAFHWEaoQt4BIlRuw6NPWogd3pHhiDahBUN2t8h4IME9
kfnfLiqTjQ4wqi904kAkitUMJyhohLdAQn7+kzhHmCILZtPDHiGVmzCOoQ7AMUYV+wLAN9iCXsL4
GaOCAKmZmMwM94KCGNTok5MlSiguuUlv2uQ2d4TIMLzcYxnDw47uHAlO45lYIZsnDngsRZEuG1Xp
HKkzXCaIRjSKwf9CoEk4VIGOVwFPcViZxFPexgDi/tmOF1oTlH45EFvRww5N/HlOHBbuYCvKBA/q
876F2PBX/MxCM6aDFdUoqAzsyIEIXSXJuhQLbkYsCj+bmaBtXgAXzctKR1z2FxrWxnG70IYhz+Gc
LmjJLpHomO+cdgeecdAa4puCt5L5Eiw4xxA0qkIKuWWxJFWTiKrbjB1TYBoLgI0YEDGJJzTR0Dw4
rptvgxuEcKAGVoVMoyKd5g06dLEimJEuba3dmmZHwVkppRl3dV19buBVLljjQ3QSzDwAhAmcRu5p
XZCPSUuguhFCAj0xYY+diNOzr4QUsZjZSBdYSSnnrYMWfmGD7EK1vSu9IlnBwltOEWuDryojnhnl
/lrLOoPRyCFPmuVTKyzAAhzLPrAyo4HVK5ZC1yaIRyuwmhIWuFKVdR2BFh3NhyeEmwUL4FQubVWd
bqE3NzI4dhp8iKwttMEokLDtbR0dTYMeBKJ3/q9/VVVrwBL5I5tgIisZGgRGkvGxfJbmJljoBRHK
xzUo4MNQBobeFqC71t0ijRu1Ew7r3hLci7arXmRBrI2I4A76dKxGnLmHHEy3g2OoQjxQsO6I4FnT
q3jGPUZz7AhR0ddC1OEeDTkORKipoPp04kEnuIfB1GkXUGzKGJ0xy4gyZzuJwCU2AnYbi6aKEL2y
iV16cTInzILgxT4YHwweC4i5UWBdHeI2CuJx/oX78wGtFYUzGzKBdL12rJsxUwUhqRJG3ao1/cmy
Z7uk4qYs8D9YLAumdzks2FglATTEZjhawDBttlNBXCSB0MVZHC5+heQSx+E7SMDM9OSjFANL7iuX
ZVWWq8FKA0/GCNTAjG7D7GBvXicpZ/ZcjhcnlTZTRk6nASrHnDSBY3Bog1RyiNrwAcKBjZkS14KT
3HixEbYBxgjHgaKq7jIbjZTDHYXAxTt4dJoNUfRgvRqEFLSUh1s0bm9jSXAnpYaSxSwjyKqpdVzq
pRLOceoKsB7dDHlB67fY2lrhyPWDPFEJUG9XOjS5gB/5d5z0yhndhXgKLJrSiT/TpcexOJVp/l6B
EA/kDVrqU8VO6DgBjjSRHFQaCQU0KIM7mAfSiCzeScJ4cf45keJEVobtytWfdlh0LsvIz2WOlWqP
55eTmBkaHQB+S+ZUpwW1rtDBMZAMhVdFXaCWHR6xZgN2pcHY+oJ32o5lipNUAAh5wC1eyjIKC1TR
TlIYglz+koqbMKPYX84FNYf+1pBqpz1ljNt2KsHeg1w050VgJbLUGmp3KIgNObJ8MN2Zk1TkdIrl
yh5FO071C8llzKW74xw0AKt2TkBd4/CKf13LzGSpIU0FUMaki3JLFLy9sgq6RwvYUBc82wFant0R
DoRwtd5wIOXmZkyIEEVfrLj5q+OGsj9z/gOa8n2vWoj7r5SbojFBec4zOFRoOnzFbf69HQ2gd1Ab
NXKD5Zerk/CwNpTHwPV2ymxkuMMnIouBEzOMZGqckauZtNK4a7MEhRCZLSAGgBMFwOgEaqs7g+EP
aAiLUkEdzDuJNdCj60CTfGKzk1CKD+ymFLQj3WurwKgXido3YGixO6kPy2uTLXCMcGoy1eqaDfoD
l2G4spE/tvkMa9ild0iW26AgH5EDJ2E+xMCCY7CA7NqNMMio68sAPHiTlYMDZGkrz4lCN8qwHACP
kgKZHOCByWCdJNkh06o8j0or2gCJluFA8qCevdkhRGCW7uFC8uAGJ1OHNvmKvDOUdsoz/u4zgLer
oh3kHxbMhDUKQrwZQsAowr9KNhfgoMKBPPfYkP7bsAW8LpnSuXmLj9MQuJXrKC7ppuFLtvxQjREa
lHFYh6XhB70plIU4sUaZkWBgrlfwOZ4olowyqGKZQT4Uri5ksv4YBcSqI6kpFZ9ShXSAQgdIRLVD
h8s6p5IpLovblJOYv0r0i3m4jZMjjkobuASgiY/5RLILrfDjAUaZA3WIsn5BpNE4KZlQOaMQi6I4
KdZJuR9hw1joBSlIBgQaBvAQLq3YnFoQMNfRmJNhrsVALN8xQRVchgLbt+qzPLhYRluDRiq5C5Wy
CzRxkWfaiegbg4xBMzOrgVN4ihsK/qNwKwlLNK+TC5UDKo1bMcAtGDapEpzwWxM064+iGpAHEpF7
PAaVEysb+R09WLdNmweLmAI+wANUiIxY8QsBw7BMEJwI+gD/sIOH9Jgn6oP+8YTTGpbH241oFBzn
AQ1puDM9EJ6AuQXnywNjciNc2YXuUCxBUkmJkhQP4IgvksSdS7L5qwZxpISG6A2DDI2tWYf/QiQI
xMf6qiGkGKlqWrlrUwDFiMZCkS6OE4wVzJEC6RejgLNJs4HMugphsYMImiz5I7qNAIbBg8s2+bMQ
GcAQEpKEpLk7kIjNWSj1KIyikpFOMZDH3EtnI7rxGqsLCkwoqIgtyolEdCIeagiO/pkIF2BMglyW
x2wYNLlGypTB5KKy/7BCNXwneAACDtIdRHMlH9k+GQCC7ZALewnLiBwiuEKGa8gfM1m/P1OV9Rsy
Ffgf6HK8ZFk3iDSFZYQfEPgCiFtFRDGno1BOu9DDUVC/UhNKiZEj6fwB6vQE6/yLLMI4AviBECiH
C/zOkkwb8XSaO8uU61qobIAnDLg6CDIm/mkYtdMrS5mgh0jINmIDKnCZK4sCoEmbTEAkcVqFiWCb
ZLM4LajGlhO3A60jCsnCziyvwqDIkgQkX1OUWYEonPvEBkw1Vou9FvMAH9qVmPuL9JEuE80vAkDR
IEBR6iwd+3xRu7CF0YggB80D/lbKSSu8OrJAgDBZIShcCukKAjzwTCKhkhobSyaLoTKYSTk7F1xZ
xWSCt3PaiU8RDXrsMtbwElOUjhrIgSKhA4FyM2aJrTdwETYRw9VTiQ1rpgti05N7vSuZ0/85ILEJ
VgOw045AgDwtBw5SUrGBxh/Zr3oQ1M6U1RsMgyTRFnR0nhAqrhvBVagqDYoyypxsrafJp0iRHB4S
DvjYLfT4GSRcITmQhpykmCJyHtNMPQAjuSLJBiN6tnOdituknvZIyOXEqG7F0JMkATdFMDksBuJT
j0qBFjDKl6dQVqZgVmTrIg6ARkWT1tibrSMMOAwQE60jxh6L17EADKp0FbCx/qlzmJBle5h16dEy
4ZcL2JBwAZZd81XjAQEnihsbiQ5jikf8GIbGABXEI7slcI8La9SkfLGBxY0HiLhIccLNuLYbUFgD
Y9howYuHnYyKyCFRmMp94VIm6gP9ilivQYMvQoUKwD91wEjEURLaYR2yEJYavKMpAAK61ay/WJwh
oJPp8J1Os5KiKjpmNLJCoROmaBjJARhquRhJOiJkYUnOEBYQ6R5/0cPKA4WlLa5kkkHSaSapvRWk
ucGVqB40MYlN6FV984SG7dqmsrQUXQhx1Ie5KUs1DSPsUds7wKKnICD4idskPUnQWSyFsNZo012W
W7+PdFTQaAj2mJkUgAJZ/rgj4yGPFqysGqg0HcMMbuUF4ySzRj04REUKACPXC8AdXSg3HAUahPgQ
0HIiJTzJRmSDd7wLGVAosWndiHxdrsUMr53d+pxAKkIZkAkE3fWIYCgAAmpT6/lNChDJ4FQICsIY
DCs8xDBLs5iOCQAk08ACMYGI1rCWrACE/IwKbqGEtjIbYzKbTtrDjKGCexhIT0vCubCJDWEzbEUu
jcuKmKABc9wL58sFwNCyl4uKB/NHtgvgJxgjjOChYyQXj2K45IM0KwDb2hXbA77f0DHEx3iIBi4P
RqsiYemPnoECquwFDMS8HPG6loTiqaoK+PoYNZARO0og5xOeCIKDEzBY/rbJ3ycQL/mgrIaa0q6x
ylYYoFn4zsekuTN6CDIxHO4xUhXt3RUgAGKtCH8wUFUJhHJIDG8zBwkuGXTKkVyYtCkEC/ALA3X5
FJqZIegSYy0QYwMg42rYmv9MDHaBAsdI0tLz3SRxBSNVRaW9qDM0ge5IEtO6BJ5hgqSEGNehubdL
xNSa3wPKIshKn67yuZbLrwK40wRA1qoUlKob0Y/wiN0Ro4wzBYUDTlWoZYSQVA4uH2oYvDRYIhVN
2FIGVa1L1bjBuxzAhhZw1fKxJrmxTw+2qKyQ2jbJz13+DTVZDegwiBN+GDmihaLFpMDjUXypO7pV
LrqAluodF9DaG+jq/hrH8NUzmGXhYbOIzSHbCJaJvpec1eexysqFY5Yhi+eWOZMyrAa6WIWWrmRL
BiixW6N/xo6A1hYuIOhnAA+AUkMBWxbo5OHVKBlDMyOtKWhsgQdnsdZCILmqGDKzaGCfpgeqmSZ1
EqXicbVpKgKB+lk6jNwWakGonsKmLt6u1knn0QpDS1S5cVXopOoSNg0eltwwbRlruo73m7SJ+b66
Ur0rQAJBjIELamrhoFdmC4dlOca+w2NbhsfuKy6lqGcWggc1WKoCK4wW7oNbLIIoGK1o0IA9EBZ+
dDODAOE6cKDrdKHDEA7CvgSFCJUX+DCnwZp9BTk0+yGFeJo1Ur1l/nkAW1ZVvfEvFlGCaElBm4AW
xwkDyMbhi4yoh6NG4v6ZrXAPQ8sWQeIuQfJsWNg6ocjCy75CKoJMGrYUy5OGNSghhBGBltbQoHTd
D4gBLdGVKiK5EDPZu+iOJA4JPzgJ/EkSWBmcxZTtMt4v26DhvUEsz+pM3FpEi13apfkGT4oJkDm6
+xRcV9KNNvXu4/G18F6K8faC8i4c455C5EZoQaqQySQ76rsbSeGJRY7ZPAEOeWuHWQjVnqnA+mzQ
ZfagH4RUzN7v3Yid9G5JdqCBjPlvVvk67nUHzI60IS7yYhlrm2EHtY6IUHGdEReda5HtGG2Ujbzi
IVhmRPqxFJ0p/vA2wOEaDfLWg7p9B9p4ASGdzLdAm2cz9DAS8nMgcuHr0QtjFUz8Bo3hU/SAb8Zo
qqoABe/mlsKAEqjTzzL5LgzwIX77WH1xDKguK0hXuxp4zX47AAJIiXNYIpLjlREaD6d5YSoDm3bV
gPH1mT/gIHN5bGoalIIbC4i5cNuwAymxXkOvqGAyxLh7qEGouO2rEyL7T1jPMYe8y8UVN6VdWhvA
MFsYoSiowztLUfga6Y50A0AWJIp8bAWpBX1xaRcRRLogGU6wn80ZulmvdUjjnwuCr84AAueWO6/4
AP8Gjh4ARki7BQ8oBe5WDfwJNQVd9p5t9g2GdkLcNGegdtpq/qeqwvYnGb/sjUpPZgGOIwsu1wI/
WbQGnZlRcYgMwa5uermImbiS0CpvA6BqTAFniZgnEsyqcRzZkYXYmQY4olgqwpMfMgY7/sr+Kfit
Q4fec5qlVWFrSOOCr/llMxVgIEhKzHSynDyNlzaX9gOPp5TWlAqBjArj45ah2qVeBokX12+Z/olq
Rvo70J2++5Ugqy8hrelfZ6MldU1hatHIoBJIdTqGyJfe0B2Oi6Mtals42qJtpra+h9SKiLnRihKo
cL6XFOu+ITl342MZcQ9OEMxUYZkCTa474966/I6LZ5W6n4GNZ3u6e/Ya+FxpTxlaHN9Gf4Ke6dgk
D+q/g43m/i8JJ6lZWTCVj2VEP2g0cKvKWcex9iiVIf2esGiaJjET7kaHzXKDYnf3WaCP0dwewXF+
oNiHgJEf4NwAElWkaNwAV0gMrzqcQW1OCEBpupMabvc0dlTCMAhySBiDTYo1rYnTfA7N1OXoJmAr
OiJjYrGkQrpNwhCiSXSeQ+vgCDWmiYOSpkWJVJdfEKalYWiU6tSBiNlgmS1aqv3a5lcNWmtLZcro
+pheVdUEXk1M4FYMYR4ZEOEFCtpdikeYgUEBlMGBJotQZ4FBSQFJyAlWpwmnyQfnhMeXioNBhwKI
CIlJJN9Ki5FEjAla3tWODg/snojQ1a+GjkzSkpoOQqyL/hTsaIkB4NajVUZCMJRGk0VTweCxS0XI
Lkh2RxhPmBUUR40kXx/ijyIyPwaJi9ThXxlFZb4s4pJCXEIyYg5B4lCIygVnBUSRYtWqAQJOGxV4
hKLJxaiMOErtwDWixIkOXpzBIqdAGAJicyzIe5FOGYNPQ3ZljGZBSZ0uE67ls7DOBIONJgr0MhbE
lAYL0CxMOZBiV74pRdrlbAJDjrSsF1hE2dFUxgkrsaB10Uao36K1IVLgIBLNCTswhYYULTEFhAZm
IvRVAXTwTSNo7WKsBaEApMgCJJuGUhD0w5BXJ6GYJXeEGaiaCG7C1Wnm1xEJv0QIddZEcgZvHNaw
ydoq/p+xTgiklshWHFoJte0u1MlIRpPJ3/leOc1Jk4JHDfhAEvZsxdjSwYYKIeqgd0lI02Gs6RCH
+srxpdoQXzyVUUabEQ0TMXpTPhJlzWQkz0ifCSVaPie5UNpe2fRgEwav6FHDLz2ZNttnwRHFzCAN
6CaDZ0GMAB0rVA1RChSXGSMDcEIoAYWAJAAwI400MlHBGH4kwkZAU9RYYwwhQbGeaQKCFBQM5LTw
XRAKBMNCEEMxSMUDDRSQzQYtOsPiBtbZdwxVd6wByz4F+ZNjHvTgAY15lw3UBzqgKRieE+vByAyM
VpYy4Q8VsodhbXRySNmVXolixASiYGISNogFw2ZT/gyaQ9MaP9ZYlEUiUkEMB526cFkRls74RTMw
wkaeF1sN6YQLXOrQYgktPFABbCzuwqYHqPzVQgMECAHSFBIU4YUlLohIRpoP8ULQNx0egcGcRRq7
ZnxXKKEnbwD1+emr4F3zAnvA2IdiVNAZoyh1A6Hqxg5PtFpIlCyuU4Woo4JqkUFFIJtNT7/UO9gP
8HVyhEHKYSmEZ63C+OrCsU4wa3E9LFyUeSekdtUVUZWq1rCS+XmGsl4Fsywi3wikQkLREnwfd5he
u1G2Sflp3hAkfLtcaj+NoAqK5jq1sHZ9DBKLKqEU3UJxxR1TLwCkpcgWr151agIpCUL3b59aCWOS
/kcCagLd0TDH6oEmsW7iNCYsYJBg0VKBvRQnsk2sJDmylVbxgBm/AMIUqmYllkFJRlTemjQciijB
1Grl4gUw87mmIVHCR0KU+ZSgwGhFZtYz0AKiOcsTUoWyEXQSFDfQt0xf4wEeTjpnRiRuVLJiAv9u
tQQfPB/R00YlbWLziR5BzVlNHolOuuimD5zA22ZT/QmiXuCbMWnueAXK3/KMVTgbe40QBLRKIP5s
JNVi0bgmD/03R2MapuL85SeR8Mnmq32rnREHgfNunj0iq34TUsC0ARKwgD+qmTxAIgZ3JGJWpvkO
QRqjh2YNLkc2MIRAcoQRGjTlCsNDXsIiMQRs/qQDHTC4UpZ+1QM2UWMce/GKig5HpL9gwHxaUQVD
AgM7VbEibpwxyZXmdxRVPAp8f2COQIzQLwNokD8SqUntDCjFKV7KQ9e7IqbEMDjwMAEG+TnII/pA
HgdUiRhC0+Ei/qEPxgzkE1+TCvNaoBnCgMdUJwRf9Tx1ERU9xIUiEF8QZLgylsGHHp8AyUnMiIdc
hAAEnOjhD61WN3k04RYTIUjAElKEJoHiF+IIkBjdIQEqklKKHJCGVX5BNRdxoAjV45IEboGDMHSw
eku5jGTasy7m1HADKHiTGRpAksy5JRUoAgthqiE1okjrB/LgCixcAkjmTbMQkhjPKAypleFs/mgF
OWEkkjaBCdH9cCOwOAhgFAJKTYrrOleASMBmqIJ1lLKeAzRMV25oFsnFMTHcEiaGyDG0FngGh6lZ
mTbIoynmIOEIUvDDJPIGNl1M5zgjfMZLzuAgurgOP1GS4Rl7QYhs0mabWMiE+HbwzYwOBROZAFst
c5KBPZAMWYkJYFLgsZqu+AaCsLOlLxtgz6FaKmj59FYrPzU9IZiQTHJppDu2xI4YCcGn+FicZPBR
Cu1pkSEPsI6TuiGdoZBIKxmNXRToYixVAu0fvcGmV0rqmW707lOxVFLETvrSfCSwSWdaUx8Tc1Nl
WGGuO4AIBVpFGbZwq29EpeIAIivZAYzq/h5MmBhjoKicD1C1BlxFFVfgAJ7Y+VQDjMWDOxKGIl1a
FkcX3IczYFQSOCYhkQbjFix+4TBZgANlMhhJLD+ws5dyIzpUa4UzXLqoXJpnIlvgxbswFsAkwSJW
XSGVWFTVotBO4LFTnKxkZ+TJBbICPKbdksBUuZTVBUVEOxOhXezEqzRgJLarsiQFEmaRZ4hLavjb
QwbX0hTR2bc4BAaXgA7aIdg1g2ylCO5cN9E7CZMGJkNZ5TCiIcFACFOeYTJde2ADhQqUghBvUlIt
HwoN70oRvJEdVdTKw7MfZsK+YDOehaFHE8wVSiVnm5S2WDBhmAbwW/utVjawodLHaLEh/hiAWmzN
cjSTwGS016nE7CgKD7HFNrbEpfBxT/CeQlaCWWMAwvWcEKYOfkHETIRZKxGCJeB8J4osJqCLKQtj
GIzJDs9EWjp4MASoKa1IqHVDcmSR4iUUo1tXANv3hoHKjEzqVE6qnDXTmEHUMpOaTRkFjGBa4Whc
xWEONlXZpjNhLJiLEt07wkD6CBB2LKYesFgzHXNpLaesw62NeK7FlnLnAua5RlsRzK9BgoabpNEN
+8nDa3cUEKdm0K1o2tZ0Cvku39w2f7C8GRXSsK9LOkAUlituHFVtilaVOh+nnmOqJWzuVlhykQ3p
QhrKjAgA0SWlCfQVTXi1oC7zOyCR/hGQPIaNZxf/qAMPfSCPEhNMSbhBJq399bUp0L0u9AF81k5M
UNiBL9lQNyz1UQbC4EMw+i7koTR4AN8KEVansGKY64bXDxP1NSFLx6W3YCR9dKSmfMsEf37YxsAb
d9CL5BGassONTLaQDrU4QOEDLPaPyi2ioJHHNMIMNqLSTCaG5EgN2tBKt8nnmH2WJy8sotnC8AVy
cIl9KSxPQUcjOosyVCJWNp/Sj+W4cyIGlDmxnMXJ8B27cfRtqgzQDVGsxFSH5rEYuo6dY7xSBXNY
/eoML2rGBKvQEyCZlvJEFW7IcV0H8c8UsQjCtiypr0BY01b5UCCbLKSPOvatzK6j/oQoKaM+9ZEG
BLsNvM47wYKUyCJVRtxwefCNVZTxO7fuKgQKifIK22DyIllxvV/6tAivdN7z4P3XqRS7ELBn+lTH
oT60HWqWmVzDLMGCR4N+7ew6n29xd4X9AqWDXZiHsg1BmzRUuAEBB32A8cVdKiyM6GAMvo2DTvCd
QlgPy4BP9dkDUZRQlHFCMkwCscSOEOQA0wmTBhRA+TEN1olKgr1AY+CGhVBg/qyIBo1DGFSO9ngM
rEVVTfwByqgPGRAFDzwYPMjAIERB31yXp9SCUdiE63AIi1jS8T1gFIwCa7jEgqVJGtXBIpnCO5DD
7BSOT9QNYeiCucGEdxxdUVjT/sHwj9owwAqy4OehH2Z5D260xbTUYJ64UGzslx0F3MVEVcy1QflQ
240ESKTcwSmNVuMFx3Z4nzzIkhFwBhU6oB2pRRZuirQt2AVZBRgizRgaA+DUEWHwjA/lhDAg4MEE
4p1Mjp3NoaW04L+km+U4oPuw2R3EVrz4hn191ETVGGnA0S0MBSERwjMk0ckgB8JogsFkEiT+ymDU
CdM1xSXCxt0YA2uEm7QRDjpZhZKE4TWYFtWFXc4AEXFMhAdZWTGFRKFMxUmwwCjJ4rD5xi1GwSnm
HP8sjuaZYsZcBU8YI4wUBy0NBWI4yzZ5YdD0QwziAT/CSMC4mxxsG2x8YoA4/oOFBA75aA0YYFzZ
2VsznIMUREERqMiImaNtGI85wZ4ZaAbtLEVB0kmDhAA9Wp1M0g2TOBxw4KBN7VDXndMi9MJVhAEL
GZ6tEBLt+MCw3EbQREY+eQUNQA3rCBMjWlkdhNAK4AIKyELicA++OVGVUIZMIJdIhuHiVGJCCQgW
pMfX6APs1VD23QfrAANRwouw1aTCAYXk5ORnYIUKOEZEKZax3Ntf5lXACRel3VCK5IkRyAXReNuO
0IM+xAA5PVlVnkpULhQnZtI6aZQmCeFMYUBYygRT+Z8eoR1aEglnGFho/RQicVLvHQBeziZtyqLU
UMATaEliiQFhaMrn6A9B/mTDHN0eHTHQdPHSEXXIVInlHzDktDRAGTWXwFBaLbTFRepNJ92i6qWJ
AWJOUDBbJBhAbY4neSocVKoF8cxHLzUI32iBRUgcJkFDQZlEcFhDLixU0TkCF0IDc+4DH6wHH7iH
ccRddbbHZlVOpJgALjWbNOgGVYCdj5SnhE7oUGWFx4jEzpQkqdBOBSCh5iFegJWKkAzkfcrHmQzE
BbKLGBWdPAloduaMhtWRfb3PZOpElrzIg7rSQ1Eoj/YoFTEZfVbP++EfHljHpGlcgNkABwhaguhC
GOBTIIBmgFwkrmyl8W2odJqNQ8VoaNCY5tnUbh6mGNoKvfiomZ5pvThh/gA13cLcA5Oxo/7Igg2w
RmEBBxb8nhxE6X7iJmex0JNeKTLSDIp1Wq1khSb4kOUQRJXoUn1WWDghAppGqqTSCArZhNzo5sQZ
iVlVQUwkyb4xwjO9yo6A5tqsgQfQB8GshteRWCvaksP9BfNMFGkwGYNVo4ZUSxpMqq5KKsrJBz7e
x8HAxbE0gQOoCAU2nhnU5ah2SCWYwLaMz4IA6gMsD8Nk2KsmXSewAkHOWhvuIw9dS9/AwK6Oa6Qi
CT85Q5T0y1new5JchpP4FoC0nbVJhEM43Dc9SKru4LReiWoK3KtajgvMGy9w6yA5wzuwGlSqi1CR
K8Oa6Zq1imcImtx0/iufJVZQeMm7nAx/EIJLdMETYAy0EkwKPADzjE/nOJzAEogBeEcXjlb6mQPN
cdd6NCzNOqxzlJyp6OFu4tLO8N8YRSY9HAMQVAImCErBnlOV8KtPCJwQpGE7aIb+hAxbUZ68cOTA
1SzW+qjLGUvT0pHTsazqOdpmogkzuATuFG2RSM6UFELSNoOg1eej/QRiHGQNoKXYdhkrBGidxWLW
9q2EsonHbAJN2BooWcMOYhwX4MweoO2afkBpcNYFVAln8YRttBoO3QbM5ZAYriOl3YdxPYoduIDf
ji6P7t2cpU/dyNTJrY2RcBhpWsjiig/JpYhZsEACQUwyFGHRyIaC/qAByXbVmHKWK3luJmTYEu4t
6SbvhBZAQxiDkLRjeEDdbPCKGWnoYD4eUuBfiiAD5EKnGiQDEO1u3OrfhgoUKl0QNOkJCySrnGaD
8r6vhH4TopSU5ZhCAv0l/rGMGMFu1hgB0UCuL/AK7mqE0ZQOTSQCKf4gbqxiGoDgAlkTnlwB/E5w
eaZZBOeRSqEmHnmfc/Ivl9DSJFkD0EBMdHwNASRPUVRbAlOXYl3XN6aBcjRXC1AwDZPnfZiO6wRk
ivhTWgTl/sLaB4fH/IiwANPKjBXACbdaVomR09WqRJjDFuJDfVlFDVdxba7DzYxJMQFVD7+VClgG
sbqKEGspirmD/q3sFRKbE/VBUyPG3APDiy8qEjO2QQhasR3TZvbx33ZxydBQXEuE8dzEScPAyPra
ntsQgCo2myrNhBXUKmn2Txqp1eYRgQDdsSXjJRPhHDNNjVwm7h/zafrZl6+6xdaE74iVncoB325G
Zf4QjZtIROFuRSVcMi3PJnN0WgrtYq/ilxfNjYM4oBKoTRJIUgWpQAdK5yfhAjx0SkRoR102FwbU
sjTP5q1I3N2OmTs8AeAl6PkUTwdV275oXy5BBC6Axt4RA7vIJQWo4DS3Mz3OC6MdorEAAaxpM8Gs
JpsFwfYxxCU9sjE4oQ/ShpE8Rh+VL0NdgDsndE0m7ELUCTb7/oakZKvTtIjkoAxl0OtYBMc4K0MO
R45FrwkMWoFCj3RNvsFp0POuECrXRNIPXhA6swNpbgwXKQNRJBGu1OXpRChJ77Qs6trQbuQmsw1L
V1y0BQlMA6g0LgnraRwkcK3MQWTV8bRUy+JJn179RlIkKWQzC5TwfQoIo9JVxYUZiOM9Q6RsTjVa
d97KWPU9TjTx9LMfPCmt3RKRgDVyXcMYIIECDdztRXVa//WdvYoy70oa8pXzaI1zhdJSLESurAZq
6NF0CmHf8KN8OO/CAjZmP5Zgj4+RzZth85XlidaWVsT8uKadUkKjpQVSVVdmtzZRbfaTrkq2loST
QHJPSme3/pD2ThUrzGYiijLYQ16Zaw93PcH2Lz6aZzsuLiXbVN3zhhLUk+XsrxxC6PrFYjYBAhC3
dk/Rq5iC8wBjSSAnc8/EaEvxMQDUOzKQtWGJB2SCPILAdsd3Af3ycW3XqiHGm0RGpyIUqUCPVghZ
S5ixr1Vi0/aYAsg3gjMNKBBHrChNKLwCtPFnUO53K/Z3W8jLMRSEuEFXaJjTPCY4iF+K1YSZg8MM
2akLCeYAecsoMrYFm/nkW+JOcJhTooS4jYvXiOuCLpTmV/pxeKj4n4TkURXYKcE4BEdkdAjBjd/4
gMUNTBSaeynnV+yCsABweFx4lxVNOAYmkTqzPi45k38a/ol/qVj4wEzFEYhdH9Kw44yuljA1r3qZ
WJZbAJiHuS44eU3PgQKqgASUTZHE3U1iSnrOKZynBvsCRwnUuZ2LlevpT7L6wOT5eVONFnOxUkUW
qwv96k81DDsrOohXWCqMESC4Vyf1+UAeNKUTdnklSRvMhHpx0OB6gKfbOKivrN4O3wstIhw9yhvO
RAqOxiR8UdJ53e0wx6zT+vO4SUJELVoCLBwVdII1dbGyxDvBTrCcQ2ycXCQcO7JvZmjmVHYK3inB
NKWXOW9fxHN9HbZLBg7URCVz+6c3nyN47FZm55+Ne6F3HbSbGL06iVxIjwU3EryHeA4Fu1LMZJeV
MxSb/hGlC1YwjfUFuasWV8WqZIQcDjyIF/yjS857LAxi3N6yG4xvqTCKXoZhtIqq3APfYnx851Bz
tNtMnmuWFPkTrTn35IGpVoFhQV1sNTLLE7wXNodKEeR/WpmtaFCpbKprqMF4APk+Ulen/7x8M3Ul
gDFBDo20pND/0DdyVtt7lqJkhGqSnLXUIzg+ve7QcyRuM90CyTBn6IhbfT112WMAEULZg7hhdEAl
pb3LW7WKFuRbZBAg4Isd0D0n3j3eN+Leu05czJ1gjtgiDaoNdqF7sknhAuwFIf6n6xaCeZ1i1HU+
Mafk799CuCdRXidF04LmJzi1zt+TolwEo9XDGXNf/v8HiKYZO8SJsLz76sd365PJepht7NN+n9D+
ZAYlaW2ega7brIpA77N+pQZQRwotqfPXkCTH2iSsf3rfWbxAsPxqBzw/9Issj1B/g3TOQDIGEfSW
wsAeQYmtVoj/+J/GIQgtynVOjQVDgChkXV9PGEKASjMdag/Qm3f/wVAcydI80VRd2bY9CopiHIdO
pJlhDitpFIXYpNaY0BpJWYLHSDh8B8TlknFdsVntltv1qg6GJbN2Q+SYzB4lWDA+He8d4z2R8IhR
hG9itH4BAwUHCQtNFMSWaGxszmbUeiwQD4wainSWpvCeLPbW3owMRUdJS01JEMcWLRnOnNJ4Iif2
/pJq4mAzNX2gEDwtHPoKToeJi42zUhWLGhVenWJ7kvZsixpeKYymEDZ5I3/tjsPFx8kBEhJlVpmd
JyIRlCypkzb7KLanICMlgBPK/f8BDjo3Bg4rV0fafaply5ISPj+o4IMmRYECYAExZtTIYqCMKUV2
HGy3hNqlOH5k1OlkAZqCKRY3xpQ5s0NHe0+MhGzWqwJEMiX7OOSjMsGehI5wGKC5lGlAm7N+PGsl
QQq2PiX5/fAzlIqCNVLwnWs6lmy4nh63Sd3jdVvQeMuAWRBqdWQQDAj7ldW7l9RZe2mZxPLq8221
Gj3n1hsJ46ETvo8hC/I7C/AEAwcGV8JaC+Wb2KqKK/QocOAag8inUWuZXDTtHgSXi2rFetKhjM8Q
MYjeQUFYat+/Uazu5aTH604/ZsehhPJCWJTedhcFPp16COFnPLm+mpyWETShl3jDm7d6+fKrw0j5
OmXh5u44bEeZMDqaT/P3q6MfbRRxnNnSKAHmuzV6YkyKShLoDb8FU5tsj9FkaAYueQC0JJ3QqBKt
k0r+YNBDyM4qjrEZrJmQIWneseERWSKBEKIGPowRxNzU+6whdUpKIhtWVvRGlnpkDHKv0NwpDrk4
FvlPCQTK6NHHoYSMkqwIAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp4.gif

R0lGODlhAAEAAbMAAAAAAACUAP8AAP//////////////////////////////////////////////
/////ywAAAAAAAEAAQAE/nDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq9WwEurpXQxXzBg/OFqxmEwdp1mpdvezRd+Masl9El+/TR3/wNkeIKBc4Bc
gIVhaIoWi4OHiGSEepWNgYp7fEyIhZiCdp94mKKgoqOVcxWPqqadpJaxr5qbS3aHqbmxp6W7oW9x
rbmqq6ajxLVTt8e6pISuw2isu7Cf0rB+1MHNtMlIy7y/ccPkddir2+O9qLLnyN5Q4LPuzKW47+Lq
idbM7/T11eA5kccPkh5D/RIx8iLJ0UKDBR+2kWjMk0A2Ubpd3NhB4xCP/hxDmosnsqTJkyhTqlzJ
sqXLlzBjypxJs6bNmzhz6tzJs6fPn0CDCh1KtKjRo0iTKl3KtKnTp1CjSp1KtarVq1izat3KtavX
r2DDih1LtqzZs2jTql3Ltq3bt3DjdhUgV6UAunVN3r2bt+Revn05/gUcGN7gvYUNHyacmM9ixI0d
P2Ycmcrkv5WtXMacecpmzp2ffB4cWvRo0KWVnCadWvVq1K2JvD4c28hs2rWH3MadG8hu3r15/F4c
vMdw4sV1HEee3Mbyx82dP2cePcZ06NWtX6eefcX2yd1bfAcfXsV48uVNnL+cXv169O1DvGcfX/58
+EcD+L1PP2mA/4Lx/tcfUv8VKJCAmy1V4IL6SYbggPkxuCAWD36moIQMVlGhhUphiKEUG3Lon4ce
NhHiaBeSWGISJ6LYoYoqHtGiiyPCCKMQM56Woo03+pCjji/yyKNwP9JIoJBI5lAkkDUimeQMS662
o5NPvhCllEFSSaULV2LZpJZaptDla1OCGWYJY5KZpZlmjpCmml+y2eYHb8J5pJx4AqhBnbOVmSeb
GPDZ55p/4lmBoIPGWWieAyCa6J2L/unobX5GCuaklBJqqZaYZqropkJ2ululoMIo6qialqriqah+
qiqGrLYK6asexvobqbQGYOutqea6K6+uqvrrcLiCOiyxvRp7LLCz/tK6LLMR5vrfs7JGKy21njb7
KraPWusrt15qKyy4TIpbKrnlGiWAtAWiayRRf7Grq7sJwnuYvPTWG9Rk+OaLH0+b9esvdzt9JvDA
rPlkMLsIE6zTwtc2nLDClx0sMV77PmaxxPbey/DFkHW818YNIxXvxyBjrO5dJCO81Loog8xUywPP
HPPFNkeccs7f7lxspClT5u22QfPsbNE/Lxq0yuaeK3PSm+IMtbI1T011vkbLu6C/WWu9tbtde/01
uGGLPTa1ZZs9Abdpa30B2laXusGybdNK5691y22frXlb6h6rfRdq3qmBGypep4XPaSWmiW9Jw6SN
C6mkoJH3uAOfupWv+MObmWeo25id62nblZ0zEWXlUBTZuGc5Fn7FjH1vcmLdij2Y9kYVhr0ff1mn
xPuOLc1nc0zr1cfleMYvfl3yMCzPfPPLPa8dstJDX231x3eLvfLpbs+9iN7L0H341v9L/vQOn48+
bOpDCVz7NUwMv3RMz++c/fjnr//+/Pfv//8ADKAAB0jAAhrwgAhMoAIXyMAGOvCBEIygBCdIwQpa
8IIYzKAGN8jBDnrwgyAMoQhHSMISPjACAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp1.gif

R0lGODlhAAEAAbMAAAAAAP8AAP//////////////////////////////////////////////////
/////ywAAAAAAAEAAQAE/lDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9AoL0CleqqowESrLVkl3bCFKy23ulfwCY32UsjkStxMX7/FbQEbLNar51t+gl99eVZY
f35chIpfdY8fe42CaomKl4uUlnFwl4GeiYCdfZClGpKcb4F4mINyrlWjmqyrnlipprkZqK6ftq24
taDAqsOyrJK6yr54opXIrZq/0M7GxNd5y6ZtjIaOesmFY5+OyVuklZS3g9na7unv8fLj8/X29/j5
+vv8/f7/AAMKHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8eP/iBDihxJsqTJk2YAqFwJ
AGXElhVgumwok0LNmQlvStCJ0yBPnj0J/gyqcChRhEaP+rwAVOk/nTVVOg3IcmXMqk2n+sPKUitS
rlm98gMbVuw+smaFgk2rlitbgWTLvp0Xd+7YuFaPyLUbQqpNtENa7uXrwS8GwD4EE1ZheANiHYoX
o2hceO0NmYMlM81swTINzJpHCOacoevnmKH7CogMxW1qEHmj3CQdmrKTpK/f4c7Nu7fvfrF/6w4u
fJlpr7ZTxGpNfGryNWHa6W3unPYpbk2Om33uRfpyItq3W9/VjpD0HeHFnyl/vkd69Sy+nSvyHv6K
b9HBU/fxHRxA7t3x/iGgf4nt14N5A2413nX4IeKegVNgR6CC+dTHH3sO6gOgcRAeyF6CFS54QYaB
dejhiPmdJaIc/QlhIRDyDRijPRuCEAuJBdZ4YTEIqnjfje3h8KIQPfaoIVQkABmkDUPqgGN/NwIH
lXVRAtFkDlUyhFeSM0JmIpZA0lRXHVeCmWVRUz5Sppkt5oQkmV9GiONXyqwp50M6PmHnYnlmF2dt
K7r4J6Cl7KlfVQX1mYSh4HWmlpqD6uXoQIoagSiZk8IVKA+upYTao2WYFumhjMZTqaCN5bXpZZlS
teplzVn1ag1vairbfqW61+p/s87w4qg/1OqqngZeSqyxqeVaHBPK/i5xqnjP3hYtXZ2SOty08vT6
QrPOYpsts8AeW1S33pKrbS7nMhautOVmW22O6aKqJRLckkvTdO0qUS9dlq7Lbry6ACzCvvrmW49n
Xhq8qMIoEbwwwyY5TK+/QUk8scAfWYzvaxr3CzFJHdNHcU8j+/nxsvKirE3JKnuMcctCIgszpKO9
PLMMwZ18M63ESWXzzim8xzLQPDelM9EsFHs00kEPzXTCPy+79AQhAz31TlfPfLXTT1MtcNVELw12
2ABz3bXXOGdtdbpjI31y226fa/bZf22rdtwuwM00w3rvPevcdF+V9N1PG9x34asCHrjgi9/auOOP
Exu55JP7Wbnl+Zd3m7nmmy/cuee7fo7emKJzSnrpXjKF+oOr69d6ia8LGnsQhM++me3BRo0747uP
3rvpv/sefA61B1/878f3nvzuy3cw59nNb3Bm4NGTNz30ukcSZuPVY6Dk49173ybd4Yu/JNnDE589
8utn8XzL5WsP4s3xOy/h2lJ0Of5v9XMwo5Hpc5/1zhdA+4lvQgU0AX5kRMAESi9FABTO4ZSToevx
JlUO3FboMmiC9imPg74CIc5EGAMPfvBTJDwBBlOorv6x8IUwjKEMZ0jDGtrwhjjMoQ53yMMe+vCH
QAyiEIdIxCIa8YhITKISl8jEJjrxiVCMohSnKIQIAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp3.gif

R0lGODlhAAEAAbMAAAAAAAAA/wCE7wCUAL29vf8AAP+UAP//////////////////////////////
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

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp5.gif

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
BhuSgcMmWz2my0Y7bbXXZrttt9+G24MIAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp20.gif

R0lGODlhxgA/ALMAAAAAAACE7/8AAP+UAP//////////////////////////////////////////
/////ywAAAAAxgA/AAAE/pDISau9OOvNu/9gKI5kaZ5oGgIsoL5wLM9ea98ure98f+FAoG9ILK6C
SOREaGw6YcmodJl7Wq8gqRbHYWG/YMl27BWVw2gfeavipt/tdZJ2httR8haxfu+P2FZ8foM1TGGC
hImKP24fA48DYQICi5UejxKYX5OWnRmamZuTlJ6lE6CSo6arqGCkpKuerVicBLWxlrNXtbe4i6iR
u6O9voqaukS9xMWEkMFWyrDM09TV1tfYHcPb3N3e3+DfAePk5ebn6Onq6+wBzu/w8fLz9PXvGOH5
+vve7f7/AP3ZG0iwYD18/BIqFBewoUOABiNKJIhwoUWLDzNqRDexo8d7ktlCihxJsiS6kihBjKOw
MqVLDS0lxHxJk2UAmzVzTjipU+fMmT1d/rwZlObQokaJylSKFCXPplCjitEj1aWcqtPyKMFaSesa
rna8irUB1s9YrWX7nM2TNuxaLW0/NOLxlmrcLlUQFWF7Fy8FvV+29tVQB/BgT4WrHMaVeHGxxo4Z
KzYcWdEZypUTzc3MubNnXxEAADs=

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp21.gif

R0lGODlh+gAuALMAAACE7wCUABAQEP8AAP+UAP//////////////////////////////////////
/////ywAAAAA+gAuAAAE/rDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoLAwGOgC
yGSARmgShhWAdFoTWK8CKNGYQ1K8saZErC1IJ+eZtTwpFrvLCfhFHrPTEjxszd6+cXMFgS11fWYA
FHovfGxcXDdKSTKFfXqKLliMQX9/NoGDLJR3iGikMZpQnI81n3F0T4Z5podqWY1unayugruEsHZl
lrOLtlq5uTOtk7CiQXiXmMWpq8gykaAuTr9aU1Q0maix4uPk5ebn6Onq6+zt7u/w8fLzKG70Gk73
+vb6F/n9I66U4QeQwr+CIAQaqwbwIEIPCqetQujwIYeIQwg+rGhRA0YhsBopNut44eMmhv04kiwZ
rgWulzBjypxJk+G1mziVWNDGs6fPn0CDbuvQrajRo0iNTgDHtKnTpy0t1JxKtepECTmzXtsptKtX
ryGSih2rVALUs2jBdbDKtm1IrFrj9irwta5dnmHJ6hW7NK3fs/okrdzgbbAWwYYxFE4sBDHjKNAe
83AsWdawypOxPV6MOfNcyZw7H9HMOLRoQKRPq17NurXr17Bjy55Nu7bt27hzd44AADs=

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp22.gif

R0lGODlhewBfALMAABAQEP8AAP//////////////////////////////////////////////////
/////ywAAAAAewBfAAAE/lDISau9OOvNu/9gKI5kaZ5oqq5s674UAMTzJGe3kNNyD++6GuwCLAot
OaBE+Tsyh0unFFdjPls94RWa9AVt3q+YhvRmwdlw5RxVs43t46bbjdrF1nT7XsfLl4B8VYNjX30d
N1WFQX15ZWCCkWuEfpKNeh5vbjOXj5OQlaFkoZ2kf5lToKWjrKWHaGaUh2yLH3Cqsn+OlrmfkK6p
kqiscb2+xLSrd3aYccfOUNHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29xxb
+NT6+9G0/qwBDMgvEEF+lA5Ke6VwSJpTDVncivhiIsWL9SBixLJxYcd//h+5NHxIsqTJkyhTqlyp
8QTLlzBjynzYZKbNmzjVeAjAsycGnxeBguA5gagFoRGR7gxAwWhTp0QGetrlaYjSDlChSrgKqtYo
qs9ecN2qNCvTCmPH6Ft7SiqLsUbNPu1JVysxHloSNsMLC5pfDVyzPh2M1i4PX8CWxTAYixeHunQF
GCZLeG6+HYlF4VpGs++GwGcvODWcFrExZY4V/2pJNnTlo3V/TlZ7unYZTV03fybtekRazLZNPUuU
NzVg3k1FlN6bTO9AOEai95M8OW5vrLP9pY2sPPu+0ibA4xNPIqf58y9rol/P3m2K9vDb32Md0gT9
+uXxV9Tv4j7//wDSNUNSgOUFQ6AtBh6ISIIKztFZg8PkBqEGFk1IxV0WRoVhhpPsxeGHIIYo4ogk
lmjiiSgeFAEAADs=

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp10.gif

R0lGODlhAAEAAbMAAAAAABAQEP8AAP//////////////////////////////////////////////
/////ywAAAAAAAEAAQAE/nDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuLwIqNvv+Lx+z+/7/4CBgoOEgWkA
c1KIaIuJT41mkFcBlAGRh1qUEppkkp1ZnJtlnmOkUqFnpmGqUKiXjKCWmLBYrqOzk7Kin7S1srZf
rMFblbqluI5Nwl7LyUPNXNDOQNJa1dM911ja2DrcVt/dN+FU5OI05ornSelR7esv74/wR/JO9vQq
+Ez7+Sf9SgD6IyEQScGBIQ4aWVSsEsIcCulsMgbsoYmGxiISYUjRmEUU/qFCaXw2kULFjyNQcRop
hGNDlCtUymIZhKNJjzBJyJRAk1rJCSdzftg5oOcPm0BxCg1B1KgPpD+X6uzIcxZGpVKH6hKJLKsK
jBScZvM6rivZGGJ5pEW51tvZGm0hvkVndm6LuDjwItRrg68/v3Ttoq0rWB/hwigAz1AMj/FgxC4c
w5AsjnJkyJd7YTaseXPiw55FWL47eTQ40Cbq2DW9ot+duaw537UDGzXBqm9jp9inuqhuKL//RV7U
m2zw1MNfnz1eAl9x38ttJ4T0XGpcAdiza9/Ovbt37oXCiw//vbz58+jTq1/Pvn12tqWYJ5OvoXro
zEWugqDfbdlLGkFl/mDffY9hEBJWLARowYAEymCKKwjGFOGCDe5AioIugCUgf3tZgGELCjJYYVk3
TfThRRNyCBMkRMlwkogjuhXVACeWAAyMMVqY1I4z2KKicUlpMmE8P0YHgn7/FFmbVq0pKZg0NdaX
ozodRHkBjlMaVOV/+zkZmn9DCpjlNhtYCd2YZGYQJZZZacfLBTV6uQR3b1aA5JVyKuFdndPdt2cn
4jX4J5px0EnoHG4equiijDbq6KOQRirppJRWaumlmGaq6aacdurpp6CGKuqopJZq6qmopqrqqqyy
MN6re7SaUEuyfqBXnkJV0+JuuMLHJI+u1irlrzO2JiwGulIVz7EU/mql4bLMTpBsiWj1ms+0wBYo
LLbFTsYstzSGudux4Jp5W62xsRmqXra4Yu007OLkI6vxdqTUu47UexNW+M5R7y8OIdsvHP+amOKp
8YYr5JADt5FwMeF20PAaCUdsMQcTS2cDJxyLeyaoTmZ8CzMggwHrySj34bCkIhfF8sqRttxyOTBD
KvNA5o7LBlTi5PzZzt1O47NwQF/cs8f4qcFzN0MjV3TTZkB9LsVBOyP1CDcbzTTSpD3NdRtXiwZz
2GKQXaYuWd85IldFL8o21Yy+rXSjcmvcYN2dEYp3Kod2LG3NY/qNG9x6Bzz43FYceEzbVAguRtZV
LDwy4Y0bvjjlflNYfjnikWu+CuCZW2J2PaCfAjCfeUeh+OOlq66sya0vCvmjszsqc8q456777q9G
6/vvwAcv/PDEF2/88cgnr/zyzDfv/PPQRy/99NRXb/312Gev/fbcd+/99+CHL/745Jdv/vnop6/+
+uy37/778Mcv//z012///fjn33wEAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp11.gif

R0lGODlhAAEAAbMAAAAAAABj3hAQEP8AAP//////////////////////////////////////////
/////ywAAAAAAAEAAQAE/jDISau9uJLNu/9gKI5kaZ5oqq5s62VwHLt0bd94rrNy70u7oHBILOJ+
SJhxyWw6g8mo5UmtWq8vqTaA7Xq/u60WTC6bTWLpec0+p6PtuPz6Ts7veGMdme/7j3s+f4OEKoGC
hYmKIIc9i4+PjTKQlIWSM5WZfZdKmp5znBmfo22hGKSoZqYXAK2ur7CxsrO0tba3uLm6u7y4YKsV
AKmowl/AFMXDn8ldPyM/zIsC0wLKBNF0iCHQlNMb3sPYVs4UBBPmPuKD4N/K6lTk5/LpkOzW17+C
5fM973721vw5iQeEnwyBeQC6y+foFLdHCsMxPIYQj71qEo0dk1DRIsaI/p466tHWIYrIO9QwZvTi
7IPJeyEn2nkJM9NJIlvQIblZcw5PIS2z7OxZ6ScUkhxoEn1kNMwYpUsVNdWRE2rUQlNzBC2ZJOvV
L15vbN0gJexXLGZrbOR4NlFaGmsDvG37ZG6LSSKs0s1jlwembV33Duq7gmDBwIL9EDakbx/ilNQS
s1mcYizZxyoJgJRsBHJmyij4cMXcYTNnIuzYgT4Rt9jFzKeZvN6wGs1TzJBjU5mNTyPSpA9565ad
GVztEpaB09NcHPZw1M1py1Sigabw50V4HycxRmfw6Ng7g9/+bIYG5d9zhxfPQfX0KehGI15fxXMH
8nnxotdL3wt+wPp5/sdff2i9J8p+DxEIxn+M2IHgQQqSwaBLagjYT4QLGsjJhBjep+ElHHYonW8U
idhFiA+GgmKHK1poSosRttiaiQWSCAyMCsq4Fo4E6rgRj/35WCKNVgh5I5FFfigJkPQZuQqT6zn5
4hCtIBmClCpSCaVNSjbS1ytWfoDlhkKAGaaHNj5Z5ohnstnMjkFUec2WkIwJYpzFyNmmnUviaeae
XR4yl55zttkbS3DqQCihVrY4wKOQRirppJRWOmkvmGaKqaWcdurpp6CGKuqopEIqIp04MGpoE6jS
oOqqTkDpmXMjtMpiCeqxt8KrsFbhT2q07mAaCLz2miQIAAWrw7Ae/tgapjjMBmGfCMUae+IH0Qqr
LAfVWuufB+CktMSwzhrLzHVDbNattxK2B152tK7LbhnJADuuc+XOy6273myrpb6DqTCrDfICPFkK
2ZpQsMFtiJQwCfkyTO0JD18ZscQT45orCgtjfAdCFaPpcVEkhFzoyJr86q+YFz8S6UrYriwyu5PC
XNq0xLbsMqU2p9CxlZW6kynGQaPMWc1Gn/Zy0kw37fTTUEct9dRUV2311VhnrfXWXHft9ddghy32
2GSXbfbZaKet9tpst+322zdoKvcscLsAo8764og3uyehW8PPcPf9bg579yr4zWvWrTDCgyuqeAmC
4xzn47UyjjgR/oCnfbi7SxTeqOWcd055s6B/I3Pco++Lgt+Yp34oHpmLjaNCAHmO4ezOKWR7jmVE
xi+xiuPeXLC7N9m77+Ja/LbwH/meMdu4M9fvysUPF7240VYfW/TMmX6C9pxxH+7pJ58N/utkn4++
7KPM7f77tUSlPjHyZz3/4ljfD7n99effP30mS1X/AtgTAhJsgOT7igH/hsDwLNBVDcTOA+0WwedM
sAX6g5j3JJjAHWSwct3jYI2I4poORuWCLPhgxlCYChZqTHUkNN3GPOaepahQGiq5IfCmVsMY8jCH
/4taD3uiw0QMsSZF/EfzYEhEqI2PiUgUovPWdw/P2Yt+NsThogax6EMjVsOFDQsiIZLXsyri0IRu
EeM6psjFJipiegvJ4huXmIokzmyMKgHjGewIxTVern1qnBof3VS1QVJRaoaEnyIXychGzs11kIyk
JCdJyUpa8pKYzKQmN8nJTnryk6AMpShHScpSmvKUqEylKlfJyla68pWwjKUsZ0nLWtrylrjMpS53
ycte+vKXwAymMIdJzGIa85jITKYyl8lMiUUAAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp12.gif

R0lGODlhAAEAAbMAAAAAAAAAewBj3hAQEKUAAP8AAP//////////////////////////////////
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
DatYx0rWspr1rGhNa/oiAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp13.gif

R0lGODlhAAEAAbMAAAAAAAAAewBj3gCUABAQEKUAAP8AAP//////////////////////////////
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

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp14.gif

R0lGODlhAAEAAbMAAAAAAAAAewBj3gCUABAQEKUAAP8AAP//////////////////////////////
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

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp15.gif

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
iXWVuQ+XeXWZKZGF2Zm8sJmNCJrsIJpQFwEAADs=

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/xf1.gif

R0lGODlhnwCbALMAAAAAAABCtQCUABAQEOcAAP+UAP//////////////////////////////////
/////ywAAAAAnwCbAAAE/tDISau9OOvNu/9gKIZDWW6nkWLr2I5c+sJ0t86UPEg6v9O4SdCC69WO
tp9KeZkZkTGmZuiDWllSn0n4O5m+O92WO851v9qzc4t+oq/QcnU5N9rP9ew9Pzdr+1yAcDVle3SH
hoZ+iHiMRI2Hi4ODiY2VfJGBjptrfUVykyI3lqSYl5mmpaibq5KhJEqnsqqdnKqLo4+Crx9gZLmR
PYq+FcNqWVXAxaC8R1Rwz83S061XT9TY2dHOzNne3+Dh4uPk5ebn6OneBOwE6u/n7BLy8PXh9PT2
+oP5Bv3+7vYJtNKvYMCBCI/gOwgwocMaCyf8e0jxQ7uDEytq5GBwo0cP/gYvfhxJsqTJkyhTqlyZ
DQAAligBCBDg8iVMjy5n6qTp8iZFmTuD8rTpcx9QoUhrFoWXE6lTnUqXmjv6tOrMqFLBUbXKdei9
diqbdh0LtSe2iCe3kl3rNVvGjWrZyjWrkOG/tz/jyt2LdUTHeXgf6t1L+CrdEGgpBEY4uLDjthYD
TlwssPHjy303iLRA2Z7Yy6CfZsbwtzPT0Ki7jlbMEKDpd5ZTyzZMlOXn2bhFH06bu/fY1XB9C/9d
W+Pt4ciFBij+M7lz5QGiM3cY+zno6NizY5++rnWH6tbZah9Pfvm4zR6Ohxdfvn157m69ZwC/Xqf7
+/jhX/nb8Hv9qvgF/iigedLwR5l61g2ooIL67SeZXfJRQJ9sC1ZoYYNQJNYfBhM6ZuGHIBJYIFis
cdghWSGmmCKGBHmX0YlPqSjjjCxm6KJ3MM404448ingOgkj1KKSQNVLT2JBIJunjOAAEYJ+SUCpZ
ZDMvRWmllOgAUEABV3bJ45RUbrmll2SGCCYvWorJZZlsMphOmmq2KWd+WaoZ55x4ancmmnaKmeef
S5IDZ59rAtrmnq8MSmihhnqJaKKL3tlol4+Gomikk1L6ZqSEZhplpZNcyqmnWG7KaaekEgnbqYum
+uWqrKLqqoygDiJqrGPOuiKsuMqqa4W12trrqL8uGCwctw6ba7EC/h6LrLLEMnufs1ckC+2y0r7H
1LXRZjsetVZYyy2j3kq37binlrtdPeKiq26gP6Iba7nghisvrt7WC0W795Krq75I8Nuvv6kCfITA
AxOcqcEHJ4zvrAzXgLDDrkYsscPDFuwZxhl7ajEME3Os8Jwfgyyyso2WPELIJxuqsggsnzyyo0bJ
fG2eL4cQs8145qyzzdzK6TMIOwM9c5JDf1C00WUmrbTR7tKsz9JQH/3q1FXLe6XT6WWtNZRcf+f1
vaViPfbXQ4Yt9tlo96j2BlSzjS2NA8Utt9t1yz3wjm/DrXfCtDL2N+BmCj743oVXdjjFH/bt9+KE
G2s45Ii7OTnlsP1anjfmjNN5OeeZB+j446BH3t7oGthdup3uoT7f6hyfTh3ssX87O+21r3s77p2b
m5DqvLPuO0cRtiRA8JHWpPzyzDPfAYnkHI9u89RXb/31u4WC3jhDYU89SQZCnxU8pbnz2vjgJCbP
+bxcxH5JaGl4XvFSoec+/fGhf8Fb70ME4Yb6k0iE+keDjrgvgPWI34MQ+A75AZCB8RCfACHYwP89
kILluIsEMcjBDnpwEBEAADs=

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp6.gif

R0lGODlhgACAALMAAAAAAP8AAP+UAP//////////////////////////////////////////////
/////ywAAAAAgACAAAAE/nDISau9OOvNu/9gKI5kaZ5oqq4mwL6wB7gtHd+4RNuiy+fA1e70CxpT
xYxteWyGmJMkBjqQOq8VqnVapWyxYF/0axFHwWgu9WPWpd/erryXhdvns9l9z+/7/4BOAQKEhYaH
iImKi4yNjo+NKQGDkJWWl5iZApKTmp6foJCcnaGlpqCjpKerrI6pqq2xspsok7aws7mlr7a6vqG8
vb/DmMHCxMiutbfMlMnPica30NSG0tPV1NfY2cnb3N3D3+DhuuPM5b7n6Omz6+ztre/w8afz9PXA
y838/fmm95r9QzTgUkCBnyoUKliJoSIJBvf1m4gwocWHmyKeoMixoiaH/plARtNooqPJYyEJFYQ4
QWVGlytVinRp6eBETwxZWqOVcWXMnARJljhJ1JlBmjl19oRJC+KhmZEkFuWY8mXMpVh/LoLKyCbV
o1bDAvWZNWhNqVO/NkQq8+pYq1C5bkWbluIvuQnp1r0pq2UsrycHRt24t6jguYQLEz0cTa9ivowX
On7sL3LbkpQNWwZcd/PkzJUPc97LeDRpwaZP/0utuh7r1u1ewy4ne3a32rar4S6cbjfvcL5/Zwsu
XNtn0LnFHUfe2Xhi5sydY4YOHRrxzM+uY0emfbvy59SpE+sO+vv08OjvLkevWN169sX/voeffNd8
+s3lg8fPT0J8e8dV/mDLAEUR2I+BBua3yjkJ1tUgMwi2xwqDij3Y32MTrhehfxNMQmCCHwaAoIUe
Uraghh6GOKCIIX7YYokQlgcQiiLC2OGGJbro3y07eocKjTjWGOSLF0anz34H2lijkDmyyOSSMFb3
I5JFRsiiijiOCGGHRuJ0X1ok8mdUMV+exKWY/HhJJZr4fVQmmz429CacJgpFAp14jqnMmnnSJyef
fcInypyBYrjneYWyeehQieI5GKKNotkVoZFK2BiglbL3EKWZ/tcUpJ2KSRCnocJGXqngnIrqMaqu
Skqrrg4Ca6yB1EqCHiOQYWsOQzyh665A/OqFsMDeQGwXxxZ76xlVNnwBRRvK4rDGFs/OEa201mZb
hhy9XovtD85ym0ey3rLBrRsaQKttuSzwgOsGRZDL7rz0hhABAAA7

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp7.gif

R0lGODlhswFMAbMAAAAAABAQEP8AAP//////////////////////////////////////////////
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
R0/60pv+9KhPvepXz/rWu/71sIdMBAAAOw==

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp30.gif

R0lGODlhAAEAAbMAAAAAAABCtQB7AACUAP8AAP+UAP//////////////////////////////////
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
R0+BCAAAOw==

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp31.gif

R0lGODlh2wDDALMAAAAAAABaAAB7AACUAACU/xAQEP8AAP//AP//////////////////////////
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
F9v//vjPv/73z//++///ABiAAugBEQAAADs=

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/bsp40.gif

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

------=_NextPart_000_0000_01C04B5C.911DD620
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///E:/Text/Sites/Misc%20Web%20Pages/mrg-bsptut/Mr%20GamerMaker_files/bsppart1_files/gamemaker.gif

R0lGODlh1AE8ALMAAAAAAAAIAAAOCQAAKQAAQgAAWgAAYwAhhA0uIACDRzhScFKcrLFtoXvS96jy
8v///ywAAAAA1AE8AAAE/tDISasdAKiFlF9gI4qggmQIEiBJcgoAIqatO95mKyh37//A4OhkKRqP
yKRyyWw6n9CodEqtWq/Y5EOKSQViKVVAsAsLVrW0GrAQ5VoyXy4lrNvrCkAhy+/7J3t/goOEhYZX
W1Bdaowujo2NATwiAjUdP3ljbXecnSQABIeihQUKBiYeToFVq1KBHiYEraOGs7RZiU0Fi5C9vi0a
Qyxwk3KbnshBbW0nA6G30NHS09TVg7lMKL/bjCfFCwBpAsmcJmMdx8o7eSdhJ89+IAymSxsMC/SG
IA8PDg/41qbYA1hvwTwqC/o9aJAvoAFbDpFgS1IgA7eLcFakawCDxSVy/kIWnEmjQsDGEfgEpAAz
rEYAeFgS8uO3QImCmTQJbcDJM+ITmTNrItmJs2GTmziF+ly6ZOKRipUwblPx0Qc+BCZBClHZqIMD
lCnYDWvJCBQfoDONVkDK8wDEKkR5FmXaVG4StkERHIDCUyndvxacGgEQQOovrBuAhNBq501ZD2Fj
uCD7K8DbKHhnHokb1E+BA3JDqwVMAa3mI6H9OulLuvUEwRWgGvZFJ0ieYB4YAykMyV2Y2S70YMmc
swjxB6Phhg7t2sjx5Kb5JVfS93LzgLApDOANvJuAr0DeoFihu8cC7o+69yJy5bhgBNGRW4fCYzmI
faqvnwrdwHgD0fMV/lHAf0EFqJ802UkwAGXqAXPSDWQNI0l5btAARzgNrjdAe8up5Z5bZ8mFTysF
GEiXe0XEh5wUBNI03XUvHpLgghmWVQeDLhTDGDtpABBVjV1tWAVo/MWmYkMf5JNkPSJ+JkEqd21w
H5QTfEDQKRtQ+WQJL1qJj4f2AXIAfB1a4OWXFSDAQFIUwOKclCWYmWWVcx4Fp5ZPSnkPmmtJqWSW
SPoZ42tH8AIkMHX8SJKOWjFo4aHdCCnQcitWSamSbOI1qGkMnRJIiZutKWJDaH3QlykKiNqZmfEt
AOKTlO5laZlVqqhai8jlk9ZareaDVk14vTpUdFeegutMDLVSKmf//kjAqQIBwlZAGVwdyoZtOFa1
I2Ud4AjpS1S416wEBahY6X44EYksEp/JRY+B6tJqAKf8uaeauf9gGuYEKna6JaXjGkDmqvPO9e+l
sKbL2lMH1CcaufgGzNmxQR1JnREBLACeYxmeEB6G3TxIDoY0yPAopD2aaEEpOB2ra1IGS9CXXUPJ
VQABgzoLcL4J77yzrOgC7CvMOM2KbMzizrTKwpkNvXPPNPHUAAA1I1ywz9Dq7DPAxRYh2AA6cgCp
NzeI5C1WFH7yggYOcIzyhZNWzObV/DRQapUUJ2Wdafm1GWfCXzI7QbxHL0fxy0GZOtNBnBFuSrlF
4ZoPkfcoXuAB/gBIrgDhrkKdr2n07Nx3rZQKdVze/PJHKcUXV7BgDycDGcM4ZgepUtqfgCCDA96i
jICkT+CFT1t0b3H3BBQDBbQRfFNQoiwOL0SPlMoW/VpSqI4adHGZUcATPaWi1WlbkpdWrPDgz3Vq
IOVrTRMCBqRWd5dSf0nQsfg0zPcemQFErPvS0UJsMocDkL1tJY4KBtnKkxsfKOptaQAXFH5VgFO1
bGDFeYiqAgioD+zJT8ULWAWa16YkHS96K9qDaUqkwpY9ZFl6IMD3xlQqxwmvgnN7CLkaBouePOR7
v4LWHnBYN6DhhQEScNkpvvSWAmywP4DwAOdKhIASmQZqDWAh/uf2sofvCRAQYOuBASE4RjhkhSMx
YCAY0uE2CNaAahNMChukVhTIEcwAuALHWuzDrAVAJDNTS91//OHFJKbLaNJLHbJMUb/7FPJ7dqwb
8RZGOkISsm5wzFtOWLi9fzhybnnMRyk2U8jBdXJ5ncSi02iyCslZBxuvE6MbaXMtEiRmRyTbQUrQ
M0tLAK8gbJLBpTiDRHK17xQCMxezziUmmi2zlDhxQAVceDB+MKBdW4Oi4zqJPc74JWJCESaAkLS1
Ss1QAvB7igIuyUxFKq0VeJFmJz9FQXe2MzCAGEcPINPLSGiLMbrjZTv6CQmzrMZgtgLgA151TAPs
RZNTIw4H/pbXRR/Sq31E5AcF4jWPm0UyX0lL3PV2hUda/QqRkmwZHFc3i4hxjycqM42wRmkaWXwq
M27BC0PSt6oWkhQ1EwhjAc9D0EYwCiTgQENRMQJHJjTNczPZiwcKmdF2popWD1tLHreXv8ZJgHBt
wslBlqg3FJ4JFkszmHtMgUEOSu4ADRNrIHZGzsTd50uvQqETrmgcaobVeje0p1I40zoCxAEHA12q
JQ4L0DIqlja/rBpJP5rBp3ZSLVwKwVUU6qJpJqWtpbHe9tqGUkD8Si+S04sHOInSx8VPRLKSKVer
uL1rymwmbTvWX13UEHiWcoQL4YDn+ta/6q0KLbbVIPae/rTB1tUSQul57HN1I5LHYsQyTi0lcfS1
KrOa6XmrWAXhWrYnERUvFZx53DpFuz1ttrUmbZ2Hm74KMeJxlnRzER7ekMW/FjlgLzw5CDbTMl9k
eg6Vnvuqu/jlKnF2V7a1HaIT9TbSAErEALEsW+96uUDdhGUAJPEIYaxLksgyz4ugwlUg+edMSuoi
pA876WU9t0qN2tO2gJTiTqD42kMON7Rlta9ub7ur8dqTZ1OtlGUfAq3tcpY1Ln2fW8QHAC5ScslG
eEBFTiK2x5ZEZMgAx8nCsoIdSIbECRBAgIy823YuuH/sOkKUF9dDn5mulKCrpo2f6cUcA5kfcM2T
XMak/kkf9rg4463JeM1bCnbmx8mnYCejy1ljB3wKV2NF4eheI9R9bth3KziqVh6YgDHMYCUKUKp1
2SPZqFapx/6CKrBo5hz46cVM5ZSPQ8s53Om1JRAyZWHETPEsz/7Dt16McujEKosQ3plr2VPpHg3N
TTbBFWt/BvQQjwW0POrlLQ84Yw9IPUuN4I4hAj2sAmDAhtugWQAwOfEdGbw8GuYQ0zkrwl4iFusB
I4ujDnWwCAs5MVKVTs+qsRJrd23ttkrnbt7MtpKUOUQXC5YCwVgOICj772mTtOCfaSuPsyzqdS+1
NucGhxrEnYdbeoCXS23qXa7EwvmU4FWlAJRxdOg8/rW8wiAE+k/XSlGKhODDsCAc3M17/je/XQXB
O/Yk0ZU+InKBikTkspKW9OfJ6T29Vr0ltoU3ug+hG+UAJbjMTfrNSaL8Z3pXR/tCgtsQt5RIULzi
E5OTLpEHORaCKD93Ax4VeHz44O/9REC89f2QnJvJCKB60sZrjoWaU17mPG98AWgL3vA23nmchMjd
LcBFy5Oo5qNx7RFQGfnQ7wFolhdObGYhRNPPnoXJsbwFaGv1yE++91MvQrNBj/vT70H2WQZP2RCP
sukK3jd3aGNRTRwbHSI460/JfOnXrISFd9/3tge+94H/at9XyfwbFZAthDUFy8MDRJQX0ODgFcWn
/oxf9J9yHuh3jn7Nmz8W4+c1mPBpsiNq52YC8AFmEAID1gVvFNF+D5gFQ5R5zSF6VDAfKiMNGbgE
GwgIFMgXA0hQgSd4FZICAjAAKmGAOABzHEZ9TBZ/gEA1uFd9l9F/TEB5n2J6NhVnG0d8POiBVjd/
jbd1yXF9zsFzkXd9ehCAt+d9tedQoEIP9RaEFHFT7kdfXCSDNcdFNmWDTDZ5NcgEC2EVzFcjaEOC
I7BusTMZwoAOIuAAKvdYAXAgdFiHdugaY3h4/SRuJBiHkDAhb9AOG9AOa+hGv3ODd8iBPzgIHUgK
H2gFKtOIdJGHN8A7BKge+oSGgzcV1bJYNMAS/kvlgok4iqRYin5AicvHYZpoN5fIDd3Sig2CXX+Q
enhiBR0AhdbxhHRSfdORHLXYhG+Rb30CeSbyi+xSe01kYPZXffKnfiwEP71VQh5SYFVya9QRBOQG
HL9hCavoh2a4jS1oiuI4juRIBagIIbCoBl6AGB5AMirIQOm4DWBQVJjnE3BiEE1XjgaRTnBxV/7Y
NX+QEElwHwyQAP7BM0phN8I4DeeYhvEYHOiwGJZYau+IS2TUibOkZoChLvswduKIFJt2UB1JEzLh
VFIAkkigLqzSLEQCLDLxJ5MoBPGYAiITBgQkeGpoiOCojkByiICxK2zBfoABL9pGLlPQLHbU/ikC
qQRLGSCz4JFeY2N/BQhIJpXxoxT5B4S30JBDkABndhiMRYbOR11q+JAYAR9/lwFf2R2iWA0OYwoy
BJXiKInOAyxE4UfQEpIJ035MiE4EYgEv+VUHUExZIwGZI0IRwZWn5iPccJPKkHKJ1U+SkI0uQAYY
aRjItxQIQGBBeSc3YTpGhyQJYTeZxSXjsmNQMiWpslOr6XUGkQBGpzOgGSeqyQCxVjANsCddYwKD
aU2GNSaeOSV0QxD1UXV3UjDz0nSjOVY91lIihUwDoRfIQhCjWZgIEhIxIH2LsoqYsJYENY+9EGpl
uB6L5xBEFG39wZGagRTF+UIPlxbq+Z5J/lYTkXRJaDFSKtYZc9Qs8fEQLUlEqlEi9vYAzHmY/6CS
cQECdvRaPNUiHdkfCOAPRPE4p7FRrDFX7xkUmPN2scmQeAACLBhBCoiT43lAFuELGqCdh9GW1BAU
okIQ09ksOYEUt7VTFlYU+ZITpxGUQHE1yyajAXQaMvElURWYgfmXR0AgxTKkPTZS11MTMsFiNGGb
STY1UTqkjGSVR7ZQe0AgYjcuo6kBWooFQpll5bBhmcidb0iZkumdjGASJdoILCoNDpN2BqAH4lR7
KAmSIFlRNWGgTxike+YiTMqkDnMzBCILO2pNVXo14EAgRccPNlinfkMTBkou6ykTUsVB/hWaZEhE
o4aKpGYyZEYqHRWFHIF5nXbQNhvmmGrqAGzaTyfaC5mjor6gkUxxAF4qYTpUoT6KLsNDoCyDHHE1
psWTMNfUp0zanMwqpO+DFAxAAKW6BQMiqfpmRwSxF6JiAhWKSSUlH3wKrW33Pk/ioET2eA6lKVe1
Ii8pnSRZOXRZBYrpaSi6DP9EgrHKYW4qDiIQp+oYr4xIYLGhNIo0awSKLjuhFASrQ+sUrYtKoPM5
oT9kY5oRl1twl+gyD0yKQ8H6iBJAAKKSRV81MFmaC0VEssCKLiO3p6FZHL66RMCiNRwwrfRZRDoE
sObICZ+GGNnJnd5IYrPaCGzQNqB4/hGK9xdeGpXYsKfFYXT546SzQmQ5RahUe2xN2qyD2ix8uqyf
qZBJ8KL86KhEdD2Dh7C/yqezgg8luayimjqeNWUBtKwft5B9MK/QBZZw4LP+CnhBq447oJDteIlH
yxRvOapaWrWy8B8BtwoOY1okyQ+khRT9AZIDAyx/GaEahaBMe2xD2i4j4iSbIRPMCawqObFaVhNV
G21+gZJpQWeHOjhk4hcLIQHbepfR5kkJYgh225VGW5G6YatF9QW/wDYowRK+ESFzegveZFw886Q3
Wj/D6WtRkxOqoinpwhYjmb2aIiptky7RcZv41VlYUjgIGVVi+g821pv9UJhJARRA/hEXtzmauNsp
bDF4HEk1pYKzR1kOcRoMq6gAaFYWIfpG6aC2i8GKZJG80KCLt2ccUDKgKPZ/aOV4VneLX2iUT5KD
5hdewXd3j4OhtPZdBDB8JeRQsYEn1Jh1vTVKWJIncBcbPCQwaPUu0ihKKRwNu5uGAxxi3Am8RXUC
h7FOd/AoChwN4FWeVMJ6slle97QyBtKXUKiVLxZc96AQkCeDdMuM/jd5OFN/uuiUMJh1tsC4otSi
niAW+5oj3FmIQNuqI1q8NSAA5YhKnxlaRwGJVSBMzoOYquCxO0cLRoiubWINOVw2SeKmY4k7eRDA
Qust5NEJ4kG4CrCDTjx6+gY09KOZm4rbe0bRl1PYhKkQhUYAe1QjLKs5d15rHB7VxSszyKs1xp73
EPVowtEoK7q3f+hnd4Ggy79XDYWsGDTiEkKMhovMyN1wZu7wt8iAIXJcjqqsfwfiffrrzNhBXQbk
qoK3wwFMiB1wS8lAA3PIFCwMBbYgRFLUfVL8ahhMw8SIfuiHKgIStpBXReMMzQIijL5YxoDAe1Uo
ytfxy0BAtGakfCTIxsb8EQSdDConz9Tc0A5digAdBCQToW7wAbjzs8YcQb57B+HA0A09SlCMwXzZ
B5vnUcb40P9MITbZbu7gvyptlt/5xnbQ0Shd0zZNhw8QAQAAOw==

------=_NextPart_000_0000_01C04B5C.911DD620--
