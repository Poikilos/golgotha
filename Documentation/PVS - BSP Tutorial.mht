From: <Saved by Microsoft Internet Explorer 5>
Subject: PVS - BSP Tutorial for Mr-GameMaker
Date: Fri, 8 Dec 2000 21:14:30 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	boundary="----=_NextPart_000_0000_01C0615B.DB988D20";
	type="text/html"
X-MimeOLE: Produced By Microsoft MimeOLE V5.50.4133.2400

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: file://C:\TEMP\downloads\mrgamemaker\PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker.htm

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from =
url=3D(0061)http://www.tasteofhoney.freeserve.co.uk/vsd/pvs/bsppart2.html=
 --><HTML><HEAD><TITLE>PVS - BSP Tutorial for Mr-GameMaker</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252"><!--<meta http-equiv =3D "page-enter" content =
=3D "blendtrans(duration=3D1.5)">-->
<META content=3D"MSHTML 5.50.4207.2601" name=3DGENERATOR></HEAD>
<BODY vLink=3Dblue aLink=3Dblue link=3Dblue>
<CENTER>
<TABLE width=3D"100%" border=3D0>
  <TBODY>
  <TR>
    <TD align=3Dmiddle width=3D118><IMG height=3D70=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/bookshelf.gif"=20
      width=3D118></TD>
    <TD align=3Dmiddle bgColor=3Dred><FONT color=3Dwhite size=3D5>Binary =
Space=20
      Partitioning Tutorial Part II</FONT><BR>
      <CENTER><FONT size=3D2><FONT color=3Dwhite>for=20
      Mr-GameMaker.com</FONT></FONT></CENTER></TD>
    <TD align=3Dmiddle width=3D118><IMG height=3D70=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/bookshelf.gif"=20
      width=3D118></TD></TR></TBODY></TABLE></CENTER>
<TABLE width=3D"100%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D320><IMG height=3D260=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsdemolevel.gif"=20
      width=3D320></TD>
    <TD><BR><BR><FONT color=3Dgreen size=3D4>
      <CENTER><U>Creating a Solid Leaf Tree , Portal Generation , =
Precalculating=20
      a PVS and Adding Frustum Rejection</U></CENTER></FONT>
      <CENTER><BR><FONT size=3D2>written by Gary Simmons<BR>Code by Gary =
Simmons=20
      &amp; Adam Hoult</FONT><BR><FONT size=3D1><BR>Special Thanks to: =
Adam Hoult,=20
      Matthias Liertzer &amp; Klaus Hartmanm</FONT></CENTER><BR>
      <CENTER>API : DirectX 8<BR>
      <CENTER></CENTER></CENTER></TD></TR></TBODY></TABLE><BR><BR>
<CENTER><A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/vsd/pvs/pvs_bsp.zip">Down=
load=20
Bsp_PVS.zip</A></CENTER><BR><BR><U><FONT color=3Dred size=3D5>
<CENTER>VERY IMPORTANT</CENTER></FONT></U><BR>This Tutorial is the Part =
II of=20
the Mr-Gamemaker BSP tutorial series and assumes that you have read and =
fully=20
understood Part 1.If you have not read Part 1 then I STRONGLY suggest =
you go=20
there now and read this tutorial first because much of the code has been =
reused=20
(with small alterations) and that code will NOT be explained again in =
detail in=20
this tutorial. This tutorial will assume that you have read, used and =
fully=20
understood the code from Part 1 and will often make reference to it. If =
you have=20
not read the first tutorial or at least have a VERY strong grasp on =
Solid/Empty=20
BSP trees then this tutorial will make little sense to you as it builds =
on from=20
<A =
href=3D"http://www.tasteofhoney.freeserve.co.uk/vsd/bsp/bsppart1.html">"P=
art 1:=20
Creating a Solid Node BSP Tree"</A>. <BR><BR><U><FONT color=3Dgreen =
size=3D4>
<CENTER>Introduction</CENTER></FONT></U><BR>Wow, this tutorial has taken =
me=20
forever to write, thats not because I am lazy either but because it has =
taken me=20
two months just to get the code working.Infact this tutorial (as you can =

probably tell from the title) is really four tutorial in one.The reason =
though=20
that I have covered all these topics in one tutorial is because they are =
all=20
related to each other and are all needed to create a fast BSP engine . =
We will=20
start by looking at the problems we are trying to solve and exactly how =
the=20
different sub topics of this tutorial relate.For example, we need to =
know how=20
the PVS data will be stored in order to render the BSP tree but we can =
not do=20
that until we know what a PVS actually is.So first of all we will look =
at the=20
different tasks we need to solve (Building a Leaf Tree,Generating =
Portals for=20
the tree and Calculating the PVS for the tree) in theory first and then =
will go=20
back over each one showing exactly how to implement it in =
code.<BR><BR><U><FONT=20
color=3Dgreen size=3D4>
<CENTER>What is a LEAF BSP Tree?</CENTER></FONT></U><BR>You cannot have =
been=20
into 3D Graphics very long if you have never heard people talking about =
leaf BSP=20
Trees.They were used in games such as Quake and Unreal and yet vitrually =
every=20
BSP resource on the internet (including my Part 1 BSP tutorial) only =
covers NODE=20
BSP trees in detail. If you understand how to create a Node Compiler (I =
hope you=20
do) then you will have no difficulty understanding Leaf Trees. So whats =
the=20
difference?<BR><BR>You may remember that when we created our Node Based =
Compiler=20
in part 1 that we fed a large list of polygons into the compiler =
function and=20
the compiler would subdivide the level until every single polygon was =
assigned=20
to a Node.This meant that every polygon had also been used as a =
splitting=20
plane.A Leaf tree compiler takes advantage of the fact that certain =
batches of=20
polygons within a level will not be obscuring one another in any way =
(assuming=20
backface culling is being used) so there is no need to further =
subdivide.The way=20
it works is like this:- <BR><BR>1). First we choose a splitter from the =
Polygon=20
List as we did before BUT instead of storing the polygon itself at the =
Node we=20
only store the polygons Plane.The polygon is marked as having been used =
as a=20
splitter but unlike the Node based compiler we do NOT remove the polygon =
from=20
the list.We send it down its own front list and this polygon may still =
continue=20
to be split by other Polygons Planes.If a polygon that has already been =
used as=20
a Plane is split into two further down the tree then the polygon is =
removed as=20
before and two new polygons are created but it is very important to =
realise that=20
these splits inherit whether or not they have been used as a splitter =
from the=20
parent.In other words, if "Polygon A" is used as a splitter we set a =
variable in=20
that polygon that specifies it had been used as a splitter and should =
not be=20
selected again,the polygon is still processed down the tree however and =
can=20
still be split by planes further down the tree.Now if "Polygon A" then =
gets=20
split into Polygon B and Polygon C then Polygon A is deleted and Polygon =
B and=20
Polygon C inherit the fact that Polygon A has already been used as a =
splitting=20
plane.This means that although polygon B and C are further processed =
down the=20
tree they can never be selected as a Splitter.<BR><BR>At each stage =
through the=20
Compiler loop we check the Front list and the Back list and if all the =
polygons=20
in any of the lists are ALL infront of one another then this list forms =
a convex=20
hull and no longer has to be subdivided because if they are all in front =
of one=20
another then none of them can be intersecting each other.This List =
(Front or=20
Back) then becomes a Leaf.In other words all the polygons in the list =
whether=20
they have all been used as splitters or not are all written to a Leaf =
structure=20
and attached to the current Nodes Front or Back Pointer.When we traverse =
the=20
tree we know that when we hit a leaf we can just render the polygons in =
that=20
leaf in any order.<BR><BR>If your head is already starting to hurt lets =
have a=20
look at the two diagrams below.Figure "A" shows an "L" shaped room =
compiled into=20
a BSP level using a Node based Compiler (the compiler we created in Part =
1)=20
while Figure "B" shows the same geometry being compiled using a Leaf=20
Compiler.Look how much smaller the tree compiled using the Leaf based =
compiler=20
is.In fact it only has one Node and two leafs.It important to realize =
also that=20
in the Node compiler the Polygons themselves were stored at each node =
where as=20
in the Leaf compiler only the PLANE of the polygon selected is stored in =
the=20
node and the polygon is then passed down its own front list. <BR><BR>
<CENTER><IMG height=3D480=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsa.gif"=20
width=3D640></CENTER><BR><BR>Can you see how the Leaf compiler works.It =
chooses=20
Polygon B as a Splitting Plane and then subdivids all polygons as either =
being=20
infront or behind this plane.Polygon E straddles this plane so is split =
into E1=20
and E2. The actual Polygon B is sent down its own front list.First we =
check the=20
Polygons in Node B's front list (A,B,E1,F) and discover that all the =
polygons in=20
this list are ALL facing each other.This means it is a convex hull and =
can be=20
rendered in any order as long as back face culling is enabled.We simply =
write=20
all these polygons to the Leaf structure (which is just a structure that =
holds a=20
list of polygons for that leaf) and attach it to Node B's front.We then =
check=20
Node B's back List and find the same thing.Polygons C,D and E2 are all =
infront=20
of one another making another convex Hull so the polygons are all =
written to=20
another Leaf structure and attached to Node B's back.<BR><BR>You can =
hopefully=20
see how much quicker traversing and rendering the Leaf tree would be.In =
the=20
above example to render the leaf tree we just say :-<BR><BR>
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite>Are we infront of Node =
B?<BR><BR>if Yes=20
      then Render Back Leaf Polygons and then Render Front Leaf=20
      Polygons<BR>else<BR>Render Front Leaf Polygons and then Render =
Back Leaf=20
      Polygons<BR></FONT></TD></TR></TBODY></TABLE><BR></CENTER>Now I am =
not going to=20
go into to much detailed about the Normal Leaf tree shown above because =
we are=20
not going to use one. WHAT?. Yep you heard right, looking at the above =
example=20
there is one big disadvantage with the Normal Leaf Tree.It has no Solid =
/ Empty=20
information.You can see that by traversing the Node Tree in the above =
example=20
that we either end up in SOLID space marked with an "-" (in a wall or =
something)=20
or in Empty space marked with an "E" but the Leaf tree has no such=20
information.This is a huge bummer for me because I loved the way the =
Solid Node=20
compiler could be used for simple and fast "Line Of Sight" =
determinations and=20
"Collision Detection" without having to test a single =
polygon.<BR><BR>Now I find=20
the Solid Node tree a lot more useful so I should just use that but =
there is a=20
big problem.We MUST use a Leaf tree in order to pre calculate a PVS =
(Potential=20
Visibility Set, more on this in a moment).As calculating a PVS to make =
our=20
engine fast is the whole point of this tutorial it seems like loosing =
the=20
solid/empty information is a sacrifice we must make. Not so!!! Enter the =
"Solid=20
Leaf BSP Tree". <BR><BR><U><FONT color=3Dgreen size=3D4>
<CENTER>What is a "SOLID LEAF BSP Tree"?</CENTER></FONT></U><BR><BR>The =
Solid=20
Leaf Tree is really just a mix of the Node tree and the Leaf tree.We =
will really=20
look in detail at how to create one later but for now just bear in mind =
the fact=20
this this is simply an overview.<BR>The ONLY way to accurately divide =
the world=20
into Solid and Empty space is to do what our Node compiler did in the =
previous=20
tutorial and use EVERY polygon in the Level as a split plane.However we =
also=20
want to only store the Polygons Planes in the Nodes like the leaf tree =
and end=20
up with all the polygons batched together in convex leafs.This is =
actually=20
fairly easy to do so lets have a look first of all at the steps we must =
take and=20
then once again have a look at what the "L" shaped room used in the =
above=20
examples would look like if compiled by a Solid Leaf BSP compiler. =
<BR><BR>The=20
Compiler Works Like this:-<BR><BR>1.) At each recursive call of the =
Compiler=20
function, the function is passed a linked list of polygons and a newly =
created=20
empty Node structure.The compilers task is to choose a polygon from the =
list to=20
use as the splitter.A polygon is selected from the list and a Plane is =
created=20
using the polygon info and stored in the newly created Node.This Plane =
is now=20
the splitter for the current Node.We also mark the polygon that was =
selected and=20
from which the Plane was created from as having been used as a splitter =
already=20
so that it can not get choosen again. <BR><BR>2.) Our Next step is to =
loop=20
though every polygon in the list (including the one that was used as the =

splitter) classify the polygon against the splitting Plane.Just as =
before if the=20
Polygon is Behind the plane it gets added to the Back List and if it is =
in front=20
of the plane it gets added to the Front List.If the polygon is ON =
(sharing) the=20
plane then the Normal of the polygon is compared to the Normal split =
Plane.If=20
the Polygons Normal is facing the same way as the Split Plane then the =
polygon=20
is added to the Front List.If the Polygon Normal is facing in the =
opposite=20
direction to the Split Plane then the polygon is added to the back list. =
There=20
should be nothing really new here for you, this is very similar to the =
Node tree=20
except for the fact that in the Node compiler we always Sent ON PLANE =
polygons=20
down the Front list regardless of which way the polygons normal was =
facing.This=20
time as I say above we test the polygon Normal and assign it to a List =
depending=20
on the way it is facing. <BR><BR>3)At this point we now have our Front =
and Back=20
lists successfully built for this call to the compiler function but now =
comes a=20
major difference.We check each Polygon in the Front list and if ALL the =
polygons=20
have already been used as a Split Plane then this is a Convex Leaf and =
the=20
polygons can be written to a leaf structure and attached to the current =
Nodes=20
front.If there are still polygons in the front list then this means that =
all the=20
polygons have not yet been used as splitter and this must be done to =
accurately=20
subdivide space into Solid-Empty areas.So if there is at least 1 polygon =
in the=20
front list which has not been used as a splitter then we create a new =
Node,=20
attach it to this nodes front list and the function recursively calls =
itself=20
with this new node and the Front List of polygons. <BR><BR>4)Just like =
our Node=20
compiler in Part 1 this compiler also works by never having back =
Leafs.In other=20
words a Leaf will always be attached to a Nodes front.We will see this =
in action=20
in a moment.We now check the back list,if there are NO polygons left in =
the back=20
list then we simply store a -1 in the Nodes Back Pointer.This means if =
we ever=20
try to go down the back of this node we will know that the -1 means we =
can not=20
because it is solid space.If however there are any polygons left in the =
back=20
list we create a new node and the function recursively calls itself =
passing in=20
this new node as the current node and passing in the Back list as the =
list of=20
polygons. <BR><BR>Thats it ,thats how its done, it is virtually =
identical to the=20
Solid Node tree except we have managed to pass the polygons down the =
tree after=20
they have been used as splitter planes so that they all end up in convex =

batches. <BR><BR>Lets now have a look at this working with the "L" =
shaped room=20
used in earlier examples:- <BR><BR>
<CENTER><IMG height=3D480=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsc.gif"=20
width=3D640></CENTER>Can you see how it works. It looks virtually =
identicle to the=20
solid Node example in Figure "A" except that because we do not remove =
the=20
polygon that has been used as a splitting plane and pass it down the =
tree you=20
can see that we are pumping the polygons further down the tree until =
they end up=20
in leafs.Its also funny how you do not have to do any explicit test to =
see=20
whether the remaining polygons are convex or not because using our =
method we=20
will always end up with a convex leaf when all the polygons in a FRONT =
list have=20
been used as a splitting plane.<BR><BR>In order for you to better =
understand I=20
will now show another diagram of some slightly more complex geometry =
that causes=20
extra splits so that you can see how polygons already used as split =
planes can=20
still get split.<BR><BR>
<CENTER><IMG height=3D480=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsd.gif"=20
width=3D640></CENTER>Ok then here you can see that we choose polygons =
F's plane as=20
the splitter first which splits polygon D into D1 and D2. F's front list =

contains polygons F,E,D1 .Lets go down the front list first.Next the =
function=20
creates a new node and calls itself with this new list of polygons.Next =
we=20
choose polygon E.E's front list becomes F,E,D1 and because there are NO =
polygons=20
Behind E's plane Node E's back pointer gets set to -1 indicating that if =
we=20
travel down the back of E we will be in solid space.The function then =
calls=20
itself again with a newly created node attached to Node E's front =
pointer and a=20
once again a polygon is selected as a split plane.Note at this point =
that both F=20
and E have been marked as having already been used as split planes so =
the only=20
polygon in the list left to be used as a split plane is D1.D1 is then=20
choosen.There are no polygons behind D1 so Node D1's Back pointer is set =
to=20
-1.Node D1's front list at this time is F,E and D1 still.However,all the =

polygons in this list have now been used as splitter which means that =
the=20
polygons in this list form a convex hull that bounds empty space.This =
means=20
Polygons E,F and D1 are written into a Leaf and attached to Node D1's=20
front.Study the tree in the above diagram until you understand =
completely what I=20
am saying.<BR>Studying the Back List of F is perhaps more revealing as =
to how=20
the whole process works.In F's initial Back list are polygons A,B,C,D2. =
Polygon=20
C is choosen as the Next Splitting Plane.There are no polygons behind C =
so this=20
is marked as being Solid Space.C's front list is A,B,C,D2. Remember that =
C goes=20
down its own front list but is marked as having been used already so can =
never=20
be used as a splitter again.The next splitter choosen from C's Front =
List is=20
Polygon A.Even though C has already been used as a split plane Polygon C =
is=20
still split by Polygon A to create C1 and C2 BUT polygons C1 and C2 =
inherit from=20
the parent Polygon C that it has been used a splitter so C1 or C2 can =
never be=20
selected as a splitter.Here is Figure D again so you can keep it on =
screen as=20
you read.<BR><BR>
<CENTER><IMG height=3D480=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsd.gif"=20
width=3D640></CENTER><BR>Polygon A's front list now consists of polygons =
A,C2,D2=20
and the back list contains B and C1.Next in A's front list we choose D2 =
because=20
it is the ONLY one left in the list which has not been chosen as a split =
plane=20
yet (remembering that the parent polygon D was never used as a split =
plane so D1=20
and D2 inherted its status). D2 has no polygons in its back list so this =
is=20
marked as being solid space and D2 has polygons d2,c2 and A in its front =

list.However these have all been used as splitters which means we are =
now at a=20
leaf and these polygons must form a convex hull.The polygons in the list =
are=20
written to the Leaf structure and attached to D2's front. You can see in =
the=20
diagram that this leaf represents the space bounded by polygons A,C2 and =
D2 so=20
if we ever traverse the tree and end up here we are somewhere in the =
empty space=20
between these polygons.<BR>We only have Node A's back list which we =
still have=20
not dealt with.This consists of polygon B and C1.We select a new =
splitter which=20
must be polygon B because C1 has already been used as a split plane =
(when it was=20
the parent polygon C) and B has no polygons in its back list so Node B's =
back=20
list is set to -1 to represent solid space.Node B's front list consists =
now of=20
polygons B and c1 but both have been used as a splitter already which =
means this=20
is another leaf.These two polygons are written to a Leaf structure and =
attached=20
to Node B's front.<BR><BR>PHEW, you still with me? For those of you that =
are=20
still awake you may be thinking "Isnt this tree going to be just as =
large as the=20
Node Tree?" and the answer is yes.We have to use every polygon as a =
split in=20
order to divide the space up into solid &amp; empty areas but this is =
not such a=20
big deal and here is why.Usually even if using a Normal Leaf tree many=20
programmers will compile a secondary BSP tree for use with collision =
detection,=20
we do not have to because we have all our information in our main =
tree.The other=20
Big question you must be asking is won't this Solid Leaf Tree be much =
slower to=20
Render than a Normal Leaf tree because we have to traverse the whole =
tree to=20
render it.And the answer will be quite suprising, get this, "We are No =
Longer=20
going to Traverse the Tree to render it" &amp; "we will no longer be =
using the=20
BSP tree for back to front ordering".You are probably very confused so =
lets talk=20
about this some more.<BR><BR><U><FONT color=3Dgreen size=3D4>
<CENTER>Rendering the Tree with a PVS and =
Z-Buffer</CENTER></FONT></U><BR>It is=20
time we talked about exactly what a PVS is.It stands for "Potential =
Visibility=20
Set" and is an ARRAY stored for EACH leaf which is used to hold the =
visibility=20
information of all other leafs from that leaf.We look at how the PVS =
data is=20
stored later and will also look at how to generate PVS data for a BSP =
level but=20
for now just understand what it is.Im sorry to have to get into this now =
instead=20
of continuing with our Solid Leaf Tree implementation but the two are =
quite=20
tightly linked.We do not yet need to know how to calculate the PVS in =
order to=20
write our Solid Leaf Tree but we DO need to know how the PVS will be =
stored in=20
memory because our Solid Leaf Tree will use this Data to Render the=20
Tree<BR><BR>For simplicity, at the moment just imagine that each Leaf in =
the=20
tree has an array of bytes equal to the number of leafs in the =
tree.Imagine for=20
now that we are examining the PVS array for one of those leafs, which we =
shall=20
call the current leaf. Each byte in this array is set to either 1 or 0 =
for every=20
other leaf in the tree and determines whether that leaf is visible from =
the=20
Current Leaf.Byte 0 represents leaf 0, Byte 1 represents Leaf 1 etc.For =
example,=20
imagine we are in Leaf 10.We loop through Leaf 10's PVS data and first =
of all=20
check byte 0,if this is set to 1 then Leaf 0 is visible so should be =
Drawn=20
otherwise it should be skipped.I hope you see where this is starting to =
lead.In=20
our previous tutorial we used the BSP for Back to front ordering and how =
ever=20
large the game world was the Entire world was drawn each frame leading =
to loads=20
of Overdraw and a poor frame rate. By precalculting a PVS for each leaf =
ahead of=20
time not only do we not have to render the unseen polygons but we don't =
even=20
have to process them in ANY way. What I mean is we do not even have to =
do costly=20
checks to see if polygons are within the view fustrum or not because if =
they are=20
not in that leafs PVS set then that leaf is simply skipped over and the =
poylgons=20
in that leaf are never processed.<BR><BR>So the general rendering =
algorithm=20
works like this.We traverse the BSP tree each frame just to find out =
which leaf=20
the camera is currently in which will be very quick because we will only =
be=20
traversing a fraction of the tree. Then we loop through that Leafs PVS =
data.Any=20
bytes in the array that are set to one means we render the Leaf =
(polygons in the=20
leaf) with the same number.In other words if Byte 23 is set to one we =
render the=20
polygons in Leaf 23.Do not worry for the moment how we access Leaf 23 or =
how it=20
is stored in memory let me just say that all our leafs will be in an =
Array so=20
accessing Leaf 23 will be as simple as Leaf[23] but we will talk about =
this in a=20
lot more detail later when we actually start to build the tree.<BR>I =
hope you=20
are starting to understand how good this is starting to look for =
us.Instead of=20
having to step through the entire level we just go to the Leaf the =
camera is in=20
and simply do a for/next loop through that Leafs PVS array.The Leafs in =
the=20
array will just be rendered as they are encountered which means we will =
lose our=20
depth sorting information so we will simply enable the Z-Buffer.We will =
most=20
likely need the Z Buffer enabled for the other dynamic and moving =
objects in our=20
scene any way. So then our typical rendering algorithm will look like =
this.This=20
is not the actual code but is just to give an idea of how it=20
works:-<BR><BR><CODE>void DrawTree (long CameraLeaf)<BR>{<BR>for (int=20
i=3D0;i&lt;NumberOfLeafs;i++)<BR>{<BR>long =
offset=3DCameraLeaf*numberOfLeafs;<BR>if=20
(PVSData[offset+i]=3D=3D1)<BR>{<BR>RenderLeaf(i);<BR>}<BR>}<BR>}<BR><BR><=
/CODE><BR><BR>In=20
the above example all the PVS data for all the leafs are stored in one =
master=20
PVSData array.This means we simply pass in the number of the leaf the =
camera is=20
currently in and find the offset into the PVSData array by multiplying =
the=20
NumberOfLeafs by the Leaf we are currently in because each leaf in the =
PVSData=20
array has NumberOfLeafs*BYTE allocated for it.<BR><BR>An important thing =
to=20
remember is that the PVSData array is view independant.When we calculate =
the PVS=20
it will contain all the Leafs that are visible from ANYWHERE inside the =
current=20
leaf.If you look below at figure E you can see that Leafs 2,3,5 * 6 =
would all be=20
potenially visible from Leaf 1.This does not mean however that during =
our game=20
the camera can see into all those leafs just because it is in that =
leaf.You can=20
see below that the camera infact may not be able to see into any of =
those leafs=20
if its current position was to be stood at the south wall of leaf 0 =
facing south=20
so its back was facing all doorways.I hope you realize what I am saying =
here as=20
it is quite important.In other words the PVS determines which Leafs are =
visible=20
from EVERY possible point inside the current leaf and this is not the =
same as=20
what the camera can currently see as the camera could be anywhere in =
that leaf.=20
<BR><BR>
<CENTER><IMG height=3D250=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvse.gif"=20
width=3D324></CENTER>The PVS set reduces the amount of polygons in the =
level down=20
to an amount that can be managed , that is the amount of polygons that =
could=20
possibly be seen from this leaf. We can then perform Frustum rejection =
on the=20
PVS set during rendering to determine exactly what the camera can not =
see. This=20
means even if our Game Level contained 10000 leafs (thats big!) we would =
still=20
only have to process and render a handful of leafs.This means the Frame =
Rate of=20
our level will no longer be related to the Size of our level as it was =
in the=20
Part 1 of this tutorial. Even if like I said there were 10000 leafs in =
your=20
level, in some frames (depending on your Geometry) you might only render =
3 or 4=20
leafs.This means your Polygon Count has just fallen by about 1000% or =
more.Now=20
thats really cool.<BR><BR>If you do not understand much of what I just =
said then=20
I suggest you download the demo that accompanies this tutorial.It allows =
you to=20
see the PVS set working on a top down view of a game level.You can see =
that the=20
PVS set ignores ALL polygons except those in the immediate area that =
could=20
possibly be seen from the current leaf.If you then enable Frustum =
Rejection by=20
pressing F2 you can see how this further refines the PVS set down to =
only leafs=20
that are in the view frustum. <BR><BR>There is a bit of a problem =
though, the=20
PVSData array would be HUGE if we used the methods described above.If =
our game=20
world had 5000 leafs the total memory needed for just the PVS Data alone =
would=20
be:- <BR><BR>
<CENTER><STRONG>5000x5000=3D Bytes =3D 25000000 Bytes =3D 24 MB=20
(approx)</STRONG></CENTER><BR><BR>WOW, thats way too big, thats before =
we even=20
talk about allocating memory for textures and polygons etc or even store =
the BSP=20
tree itself. So what can we do? Well first off, because a leaf is either =
visible=20
or not we do not need a whole byte per leaf thats is just a waste of =
bits.=20
Instead we will store a Bit per Leaf in the PVS set which knocks the PVS =
array=20
down to about 3 MB approx because each byte would now store the =
visibility=20
information for 8 leafs instead of one but it is still a bit large if =
you ask=20
me.<BR><BR>Now there is a way that we can not only save bucket loads of =
space=20
but also speed up the rendering loop a little more as well.In the above =
Code=20
example we had to loop through the leafs PVS array.This means if there =
were 5000=20
leafs although we would no longer have to process,test or render them we =
still=20
have to do 5000 checks of the PVS Data array which ok is not a huge deal =

considering how much time we have already saved ourselves but whats =
great is=20
that we can compress the PVS Data using "Zero Run Length Encoding" and =
this will=20
actually speed up the rendering loop by quite a large amount as well as =
free up=20
loads of memory.<BR><BR><U><FONT color=3Dgreen size=3D4>
<CENTER>Zero Run Length What ?</CENTER></FONT></U><BR><BR>Ok just try =
and=20
imagine a game world in your head as if you were looking down on a large =

installation of some kind with the roof taken off.Imagine this complex =
had=20
thousands of rooms and imagine each room is a leaf. It should be obvious =
that=20
each leaf will only ever be able to see a handful of other leafs at =
most.In=20
other words if there were 1000 rooms in your installation and we were in =
room 0,=20
we probably at most could see into perhaps rooms 1 and 2 for example.OK =
this is=20
a bit of a simple example as doors may be open which would allow you to =
see into=20
other rooms adjoining 1 and 2 but the point is , for each leaf in the =
tree MOST=20
leafs will not be able to be seen from it.This means the PVS data for =
each leaf=20
will be mostly set to zero which is a huge waste. <BR><BR>Now imagine =
that our=20
level has 1000 rooms and we are in leaf 0 and leaf 0 can only see into =
rooms=20
1,2,3,20 &amp; 35.The PVS Data for this leaf would have to be large =
enough to=20
hold a Bit per leaf so (1000+7)&gt;&gt;3=3D126 Bytes (We add 7 and then =
divide by=20
8 to deal with the truncation that happens when dealing with a long.For =
example,=20
if we had 9 leafs we know we need two bytes to hold this =
information.Byte 1=20
would hold the first 8 bits and byte 2 would hold bit 9.It is a common =
mistake=20
to assume that to calculate the space needed we can simply do:- =
9/8=3D1.This would=20
only give us 1 Byte which is in correct.However if we add 7 and divide =
by 8 we=20
get this:- 9+7=3D16/8=3D2.This will always make sure that we round UP to =
the nearest=20
whole number and not Down).Anyway, back to what I was saying, what a =
waste to=20
use 126 bytes for this leafs PVS set when it can only see into 5 =
rooms.Remember=20
also that we are now using a BIT per Leaf in each leafs PVS array, so =
that the=20
visibilitly information for leafs 1,2,3 would all be in Byte 0 of the =
PVS array.=20
The PVS data for leaf 0 without Zero Run Length Encoding would look like =
Diagram=20
F in memory.<BR><BR>
<CENTER><IMG height=3D128=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsf.gif"=20
width=3D640></CENTER><BR><BR>As long as you know your binary (and I hope =
you do)=20
you should have no difficulty understanding the above diagram.In this =
example=20
the Leaf can see Leafs 0(itself),1,2 and 3 and this information is all =
contained=20
in the first byte (Byte[0]).So we set bits 1,2,3,4 to 1 which means that =
byte=20
now holds a value of 15.We can not see any of the leafs ranging from =
8-15 so all=20
the bits in Byte[1] are left at zero giving us a Zero value.The next =
byte in the=20
array (Byte [2]) represents leafs 16-23 and we can see one of these =
leafs, leaf=20
20.Leaf 20's visibility bit is BIT 5 in Byte [2] (16=3Dbit1,17=3Dbit=20
2,18=3Dbit3....etc) so we set the 5th bit in Byte[2] to give it a value =
of 16. The=20
Next Byte in the array represents Leafs 24-31 and none of these leafs =
are=20
visible to the current leaf so we leave this byte set to zero.Byte[4] =
however=20
represents leafs 32-39 and we can see leaf 35 so the appropriate bit in =
Byte[4]=20
is set (bit 4) giving it a value of 8.Now from this point on all the =
other bytes=20
in the PVS Data array would be zero because no other leafs are =
visible.On a very=20
large level this would be a tremendous waste of memory and it would also =
be a=20
waste during the rendering of our level to check all the bytes when we =
know=20
before hand that the rest of the array is set to zero. <BR><BR>Look =
below and=20
you will see the Same example being represented using Zero Run Length =
Encoding=20
(ZRLE) which compresses this very simple data set from 126 Bytes right =
down to 9=20
BYTES.Now this is a very simple level but just imagine how much memory =
could be=20
saved on large levels and also imagine how much quicker it would be to =
loop=20
through 9 bytes at every leaf instead of 120.Magnify that when using a =
large=20
data set and you can see the real advantage.Take a look and see if you =
can see=20
what is happening. <BR><BR><STRONG>
<CENTER>15 , 0 , 1 , 16 , 0 , 1 , 8 , 0 , =
121</CENTER></STRONG><BR><BR>When a=20
Byte does not equal zero we simply write it to the array as normal.You =
can see=20
that byte zero which was equal to 15 does not get compressed in any way =
and is=20
instead just written to the data array.However,when a Zero is=20
encountered,instead of just writing it to the array we count how many =
zeros=20
follow it.Now in our example there is only one zero at byte 1 so we =
write in the=20
Zero byte followed by an additional byte which describes how many zeros =
are in a=20
run .You can see the saving more clearly at the end were we would have =
had a run=20
of 121 additional bytes instead just represented by two bytes (0 and =
121).On=20
very large data sets you would get many runs throughout the data set, =
the=20
maximum single run of zeros can be at most 255 because that is the most =
a single=20
byte can hold to represent the run length. <BR><BR>Now with our PVSData=20
represented like this we can speed up rendering using something like the =
code=20
below.DO NOT panic , you are not supposed to understand the following =
code yet=20
as we have not even looked at the code to build the Solid Leaf Tree yet =
but I=20
have highlighted the green section to show what happens in the Render =
loop if=20
the Current PVSData is NON zero and highlighted the Blue section to show =
how the=20
Zero byte runs can be quickly skipped passed during the rendering =
process.Do not=20
worry all this will make sense later on.:- <BR><BR><CODE>void =
DrawTree(long=20
leaf)<BR>{<BR>POLYGON *CurrentPoly;<BR>int i;<BR>long=20
PVSOFFSET=3DLeafArray[leaf].PVSIndex;<BR>BYTE=20
*PVSPointer=3DPVSData;<BR>PVSPointer+=3DPVSOFFSET;<BR>long =
currentleaf=3D0;<BR>while=20
(currentleaf&lt;NumberOfLeafs)<BR>{<BR>if (*PVSPointer!=3D0)<BR>{ =
<BR><FONT=20
color=3Dgreen>for (i=3D0;i&lt;8;i++)<BR>{ <BR>BYTE =
mask=3D1&lt;&lt;i;<BR>BYTE=20
pvs=3D*PVSPointer;<BR>if (pvs&amp;mask)<BR>{<BR>Render The Polygons in =
Leaf [=20
currentleaf ]; }<BR>}// end for if pvsdata<BR>currentleaf++;<BR>}// end =
for=20
i;<BR>PVSPointer++;<BR></FONT>}<BR><BR>else<BR><BR>{// we have hit a =
zero so=20
read in the next byte and see how long the run of zeros is<BR><FONT=20
color=3Dblue>PVSPointer++;<BR>BYTE=20
RunLength=3D*PVSPointer;<BR>PVSPointer++;<BR>currentleaf+=3DRunLength*8;<=
BR></FONT>}<BR></CODE><BR>In=20
the above code just know for now that each leaf has a PVSIndex variable =
that=20
describes how far into the Master PVSData array its own PVS set =
begins.Remember=20
that each leaf has a PVS Set all of its own but all the leafs will store =
their=20
PVS Sets together in one master array.It is this master array which is =
commonly=20
known as a PVS and describes the visibility off all leafs from any other =

leaf.<BR><BR>Also in the above code, if a Non zero byte is encountered =
(green=20
code) then we loop through all 8 bits in that byte rendering the =
polygons in any=20
leaf which has its bit set to one.Remember that each bit in that byte =
represents=20
a leaf . However if a zero is encountered in the PVSData array we simply =
adjust=20
the CurrentLeaf variable to compensate for how many leafs would have =
been=20
represented by the bits in the zero run, which speeds us past all the =
zeros and=20
therefore helps us speed up the main rendering loop which exits once =
CurrentLeaf=20
&gt; NumberOfLeafs.<BR><BR>Anyway, enough of all this for now, it was =
important=20
for you to realize how the PVS Data would be stored because we are now =
going to=20
go back and start to create the Solid Leaf Tree and we have to consider =
this=20
during Tree creation.<BR><BR>We will look at how to create the PVS Data =
later on=20
after we have created the Solid Leaf tree but for now lets not worry =
about it=20
and just get stuck into the task at hand.The Creation of a Solid Leaf =
BSP Tree=20
compiler.<BR><BR><U><FONT color=3Dgreen size=3D4>
<CENTER>Creating a Solid Leaf BSP =
Compiler</CENTER></FONT></U><BR><BR>For those=20
of you that have either implemented a BSP compiler and renderer based on =
my code=20
in Part 1 of the tutorial or have created BSP Compilers based on linked =
lists=20
yourself you are going to have to make a leap of faith from this point =
on . In=20
the previous tutorial the tree we created consisted of Nodes and =
polygons all=20
linked together in a linked list form and we simply traversed the tree =
by=20
jumping through the front and back pointers.Although this worked fairly =
well=20
there were a few disadvantages.First of all with our PVS we will need to =
be able=20
to get to a Leaf directly to render the polygons in that leaf and the =
linked=20
list system was not too good for that. Unless you stored pointers for =
every leaf=20
in every other leaf (thats a no no) the only other way would be to store =
an ID=20
in each leaf and traverse the tree until you found it.Thats pretty =
stupid=20
because if we know that Leaf 10 is visible we want to access Leaf 10 =
straight=20
away and render it. Also using a linked list system makes the BSP and =
all it's=20
relative information a little tricky to save out to Disk.I have had =
several=20
emails from people who wanted to know how to save the BSP tree in our =
previous=20
tutorial and it isnt that simple.The real pain is that each node was =
linked to=20
every other node using pointers to memory blocks but when the file was =
saved to=20
disk these pointers were no longer useful because they pointed to =
absolute=20
memory addresses.When you loaded the tree back in the nodes would never =
be=20
stored in exactly the same locations so you had to implement some sort =
of scheme=20
where the tree could be reconstucted (not recompiled just rebuilt) at =
load=20
time.Although this was not really that hard to do it was a little messy=20
especially with all the new information we are going to need in this =
tutorial=20
,so now we are going to use Arrays to store the nodes,planes,Leafs and =
polygons=20
etc in linear memory blocks so that every node in the tree for example =
could be=20
saved out to disk with just one call to a Write command.The same will be =
true=20
for an array of Leafs which will be stored in a Leaf Array and the same =
for the=20
Polygons and Planes etc etc .Every leaf in the tree could be written to =
disk=20
with just one call.There is another big advantage of this also.If we are =

rendering and we find that Leaf 10 is visible we can access the leaf by =
doing=20
something as simple and as direct as Leaf[10] instead of having to =
traverse the=20
tree.In other word then, out BSP Tree will actually be just a Set of =
Arrays,A=20
Node Array which will hold all the Nodes in the BSP Tree,a Leaf array =
which will=20
hold all the Leafs in the tree and so on.This means that instead of a =
Node=20
pointing to another Node in memory (as we did in part 1) a Node will now =
link to=20
another node using an Array Index instead.For example, if Node 1 in the =
array=20
linked to Node 5 with its front pointer (pointer being used loosely =
here) ,=20
instead of having Pointer Pointing to Node 5's memory(as we did before) =
,Node 1=20
would simply have a value of 5 in its Front Index value.What I am saying =
here is=20
that Nodes are no longer linked by pointers but now use indices into =
arrays=20
instead.We will see some diagrams of this in a moment.<BR><BR><U><FONT=20
color=3Dgreen size=3D4>
<CENTER>Memory Allocation</CENTER></FONT></U><BR>Lets start of by =
looking what=20
the NODE structure for our compiler looks like.It is shown below:-=20
<BR><BR><CODE>struct NODE <BR>{<BR>unsigned char IsLeaf;<BR>unsigned =
long=20
Plane;<BR>unsigned long Front;<BR>signed long Back;<BR>BOUNDINGBOX=20
BoundingBox;<BR>};<BR><BR></CODE>Looking at the above structure you can =
see that=20
there are no Front and Back pointers but instead there are front and =
back "long"=20
variables.Instead of having pointers pointing to memory addresses that =
hold the=20
front and back nodes instead we simply store a long value that is the =
index of=20
another Node in the Node array.If Back is set to -1 then it does not =
point to=20
another node in the array but instead indicates that there is solid =
space behind=20
this Node (remembering that you never have Back Leafs).If IsLeaf=3D0 =
then the=20
Front value is the index of another Node in the Node array however if =
IsLeaf=3D1=20
then this means that to the front of this node is a Leaf.In this case =
"Front"=20
does not hold the value of an index of a node in the node array but =
instead=20
holds the index of a Leaf in the Leaf array.Also remember that we no =
longer use=20
the Polygons themselves as splitters but instead just the Planes of the =
polygons=20
are stored.Therefore the "Plane" variable in the Node structure is an =
index in=20
to the Plane Array which is an array where all the Nodes Planes are=20
stored.Please do no not worry about what the BoundingBox variable is for =
we will=20
look at this in a moment.The Plane structure looks like=20
this:-<BR><BR><CODE>struct PLANE<BR>{<BR>D3DXVECTOR3=20
PointOnPlane;<BR>D3DXVECTOR3 Normal;<BR>} ;<BR><BR></CODE>The Plane =
structure=20
just contains two Vectors that describe the plane for the node.Node 1 in =
the=20
array will use Plane 1 in the array and Node 2 in the Node array will =
use Plane=20
2 in the plane array etc.Figure G below better decribes the memory =
organization=20
we will be employing. <BR><BR>
<CENTER><IMG height=3D480=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsg.gif"=20
width=3D640></CENTER>In this example Node[0].Front holds a value of 1 =
because it=20
points to Node [1] in the array.Node[0].Back points to Node[3] or rather =
holds=20
the value of 3 meaning if we go down the back of this node we are at =
Node 3.=20
This is really no different from using the Linked List except we are now =
just=20
using Linked arrays and storing indexes instead of pointers.Each Node is =
a split=20
plane obviously so its Plane variable holds an index of a Plane in the =
Plane=20
Array. Above Node[0].Plane=3D0 because its Plane is stored in the Plane =
Array at=20
position Plane[0] .You can see that several Nodes in the Node array have =
'-1' as=20
the value in their Back variables which means there are no more polygons =
behind=20
it so it is solid space. Node 7 is interesting.If the Node has its =
IsLeaf=20
variable set to "1" then the Front Variable holds the index of a Leaf in =
the=20
leaf array.If you went down the Front of node 7 you would be in empty =
space and=20
you would also be in leaf 0.<BR><BR>Lets have a look at what the Leaf =
structure=20
looks like:-<BR><CODE>struct LEAF{ <BR>long StartPolygon; <BR>long =
EndPolygon;=20
<BR>long PortalIndexList[50]; <BR>long NumberOfPortals;<BR>long =
PVSIndex;=20
<BR>BOUNDINGBOX BoundingBox;<BR>};<BR><BR></CODE>There will be a few =
variables=20
in there that you do not understand yet such as NumberOfPortals and=20
PortalIndexList but we do not need those for tree creation so will =
ignore them=20
for now.They will be used later to calculate the PVS set. "PVSIndex" =
will=20
eventually hold the position in to the Master PVS array where this leafs =

visibility information begins.That will all become clearer later.For now =
we are=20
only interested in StartPolygon and EndPolygon. As with the Node based =
compiler=20
we developed in Part 1 we will pass in our polygon data into the =
Compiler as a=20
linked list of polygons just like before.The difference is that once we =
find we=20
have a list of polygons that are convex (they have all been used as =
splitters)=20
we can delete it in the linked list and copy its memory in to a Master =
Polygon=20
array.The great thing about this is that because a list of polygons in a =
Nodes=20
Front list will only get copied into the Polygon array when they form a =
leaf it=20
means the polygons get written into the array Leaf at a time.This means=20
Leaf[0]'s polygons all follow each other in the array followed by =
Leaf[1]'s=20
polygons etc. This means all we have to store in the Leaf structure is =
where in=20
the array it's polygons start and end. Actually 'EndPolygon' as you can =
see from=20
the diagram is the first polygon in the Next Leaf. This is because I =
render them=20
in a loop using " For=20
(poly=3DLeaf[n].StartPolygon;poly&lt;Leaf.[n].EndPolygon;poly++)". In =
other words=20
we render from Start to End-1 but thats just standard c++ loop stuff. =
<BR><BR>
<CENTER><IMG height=3D407=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsh.gif"=20
width=3D417></CENTER>The BoundingBox variable above is simply a =
structure that=20
holds two vectors describing in world space the dimensions of a bounding =
box=20
that encompasses all the polygons in the leaf. We will need this =
information=20
during rendering to test if a leafs Bounding Box is within the =
Frustum.Checking=20
an Entire Leafs bounding box is much quicker than checking each polygon =
in the=20
leaf and the tests can be done very quickly.This Bounding Box will be =
calculated=20
in the main compiler function. You may have noticed above that the Node=20
Structure also has a bounding box variable.This will hold the Bounding =
Box=20
needed to encompass all Leaves in its front and back trees.Unlike the =
Leaf=20
structure the Nodes Bounding Box information will not be needed after =
the tree=20
has been compiled,in other words it is not needed at runtime but instead =
is used=20
to compute the PVS Data as we will see later.This Bounding Box will also =
be=20
calculated during BSP Compilation but once the PVS Array is built there =
is no=20
need for it any more. <BR><BR>Look at the diagram below. The Green Box =
shows the=20
Bounding Box for Node E , notice that it has to be big enough to =
encompass all=20
polygons in its front and back tree (although Node E has no back tree) =
in others=20
words large enough to contain polygons F,E &amp; D1 because these =
polygons are=20
in a leaf that is in Node E's front tree.<BR><BR>
<CENTER><IMG height=3D392=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsi.gif"=20
width=3D559></CENTER><BR><BR>The Blue Bounding Box above is Node B's =
Bounding=20
Box.Notice that it only has to be big enough to hold polygons B and C1 =
because=20
there is only one leaf in Node B's front tree that contains those =
polygons. Also=20
remember that I said we will want to store a Bounding Box for each Leaf =
as well=20
as each Node. If you look at the tree above you can also look at a leafs =

Bounding Box as being the the Bounding of the Parent Nodes front =
list.You can=20
look at the Nodes Bounding Box as being the Bounding Box large enough to =
contain=20
the nodes front and back list. We will not be needing these Bounding =
Boxes yet=20
but it is important you realise exactly what a Bounding Box around a =
Leaf and a=20
Node looks like because although we will not be using them until later , =
we will=20
have to calculate the Bounding Boxes at the same time as we compile the =
BSP=20
Tree.<BR><BR><U><FONT color=3Dgreen size=3D4>
<CENTER>Memory and Speed Considerations</CENTER></FONT></U><BR><BR>Now =
something=20
you may be wondering about with this whole array approach is how to know =
how=20
much space to allocate for each of the Node,Leaf,Polygon and Plane =
arrays.We=20
certainly do not want to statically allocate the memory to some huge =
number=20
because this is very wasteful and risky just hoping we have allocated =
enough.=20
Instead we will dynamically allocate the memory for these arrays at the =
start to=20
some thresh hold and when the number of the elements in that array go =
past this=20
threshold we can just reallocate (resize) the memory block .You could =
for=20
example allocate an initial Node array with room for just one Node and =
then when=20
a second node is needed we could resize the Array to contain 2 elements =
instead=20
of one.We will be using the C function 'malloc" to dynamically create =
the array=20
which gives us a nice way to reallocate the array using 'realloc' if our =
number=20
of elements needed exeed the size of the array.The problem is with =
resizing the=20
array every time a new element is added is that this can be very slow.If =
the=20
'realloc' function can not resize the array in its current position in =
memory it=20
will have to create a new memory block of the desired size and copy all =
the data=20
over from the old position to the new position.Doing this every time a =
new node=20
is needed or every time a new polygon,leaf or plane is needed is going =
to be dog=20
slow.Although this is a development and not a runtime process so speed =
is not so=20
critical it can still be a pain in the **** waiting for a large level to =

compile.<BR><BR>So what we will do is set some threshold.I have =
allocated enough=20
memory initially to hold 100 elements in each array and set each arrays=20
threshhold to 100. Everytime this threshold is reached I resize the =
array by=20
another 100 elements and add 100 to the threshold so now the threshold =
is at=20
200.Then when we try to add the 200th element to the array it will be =
resized=20
again this time adding enough room for another 100 elements on the end =
and once=20
again the threshold will be increased by another 100 to 300.Once the BSP =
tree is=20
compiled I will finally resize the arrays one final time to the correct =
size=20
needed because only at the end of the compilation process will we now =
exactly=20
how many leafs,nodes and polygons we have. <BR><BR>Its now time to =
examine the=20
code in the demo at last.All the "Solid Leaf BSP Tree" code is in the =
module=20
'BSPTree.CPP' and memory allocation functions are in the module=20
'MemoryAlloc.CPP'.These are the only two modules we need to concentrate =
on for=20
now except the module 'main.cpp' which is just the module that loads in =
the=20
polygons, sets uo the D3D environment and controls the camera in the =
demo.This=20
tutorial is not going to cover the Camera Movement code or the D3D Setup =
code as=20
these are all covered by other tutorials elsewhere on this site.Anyway =
enough=20
chit chat already lets write some code. <BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>Coding the Solid Leaf BSP Tree=20
Compiler</U></FONT></CENTER><BR><BR>The first function to be executed of =
any=20
interest is 'InitPolygons' in 'Main.CPP'. Lets have a look at=20
it:-<BR><BR><CODE>void=20
InitPolygons(void)<BR>{<BR>ReserveInitialMemoryForArrays();<BR><BR>Polygo=
nList=3DNULL;<BR>PolygonList=3DLoadMWM("demolevel.mwm");<BR>LoadTextures(=
);<BR><BR>BuildBspTree(0,PolygonList);<BR>...<BR>...<BR>...<BR>}<BR><BR><=
/CODE>The=20
InitPolygons function is called just after the D3D environment has been =
set=20
up.The first thing it must do is call 'ReserveInitialMemoryForArrays' =
function=20
which is in MemAlloc.Cpp.We will see this function in a moment after we =
have=20
just had a look at the net couple of lines.The Next 'InitPolygons' does =
is sets=20
the PolygonList pointer to NULL for safety.The PolygonList pointer is a =
global=20
pointer that will point to the head of a linked list of polygons that =
will be=20
fed into the compiler.This is virtually exactly the same as the previous =

tutorial except the Polygon Structure is a little different.Here is the =
Polygon=20
Structure.<BR><BR><CODE>struct POLYGON <BR>{<BR>D3DLVERTEX=20
*VertexList;<BR>D3DXVECTOR3 Normal;<BR>WORD NumberOfVertices;<BR>WORD=20
NumberOfIndices;<BR>WORD *Indices;<BR>POLYGON * Next;<BR>bool=20
BeenUsedAsSplitter;<BR>long TextureIndex;<BR>};<BR><BR></CODE>This is =
almost=20
identicel to the last tutorial.The Polygons will be linked together by =
the=20
'Next' pointer and the Polygon itself will be made from an indexed =
triangle=20
list.The 'AddPolygon' function we will look at in a moment is =
responsable for=20
taking an n sided polygon and breaking it down into indexed =
triangle.This was=20
covered in detail in the last tutorial.Each polygon also has a texture =
index.In=20
the demo I load in 25 textures into an array of IDirect3dTexture8 =
objects so=20
this is basically just an index in to this array describing what texture =
the=20
polygon uses.Also note the 'BeenUsedasSplitter' flag that is set during=20
compilation of the bsp tree to signify that this polygon has already =
been used=20
so can not be used as a split plane again.<BR>Unlike the last tutorial =
where we=20
generated some basic polygons within the code itself this time I load =
the=20
geometry in from an external file.I made the level with a simply Polygon =
Builder=20
I knocked up in an evening and the polygons are just saved in the file =
in a very=20
simple file format.Basically they are just lists of D3DLVERTEX =
structures.=20
<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite>API Notice for DX8:<BR>With =
DX8 the=20
      D3DLVERTEX built in vertex structure is no longer present.You now =
specify=20
      vertex types using the flexible vertex format.I have named my =
Custom=20
      Vertex structure 'D3DLVERTEX' after the structure that it emulates =
from=20
      Dx7.It is defined in 'pvs.h' as follows:-<BR><BR><CODE>struct=20
      D3DLVERTEX<BR>{<BR>float x;<BR>float y; <BR>float z; <BR>D3DCOLOR=20
      color;<BR>D3DCOLOR specular;<BR>float tu;<BR>float=20
      tv;<BR>};<BR><BR></CODE>The Flexible Vertex Format Flags for this =
vertex=20
      are as follows:-<BR><BR><CODE>&gt;#define D3DFVF_LVERTEX ( =
D3DFVF_XYZ |=20
      D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1=20
  )<BR></FONT></CODE></TD></TR></TBODY></TABLE><BR><BR>The next line in =
the=20
'InitPolygon' function=20
is:-<BR><BR><CODE>PolygonList=3DLoadMWM("demolevel.mwm");</CODE><BR><BR>T=
his calls=20
the LoadMWM function which loads in each polygon from the file and =
returns them=20
all nicely broken down into triangle lists and links together in a =
linked=20
list.The function returns a pointer the the first Polygon in the =
list.All we=20
have to do then is pass this pointer into our BuildBSPTree=20
function.<BR><BR>Before we get ahead of ourselves then lets just back =
track a=20
few lines and have a look at the 'ReserveInitialMemoryForArrays'=20
function.(memalloc.h) and some global variables that are used to control =
and=20
handle the arrays.<BR><BR><STRONG><U><FONT=20
color=3Dgreen>GLOBALS</FONT></U></STRONG> <CODE><BR><BR>long =
MAXNUMBEROFNODES=20
=3D100;<BR>long MAXNUMBEROFPOLYGONS=3D100;<BR>long MAXNUMBEROFPLANES =
=3D100;<BR>long=20
MAXNUMBEROFLEAFS =3D100;<BR>long MAXNUMBEROFPORTALS =
=3D100;<BR></CODE><BR><BR>These=20
are the Thresholds we talked about earlier.Because each array will =
initially be=20
allocated with 100 elements we set these to 100 also.When the Number of =
Nodes=20
reaches MAXNUMBEROFNODES then we know it is time to resize the array and =
then=20
add another 100 on to MAXNUMBEROFNODES which will take the =
MAXNUMBEROFNODES up=20
to 200 which is the next threshold at which the array will need to be =
resized.In=20
other words, these variables keep track of the current size of each=20
array.<BR><BR>Next up are the Global Pointers for each array.These will =
store=20
all the information for our BSP tree.Once the memory has been allocated =
for them=20
we will access them more like normal arrays (ie =
NodeArray[1],PlaneArray[2]=20
etc).<BR><BR><CODE>POLYGON *PolygonArray;<BR>NODE *NodeArray;<BR>LEAF=20
*LeafArray;<BR>PLANE *PlaneArray;<BR>PORTAL **PortalArray;<BR>BYTE=20
*PVSData;<BR><BR></CODE>Do not worry about the PortalArray for now this =
is=20
something we will discuss way on down the tutorial.The last few globals =
to be=20
declared in memalloc.cpp are the actual variables to keep track of how =
many=20
Planes,Nodes,Polygons etc we have in our array.Remember that how many =
NOdes we=20
have in the Node Array is not the same as MAXNUMBEROFNODES as this =
contains how=20
many nodes we can store in our array before we need to resize.In other =
words if=20
we have just added our 101st Node to the node array then the Number Of =
Nodes=20
will be 101 but the MAXNUMBEROFNODES will be 200 as it is resized on the =
100=20
boundry.<BR><BR><CODE>long NumberOfPolygons=3D0;<BR>long =
NumberOfNodes=3D0;<BR>long=20
NumberOfLeafs=3D0;<BR>long NumberOfPlanes=3D0;<BR>long=20
NumberOfPortals=3D0;<BR><BR></CODE>Once again do not worry about =
NumberOfPortals=20
yet.OK now we know what the Global arrays look like lets have a look at =
that=20
'ReserveInitialMemoryForArrays' function.<BR><BR><CODE>void=20
ReserveInitialMemoryForArrays()<BR>{<BR>NodeArray=3D (NODE *) malloc=20
(MAXNUMBEROFNODES *sizeof(NODE));<BR>PolygonArray=3D(POLYGON *)malloc=20
(MAXNUMBEROFPOLYGONS *sizeof(POLYGON));<BR>PlaneArray =3D(PLANE *) =
malloc=20
(MAXNUMBEROFPLANES *sizeof(PLANE));<BR>LeafArray =3D(LEAF *) malloc=20
(MAXNUMBEROFLEAFS *sizeof(LEAF));<BR>PortalArray =3D(PORTAL**) malloc=20
(MAXNUMBEROFPORTALS *sizeof(PORTAL *));<BR><BR>ZeroMemory(NodeArray,=20
sizeof(NODE) *MAXNUMBEROFNODES);<BR>ZeroMemory(LeafArray, sizeof(LEAF)=20
*MAXNUMBEROFLEAFS);<BR>ZeroMemory(PlaneArray, sizeof(PLANE)=20
*MAXNUMBEROFPLANES);<BR>ZeroMemory(PolygonArray,sizeof(POLYGON)=20
*MAXNUMBEROFPOLYGONS);<BR>ZeroMemory(PortalArray, sizeof(PORTAL*)=20
*MAXNUMBEROFPORTALS);<BR>}<BR><BR></CODE>Nothing to explain here.Each =
array is=20
dynamically initiated as being large enough to hold 100 elements of =
their=20
type.Then the arrays are initialized to zero for safety.So we now have a =
Node=20
Array, and Plane Array a Leaf Array and a Polygon Array each large =
enough to=20
hold 100 elements but for the moment are empty.<BR><BR>So after this =
function is=20
called by 'InitPolygons' the next function to be called is =
'LoadMWM'<BR><U>Note:=20
PolygonList is a Global of type POLYGON=20
*<BR><BR></U><CODE>PolygonList=3DLoadMWM("demolevel.mwm");<BR></CODE><BR>=
OK well=20
we already know what this function does.It returns a linked list of all =
the=20
polygons in the file 'demolevel.mwm.".This is exactly what we need to =
feed into=20
our BSP compiler. I know you will al have your favourate World Modellers =
etc but=20
in the interest of being complete let me just explain the very simple =
file=20
format I have used to hold the geometry.It is basically just a list of=20
polygons.Here is the file template:-<BR><BR>
<TABLE width=3D"80%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D"25%" bgColor=3Dyellow>WORD</TD>
    <TD>Number of Polygons in File</TD></TR></TBODY></TABLE>For Every =
Polygon N=20
<TABLE width=3D"80%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D"25%" bgColor=3Dyellow>WORD</TD>
    <TD>Number of Vertices in Polygon N</TD></TR></TBODY></TABLE>For =
Every Vertex M=20
in the Polygon N=20
<TABLE width=3D"80%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D"25%" bgColor=3Dyellow>D3DLVERTEX </TD>
    <TD>Vertex Number M</TD></TR></TBODY></TABLE><BR>
<TABLE width=3D"80%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D"25%" bgColor=3Dyellow>WORD </TD>
    <TD>Texture Index for Polygon N =
</TD></TR></TBODY></TABLE><BR><BR>Thats it.Just=20
the number of polygons in the file, followed by the vertex count of the =
first=20
polygon, followed by the list of vertices for that polygon, followed by =
the=20
Texture index that identifies which texture the Polygon Uses.Then the =
Vertex=20
Count for the Second polygon in the file followed by the vertex list for =
the=20
Second poly followed by the second polys texture index etc etc etc.Note =
that the=20
polygons in the file have not been triangulated and can be any sided =
convex=20
polygons.We will break the polygons down into triangles during load=20
time.<BR><BR>Ok lets have a look at the code to the LoadMWM function.MWM =
stands=20
for Mr World Maker which I called my little home made world editor for a =
joke.It=20
is an extremely bad world editor but I did make it in one night just to =
quickly=20
let me whip up some polygons for this tutorial.The polygons are stored =
in a file=20
called 'demolevel.mwm'. The loading code looks like =
this.<BR><BR><CODE>POLYGON *=20
LoadMWM(char *filename)<BR>{<BR>FILE *stream;<BR>POLYGON =
*Root=3DNULL;<BR>POLYGON=20
* Child=3DNULL;<BR>WORD PolyCount,numofverts;<BR>int i,b;<BR>D3DLVERTEX=20
xyzBuffer[50];<BR>WORD TextureIndex;<BR>DWORD uselessinfo;<BR><BR>stream =
=3D=20
fopen(filename, "rb");<BR>fread(&amp;PolyCount, sizeof( WORD ), 1, =
stream=20
);<BR>for=20
(i=3D0;i&lt;PolyCount;i++)<BR>{<BR>fread(&amp;numofverts,sizeof(WORD),1,s=
tream);<BR>for=20
(b=3D0;b&lt;numofverts;b++)<BR>{<BR><BR>fread(&amp;xyzBuffer[b].x,=20
sizeof(float),1,stream);<BR>fread(&amp;xyzBuffer[b].y,=20
sizeof(float),1,stream);<BR>fread(&amp;xyzBuffer[b].z,=20
sizeof(float),1,stream);<BR>fread(&amp;uselessinfo, =
sizeof(DWORD),1,stream=20
);<BR>fread(&amp;xyzBuffer[b].color,=20
sizeof(D3DCOLOR),1,stream);<BR>fread(&amp;xyzBuffer[b].specular,sizeof(D3=
DCOLOR),1,stream);<BR>fread(&amp;xyzBuffer[b].tu,=20
sizeof(float),1,stream);<BR>fread(&amp;xyzBuffer[b].tv,=20
sizeof(float),1,stream);<BR>}<BR>fread(&amp;TextureIndex,sizeof(WORD),1,s=
tream);<BR><BR>if=20
(i=3D=3D0)<BR>{<BR>Root=3DAddPolygon(NULL,&amp;xyzBuffer[0],numofverts);<=
BR>Child=3DRoot;<BR>}<BR>else<BR>{<BR>Child=3DAddPolygon(Child,&amp;xyzBu=
ffer[0],numofverts);<BR>}<BR>Child-&gt;TextureIndex=3DTextureIndex;<BR>}<=
BR>fclose=20
(stream);<BR><BR>return Root;<BR>} <BR><BR></CODE>As you can see there =
is=20
nothing fancy about the file extraction.We simply read in the Number of =
polygons=20
in the file and then do a for next/next loop for each polygon.For each =
polygon=20
we read in its number of vertices and then the vertex list which is just =
a bunch=20
of D3DLVERTEX structures. Notice how I load in one DWORD of useless=20
information.This is because my Polygon Editor was written in DX7 where =
the built=20
in D3DLVERTEX structure had a reserved DWORD value after the first =
vector. The=20
D3DLVERTEX is no longer internal to DX8 so I have emulated it using the =
Flexible=20
Vertex Format. Our Custom D3DLVERTEX structure though does not have that =

Reserved DWORD so we simply read it in and discard it just as a simple =
means of=20
moving the file read counter on to the next useful bit of information.=20
<BR><BR>The last thing we read in for each polygon is the number of the =
texture=20
it uses.This Texture index corresponds to the order in which we will =
load our=20
textures in a moment.<BR><BR>As with Part 1 of this tutorial , the real =
guts=20
happens in the "AddPolygon" function.This function takes an array of =
D3DLVERTEX=20
structures and a WORD value describing the number of verts in the array =
and=20
breaks the polygon down into a indexed triangle list.The first parameter =
to this=20
function though is of type POLYGON * and this is the Parent polygon for =
which=20
the newly created polygon will be attached.In other words,the AddPolygon =
also=20
builds the Linked list.Because we always pass in the previously created =
polygon=20
as the parent and get returned a pointer to the newly created polygon =
which can=20
then be used as the parent in the next call, you can see that every new =
polygon=20
created is added to the end of the linked list by using the Parents Next =

pointer.<BR>Notice in the above code though that if this is the first =
polygon in=20
the list ( i=3D0) then there is no parent and NULL is passed as the =
parent=20
informing our "AddPolygon" function not to try and add it to the end of =
another=20
polygon.We also make a backup of the pointer returned when creating the =
first=20
polygon because this is the root polygon in the list so this is the =
pointer our=20
loading function will return.This is also the pointer we will feed into =
our=20
'BuildBSPTree function'<BR><BR>Now, I might be starting to sound like a=20
scratched record here but I am not going to describe the 'AddPolygon' =
function=20
in any detail here because it is nearly identical to the 'AddPolygon' =
function=20
in Part one of this tutorial where we described in detail how to break =
an n=20
sided convex polygon into a indexed triangle list.I am not going to go =
over all=20
that again here so instead I will just show you the code so you can see =
any=20
differences.<BR><BR><CODE>POLYGON * AddPolygon(POLYGON* =
Parent,D3DLVERTEX=20
*Vertices,WORD NOV)<BR>{<BR>int loop;<BR>POLYGON * Child=3Dnew=20
POLYGON;<BR>Child-&gt;NumberOfVertices=3DNOV;<BR>Child-&gt;NumberOfIndice=
s=3D(NOV-2)*3;<BR>Child-&gt;Next=3DNULL;<BR>Child-&gt;BeenUsedAsSplitter=3D=
false;<BR>//=20
Reserve space for Vertex and Index Lists<BR>Child-&gt;VertexList =3Dnew =
D3DLVERTEX=20
[Child-&gt;NumberOfVertices];<BR>Child-&gt;Indices =3Dnew WORD=20
[Child-&gt;NumberOfIndices]; <BR><BR>for=20
(loop=3D0;loop&lt;NOV;loop++)<BR>{<BR>Child-&gt;VertexList[loop]=3DVertic=
es[loop];<BR>}<BR><BR>//calculate=20
indices<BR>WORD v0,v1,v2;<BR>for=20
(loop=3D0;loop&lt;Child-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>=
v1=3Dv2;<BR>v2++;<BR>}<BR><BR>Child-&gt;Indices[loop*3]=3Dv0;<BR>Child-&g=
t;Indices[(loop*3)+1]=3Dv1;<BR>Child-&gt;Indices[(loop*3)+2]=3Dv2;<BR>}<B=
R><BR>//=20
generate polygon normal<BR>D3DXVECTOR3 * vec0=3D(D3DXVECTOR3 *)=20
&amp;Child-&gt;VertexList[0];<BR>D3DXVECTOR3 * vec1=3D(D3DXVECTOR3 *)=20
&amp;Child-&gt;VertexList[1];<BR>D3DXVECTOR3 * vec2=3D(D3DXVECTOR3 *)=20
&amp;Child-&gt;VertexList[Child-&gt;NumberOfVertices-1];// the last=20
vert<BR><BR>D3DXVECTOR3 edge1=3D(*vec1)-(*vec0);<BR>D3DXVECTOR3=20
edge2=3D(*vec2)-(*vec0);<BR>D3DCVec3Cross(&amp;Child-&gt;Normal,&amp;edge=
1,&amp;edge2)=20
// child-&gt;normal=3DCrossProduct of edge1/edge2=20
<BR>D3DXVec3Normalize(&amp;Child-&gt;Normal,&amp;Child-&gt;Normal);// =
and then=20
Normalize<BR><BR>if=20
(Parent!=3DNULL)<BR>{<BR>Parent-&gt;Next=3DChild;<BR>}<BR><BR>return=20
Child;<BR>}<BR><BR></CODE>If you have read the previous tutorial (and I =
really=20
hope you have) then this code will be instantly familiar to you. The =
only=20
difference here is that I now dynamically allocate the memory for both =
the=20
Vertex and Index lists. Like I said before this code was explained in =
detail in=20
Part 1 of this tutorial.<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite><U>API Notice for =
DX8/D3DX</U>:<BR>For=20
      those of you not familiar with the D3DX functions that have now =
become=20
      almost an integral part if DX8 (replacing most of the framework) =
some of=20
      the above function may be a little strange to you.I have used them =

      throughout this tutorial to calulate the CrossProduct,DotProduct =
and for=20
      Normalizing Vectors.The functions to do this are as=20
      =
follows:-<BR><BR>CrossProduct(v1,v2)=3D<EM>D3DXVec3Cross(&amp;result,&amp=
;v1,&amp;v2);</EM><BR><BR>DotProduct(v1,v2)=3D<EM>D3DXVec3Dot(&amp;v1,&am=
p;v2);<BR><BR></EM>Normalize(v1)=3D<EM>D3DXVec3Normalize(&amp;result,&amp=
;v1);<BR><BR></EM></FONT></TD></TR></TBODY></TABLE><BR><BR>So=20
taking another look at a snippet of code from the 'InitPolygons' =
function again=20
we can see that at this point we have now allocated the memory for the =
arrays=20
(100 elements each for the moment) and have now loaded in the geometry =
such that=20
every polygon in the scene is now stored in a linked list (all pointing =
to next=20
one in the list via the 'Next' pointer).Here is a reminder once again of =
exactly=20
where we are in terms of program execution. You can see below that when =
we call=20
the 'LoadMWM' function the root (first polygon) of the linked list is =
returned=20
and stored in the global POLYGON * PolygonList.This is the list that we =
will now=20
pass into our Build BSP Compiler.<BR><BR><CODE>void=20
InitPolygons(void)<BR>{<BR><FONT=20
color=3Dgreen>ReserveInitialMemoryForArrays();<BR><BR>PolygonList=3DNULL;=
<BR>PolygonList=3DLoadMWM("demolevel.mwm");<BR></FONT>LoadTextures();<BR>=
<BR>BuildBspTree(0,PolygonList);<BR>...<BR>...<BR>...<BR>}<BR><BR></CODE>=
You=20
can see that the next line of code to be executed is called LoadTextures =
and=20
there are no prizes for guessing what this function does. We have a =
global array=20
of Direct3DTexture8 surface pointers defined like=20
so:-<BR><BR><CODE>LPDIRECT3DTEXTURE8 =
lpTextureSurface[25];</CODE><BR><BR>Now you=20
may remember that each polygon also had a texture index.In my demo this =
index=20
will be between 0-24 because there are 25 textures in the =
level.Therefore if a=20
polygon has a texture index of 5 then we know that before we render that =
polygon=20
we must set lpTextureSurface[5] as the current texture in stage 0. =
<BR>We use=20
the 'D3DXCreateTextureFromFileA' function which is one of the new and =
very=20
exciting ways that directx has been made easier to use.This single call =
will=20
load an image (bmp,png,jpg,tga and many more formats supported), create =
a=20
texture in the closest match to the image format or peform color =
conversion if=20
needed, and will automatically create a MipMap chain of textures and =
resample to=20
image to each MipMap level.The function returns a pointer to a texture =
all ready=20
to be rendered with the MipMap chain created for you. COOL. . Here is =
the=20
function that loads the textures into the array.<BR><BR><CODE><FONT =
size=3D2>void=20
LoadTextures(void)<BR>{<BR>D3DXCreateTextureFromFileA(lpDevice,"checkered=
_floor1.jpg",&amp;lpTextureSurface[0]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"brick2.jpg", =
&amp;lpTextureSurface[1]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"metalrustyfloor1.jpg",&amp;lpTex=
tureSurface[2]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"brick3.jpg", =
&amp;lpTextureSurface[3]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"curvyfloor.jpg",=20
&amp;lpTextureSurface[4]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"doomfloor.jpg",=20
&amp;lpTextureSurface[5]); =
<BR>D3DXCreateTextureFromFileA(lpDevice,"crate.jpg",=20
&amp;lpTextureSurface[6]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"stones1.jpg",=20
&amp;lpTextureSurface[7]); =
<BR>D3DXCreateTextureFromFileA(lpDevice,"wood1.jpg",=20
&amp;lpTextureSurface[8]); =
<BR>D3DXCreateTextureFromFileA(lpDevice,"wood2.jpg",=20
&amp;lpTextureSurface[9]); =
<BR>D3DXCreateTextureFromFileA(lpDevice,"celtic.jpg",=20
&amp;lpTextureSurface[10]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"celtic1.jpg",=20
&amp;lpTextureSurface[11]); =
<BR>D3DXCreateTextureFromFileA(lpDevice,"rock1.jpg",=20
&amp;lpTextureSurface[12]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"oldmetalriveted.jpg",=20
&amp;lpTextureSurface[13]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"stone2.jpg",=20
&amp;lpTextureSurface[14]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"brick1.jpg",=20
&amp;lpTextureSurface[15]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"concrete1.jpg",=20
&amp;lpTextureSurface[16]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"brickz2.jpg",=20
&amp;lpTextureSurface[17]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"construct2.jpg",=20
&amp;lpTextureSurface[18]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"construct2c.jpg",=20
&amp;lpTextureSurface[19]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"doomgrey1.jpg",=20
&amp;lpTextureSurface[20]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"doomgrey2.jpg",=20
&amp;lpTextureSurface[21]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"granitefloor.jpg",=20
&amp;lpTextureSurface[22]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"stained_glass1.jpg",=20
&amp;lpTextureSurface[23]);=20
<BR>D3DXCreateTextureFromFileA(lpDevice,"stained_glass2.jpg",=20
&amp;lpTextureSurface[24]); <BR>}</FONT><BR><BR></CODE>Now, we have =
everything=20
set up.Textures Loaded,memory allocated for the initial arrays and a =
POLYGON *=20
(PolygonList) that points to the root of a linked polygon list of every =
polygon=20
in our level.<BR><BR>
<TABLE>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><FONT color=3Dwhite>I would just like to say =
something here=20
      that may be confusing you.We have a linked list of POLYGON =
structures and=20
      we also have an Array of 100 POLYGON structures.At the moment the =
array is=20
      totally blank. When our BSP compiler finds a convex leaf as its =
front list=20
      it will copy those polygons into the PolygonArray (resizing the =
array if=20
      needed) and will then delete the original polygons from the linked =
list to=20
      free up their memory because they are no longer needed. You can =
think of=20
      the Linked list as the unsorted data and as our BSP compiler finds =
the=20
      polygon that make up convex leafs they will be removed from the =
list and=20
      copied over to the PolygonArray ordered by the leaf they are in. =
In other=20
      words we never have two duplicate sets of polygons in memory at =
the same=20
      time.Polygons are added to the Array as they are removed from the =
linked=20
      list.</FONT></TD></TR></TBODY></TABLE><BR><BR>OK then looking at =
our=20
'InitPolygons' function again we can see that the next function call is =
to the=20
main BSP Compiler itself 'BuildBSPTree' (AT LAST) .When this function =
returns=20
the tree will be completely built and stored in the Plane,Node,Leaf and =
Polygon=20
Arrays. These four arrays will completely describe the tree which also =
means if=20
we wanted to save the tree to disk (more on this later) all we would =
have to do=20
is write these four arrays straight to a file. How easy is that ? =
Basically just=20
four writes to save and four reads to load. Now that is much nicer than =
the=20
Linked List BSP tree isnt it?<BR><BR>Lets Code that compiler.<BR><BR><U>
<CENTER><STRONG><FONT color=3Dgreen size=3D5>The 'BuildBSPTree Function' =
: The Heart=20
of the Compiler </FONT></STRONG></CENTER><BR><BR></U>The line that calls =
this=20
function initially with the root node is in the InitPolygons function =
and looks=20
like =
this:-<BR><BR><CODE>BuildBspTree(0,PolygonList);<BR></CODE><BR><BR>This=20
line calls the function passing in zero as the current node and also =
passes in=20
the complete linked list of polygons. Node 0 is obviously the first node =
in the=20
array that we have to find a split plane for so this is why we pass in =
zero.This=20
function will ofcourse recursively call itself passing in the Current =
Node as=20
the Node parameter similiar to what we did in the last tutorial. =
Remember that=20
at the moment our Node array is completely empty so we wish to start by =
filling=20
out Node 0. <BR><BR>We will now look at the BuildBSP function a few =
lines at a=20
time.<BR><BR><CODE>void BuildBspTree(long Node,POLYGON *=20
PolyList)<BR>{<BR>POLYGON *polyTest=3DNULL;<BR>POLYGON =
*FrontList=3DNULL;<BR>POLYGON=20
*BackList=3DNULL;<BR>POLYGON *NextPolygon=3DNULL;<BR>POLYGON=20
*FrontSplit=3DNULL;<BR>POLYGON *BackSplit=3DNULL;<BR>D3DXVECTOR3=20
vec1,vec2;<BR>D3DXVECTOR3 a,b;<BR>float result;<BR><BR><FONT=20
color=3Dred>NodeArray[Node].Plane=3DSelectBestSplitter(PolyList);</FONT><=
BR><BR>polyTest=3DPolyList;<BR>//=20
set up dummy bounding boxes for the node so it can be=20
altered<BR><BR>NodeArray[Node].BoundingBox.BoxMax=3DD3DXVECTOR3(-40000,-4=
0000,-40000);<BR>NodeArray[Node].BoundingBox.BoxMin=3DD3DXVECTOR3(40000,4=
0000,40000);<BR><BR></CODE>First=20
we set up some local variables to hold the front and back lists etc just =
like in=20
the previous tutorial and then we call the SelectBestSplitter function =
to choose=20
a polygon from the list to use as a split plane.Once again the code to =
this=20
function is nearly identicle to the previous tutorial but we will look =
at it in=20
detail a little later because there are a few differences.They are:-=20
<BR><BR>1.)The function does not return a polygon but instead creates a =
Plane=20
from the choosen polygon and stores it in the master PlaneArray.This =
means the=20
first time this function is called NumberOfPlanes=3D0, so the function =
stores the=20
plane in PlaneArray[0] and increments the NumberOfPlanes =
variable.<BR><BR>2.)=20
The Polygon that was used to Create the Planes is Marked as having been =
used as=20
a split plane.In other words its BeenUsedAsSplitter variable is set to =
true.This=20
means this polygon (or any child polygons that result from splits of =
this=20
polygon) can not be used as a splitter again.<BR><BR>3.)The =
'SelectBestSplitter'=20
function does not return the Plane itself because this has already been =
stored=20
in the PlaneArray (by the 'SelectBestSplitter' function) BUT instead =
returns the=20
index of the Plane in the Plane Array.This is a word value that we can =
store in=20
the Current Nodes 'Plane' value. In other words the Plane USED by =
Node[5] (fifth=20
node in the Node array) could be accessed using:-<BR><BR>
<CENTER><STRONG>PlaneArray[NodeArray[5].Plane]</STRONG></CENTER><BR><BR>I=
f this=20
confuses you refer back to the Memory Allocation diagram we saw=20
earlier.<BR><BR>Next we make a backup of the Pointer to the List (=20
'polyTest=3DPolyList') so that we can manipulate the pointer without =
losing the=20
Linked Lists Root address and then we do something that will look very =
strange=20
to you probably.<BR>As described earlier each Node has a Bounding Box =
which is=20
large enough to contain all the Polygons (in all the leafs) in its Font =
and Back=20
tree.In other words then, we can create this bounding box by simply =
doing a Min=20
/ Max test on every vertex of every polygon in the current Nodes front =
and back=20
lists.Now I know we have not created the front and back lists yet but =
all these=20
two lines do is set the Bounding Box for the current Node to impossible=20
values.This means when we create the Bounding Boxes later some vertices =
will=20
definitely by higher than our BoxMax vector and some polygons will =
definitely be=20
smaller than our BoxMin vector which have been set initially very low =
and very=20
high respectively. As a matter of interest the BoundingBox structure is =
much as=20
you would expect.:-<BR><BR>struct BOUNDINGBOX<BR>{ <BR>D3DXVECTOR3=20
BoxMin;<BR>D3DXVECTOR3 BoxMax;<BR>};<BR><BR>This is pretty much as you =
would=20
expect.Just a means to hold a MIN x,y,z points and MAX x,y,z points for =
the=20
current Bounding Box.<BR><BR>Next up we enter the main compiler =
loop.This loop=20
will iterate through each polygon in the passed in list (including the =
polygon=20
which has been used to create a split plane) and classify it against the =
split=20
plane. Just as we did in the previous tutorial we assign the polygons to =
either=20
being in the Front List or the Back List of this Node.If the Polygon is =
Spanning=20
the Split Plane we split the polygon into two and attach the front bit =
to the=20
Nodes Front list and the Back bit to the Nodes Back List.Remember that =
when a=20
Polygon Gets split now the two child splits will inherit the state of =
the parent=20
polygons BeenUsedAsSplitter Flag. <BR>Another difference in the =
following code=20
from the code in the previous tutorial is what happens when a polygon is =
on the=20
split plane. You may remember that in the NODE BSP tree from 'Part 1' we =
always=20
sent on plane polygons down the front list so we hard coded our =
'ClassifyPoly'=20
function to return CP_FRONT even if it was on the plane.We can not do =
this any=20
longer so we will have to make a slight alteration to our ClassifyPoly =
function=20
so that it returns CP_ONPLANE.We have also had to alter it to handle our =
new=20
Array based approach but this is all trivial stuff. We will look at this =
code=20
after we have finished looking at the 'BuildBSPTree' code but just bear =
in mind=20
while looking at the code to this function that it can now return =
CP_ONPLANE as=20
well now.<BR><BR>Ok then lets get back to the main loop of thr compiler =
now=20
where we classify each polygon in the List (the list that is sent into =
the=20
function) against the clip plane, we will look at each 'case' at a=20
time:-<BR><BR><CODE>while (polyTest!=3DNULL=20
)<BR>{<BR>NextPolygon=3DpolyTest-&gt;Next;// remember because =
polytest-&gt;Next=20
will be altered<BR><BR><FONT color=3Dred>switch=20
(ClassifyPoly(&amp;PlaneArray[NodeArray[Node].Plane],polyTest))<BR></FONT=
>{<BR><FONT=20
color=3Dblue>case=20
CP_ONPLANE:</FONT><BR>a=3DPlaneArray[NodeArray[Node].Plane].Normal;<BR>b=3D=
polyTest-&gt;Normal;=20
<BR>result=3D(float)fabs ((a.x-b.x)+(a.y-b.y)+(a.z-b.z));<BR>if=20
(result&lt;0.1)<BR>{ =
<BR>polyTest-&gt;Next=3DFrontList;<BR>FrontList=3DpolyTest;=20
<BR>}<BR><BR>else<BR><BR>{<BR>polyTest-&gt;Next=3DBackList;<BR>BackList=3D=
polyTest;=20
<BR>}<BR><FONT color=3Dblue>break;<BR></CODE></FONT>First we initiate a =
'while'=20
loop that will continue on through the linked list of polygons until =
there are=20
no more left.This loop will be the what takes all the polygons passed =
into the=20
function and will group them in two Linked lists (FrontLists &amp; =
BackLists)=20
depending on their relation to the split plane.In other words when this =
loop=20
exits we will have two more linked lists Front and Back containing the =
polygons=20
that lay in that sub space. Then we make a backup copy of the Current =
Polygons=20
'Next' pointer.This is because the current polygon will be added to =
either the=20
Front or Back list using its next pointer whichl means we will loose any =
way of=20
accessing the next polygon in the initial linked list.This is no =
different from=20
what we did in the first tutorial.<BR>Next we classify this Polygon =
against the=20
Plane of the current Node.Look at how the Plane is accessed from the =
master=20
PlaneArray.Remember that 'Node.Plane' is an index into the Plane =
Array.Make sure=20
you really understand this before you read on. Just remember that=20
NodeArray[Node].Plane returns the Plane index of node [<EM>Node</EM>] in =
the=20
master Node Array.<BR><BR>The first case we cover here is the one we did =
not=20
need to deal with in the previous tutorial.When a polygon is on the same =
Plane=20
as the splitter the polygon must be added to the front list IF the =
Polygon=20
Normal is facing the same way as the Split Plane Normal or added to the =
Back=20
list if they face opposing directions.In other words "if=20
Polygon.Normal=3DSplitPlane.Normal then FrontList else Back list". =
Unfortunately=20
we can not use simple logic like this because of the little inaccuracies =
that=20
pop up when dealing with floating point numbers.In other words the two =
normals=20
should be the same but may be different by a very VERY small amount =
which would=20
still make the '=3D=3D' comparison test fail. So instead we have to do a =
Fuzzy=20
Compare'. Above I subtract each component of vector 2 from vector 1 and =
add them=20
together and then take the absolute value.If the vectors are facing the =
same way=20
then the value should be APPROX zero (with tolerance for floating point =
error).=20
As an example of this working look below. Imagine two Vectors both =
facing the=20
same way (0,1,0) gets result1 and then two vectors pointing different =
ways=20
(1,0,0) &amp; (-1,0,0) gets result2 . =
<BR><BR>result1=3D(0-0)+(1-1)+(0-0)=3D0 ;=20
abs(0)=3D0;<BR>result2=3D(-1-1)+(0-0)+(0-0)=3D-2; abs(-2)=3D2; =
<BR><BR>NOTE: 'fabs' is a=20
special version of the abs function for dealing with floats that ships =
with your=20
compiler.<BR><BR>As you can see in the above code we add the Polygon to =
the=20
front or back list depending on whether or not the Fuzzy compare results =
in=20
'nearly' zero or not. As you can see to add the current polygon to =
either the=20
front or back list we set its 'Next' Pointer to point at the Root of the =
List=20
and then set the Old pointer to the Root of the List (FrontList or =
BackList) to=20
point at the current polygon so that it is now the Root of the =
list.Polygons get=20
pushed down the list every time a new polygon is added to the top. This =
is=20
exactly why we had to back up this polygons next pointer before we =
removed it=20
from the master list.We have now altered its Next Pointer to point at =
the front=20
list of polygons which means next time through the while loop we would =
have lost=20
anyway of accessing the Next polygon in the original master =
list.<BR><BR>Next up=20
we can look at the Next two 'cases' together as they are so small.If the =
current=20
polygon is to the front of the current Nodes Split Plane then we add it =
to the=20
Front List just as above.If if it is to the back of the Split Plane then =
we add=20
it to the Back List ,once again using the same code we used=20
above.<BR><BR><CODE><FONT color=3Dblue>case=20
CP_FRONT:<BR></FONT>polyTest-&gt;Next=3DFrontList;<BR>FrontList=3DpolyTes=
t;=20
<BR>break;<BR><BR><FONT color=3Dblue>case=20
CP_BACK:<BR></FONT>polyTest-&gt;Next=3DBackList;<BR>BackList=3DpolyTest; =

<BR>break;<BR><BR></CODE>Nothing to really talk about there then. The =
last=20
'case' we need to consider is if the current Polygon is Spanning the =
Current=20
Nodes Split Plane.In this case we have to split this polygon in two and =
attach=20
the Front half to the Front List and the back half to the back list. =
Once again,=20
if you have read the previous tutorial then all this will be instantly =
familiar=20
to you as the code is very similiar. Below shows the code for the last =
'case' as=20
well as the tail end of the main 'while' loop.<BR><BR><CODE><FONT=20
color=3Dblue>case CP_SPANNING:</FONT><BR>FrontSplit=3Dnew =
POLYGON;<BR>BackSplit=3Dnew=20
POLYGON;<BR>ZeroMemory(FrontSplit,sizeof(POLYGON));<BR>ZeroMemory(BackSpl=
it,sizeof(POLYGON));<BR>SplitPolygon(polyTest,&amp;PlaneArray[NodeArray[N=
ode].Plane],FrontSplit,BackSplit);<BR><FONT=20
color=3Dgreen>FrontSplit-&gt;BeenUsedAsSplitter=3DpolyTest-&gt;BeenUsedAs=
Splitter;<BR>BackSplit-&gt;BeenUsedAsSplitter=3DpolyTest-&gt;BeenUsedAsSp=
litter;<BR>FrontSplit-&gt;TextureIndex=3DpolyTest-&gt;TextureIndex;<BR>Ba=
ckSplit-&gt;TextureIndex=3DpolyTest-&gt;TextureIndex;<BR></FONT><BR>Delet=
ePolygon=20
(polyTest);<BR><BR>FrontSplit-&gt;Next=3DFrontList;<BR>FrontList=3DFrontS=
plit;<BR>BackSplit-&gt;Next=3DBackList;<BR>BackList=3DBackSplit;<BR>break=
;<BR>default:<BR>break;<BR>}=20
//switch<BR>polyTest=3DNextPolygon;<BR>}// end while =
loop<BR><BR></CODE>I have=20
highlighted bits that are new from the last tutorial.The SplitPolygon =
function=20
is virtually the same so although I will show you the code later I will =
not talk=20
about it in depth as I did this in painstaking detail in the previous=20
tutorial.So whats happening? We create two new polygons FrontSplit and=20
BackSplit.We then call SplitPolygon to split the polygon by the current =
Nodes=20
Split plane.The two splits will be returned in FrontSplit and BackSplit. =
The=20
next bit is VERY IMPORTANT. Before we delete the parent polygon (because =
we no=20
longer need it) we copy over the state of its 'BeenUsedAsSplitter' =
variable to=20
its children.This means that if the polygon that has just been split has =
itself=20
been used as a split plane in the past, then we dont want to divide the =
world by=20
the same Split plane twice.So we copy it over to the children so they =
can not be=20
selected as splitter again also.Remember that if this polygon has NOT =
been used=20
as a split plane then that state is carried over also, meaning that the =
Child=20
polygons can be used as split planes in the future. We also have to copy =
over=20
into the FrontSplit and BackSplit polygons what texture the parent used =
because=20
obviously they will use the same texture also. Remember from the =
previous=20
tutorial that the split polygon function takes care of recalculating =
each splits=20
new texture coordinates and also takes care of retriangulating (is that =
a word ?=20
:) ) the polygon to still make sure it remains as a triangle =
list.<BR><BR>Once=20
we have copied over the useful information from the original polygon it =
can be=20
deleted from memory because it will no longer be needed.We now have two =
split=20
polygons to take its place. Bear in mind though that these two polygons =
may=20
themselves get split into two further down the tree so these triangles=20
themselves may be replaced by their child splits and so removed from =
memory. We=20
finish up this 'case' by adding the BackSplit to the BackList and the =
FrontSplit=20
to the FrontList as is to be expected.<BR><BR>At the end of each =
iteration of=20
the while loop we move on to the next polygon in the original (master =
list=20
passed into the function).Remember we made a backup of the next polygon =
in the=20
original list before we started messing around with the current polygons =

pointers so we can jump back to where we were in the original list by =
using this=20
pointer.<BR><BR>Ok then where are we now. Well at the moment we have =
chosen a=20
Polygon to use as a split plane and have built two lists front and Back =
and have=20
divided ALL the polygons in the level (including the polygon we used as =
the=20
split plane) into these two lists. Now we did talk about Bounding Boxes =
and for=20
reasons that will become clear later we need to calculate the Bounding =
Box that=20
encompasses all the Polygons in this Nodes front and Back tree as well =
as store=20
a Bounding Box in each Leaf bounding the polygons in that leaf.Well lets =
forget=20
about leafs for now, I did say earlier that you can think of a Node =
Bounding Box=20
as being nothing more than a Box that is large enough to contain ALL the =

polygons in the Front and Back List. This is perfect because we have =
just=20
divided all our polygons into Front and Back lists so we have the =
information at=20
hand.<BR><BR>The Function "CalculateBox" accepts a List of Polygons and =
a=20
Bounding Box as its parameters.The Vertices of every polygon in the list =
are=20
checked against the bounds of the Box and the Box is adjusted in size if =
the=20
needed to fit all vertices inside the box.Obviously the Bounding Box we =
want to=20
pass in is the current Nodes Bounding Box and we also want to pass in =
both the=20
Front and Back Lists.Therefore this function is going to be called once =
passing=20
the Front list in and again passing the Back list in. Both times through =
we=20
still pass in the current nodes Bounding Box as the one to be altered if =
need=20
be.After calling these two functions the box has been adjusted so that =
it is=20
large enough to contain both the polygons in the front and back =
lists.<BR>Before=20
we look at the code you are probably thinking I am a complete nut case =
for=20
calling the 'CalculateBox' twice. Why not just do it at the begining of =
the=20
'BuildBSPTree' function before the Polygons have been divided into front =
and=20
back lists? You would still get the same bounding box for the same =
polygon set=20
but would only have to call the function once. This is true BUT we also =
need to=20
make a backup copy of the Bounding Box after ONLY the Front List =
polygons have=20
been bounded because if it turns out that every polygon in this front =
list has=20
been used as a split plane already then this is a Leaf and the Bounding =
Box for=20
the Leaf will have already been calculated as it is ofcourse the same as =
the=20
Bounding Box for just the Front=20
List.:-<BR><BR><CODE>CalculateBox(&amp;NodeArray[Node].BoundingBox,FrontL=
ist);<BR>BOUNDINGBOX=20
LeafBox=3DNodeArray[Node].BoundingBox;<BR>CalculateBox(&amp;NodeArray[Nod=
e].BoundingBox,BackList);</CODE><BR><BR>You=20
can see we call CalculateBox for the Front List first of all so that =
this Nodes=20
Bounding Box is adjusted so that it is large enough to hold the Front =
List=20
polygons. We then make a backup of the Nodes Bounding Box in this state =
just in=20
case we find out later that this front list is a leaf, in which case we =
will=20
already have the Leafs Bounding Box calculated because basically the =
Leaf is the=20
Front List. Then we call 'CalculateBox' again to adjust this Nodes =
Bounding Box=20
again so that it is also large enough to contain the Back List of =
polygons as=20
well as the Front List.The Nodes Bounding Box now holds the correct =
information=20
and we also have a copy of just the Front List Bounding Box stored in =
'LeafBox'=20
that we can use if we find out that this Front List is a Leaf.We will =
look at=20
the calculate Bounding Box as well as all the other support functions =
used by=20
the BuildBSPTree function in a moment.<BR><BR>So at this point the =
current Node=20
has its Plane and Bounding Box fields correctly filled in and we have =
all this=20
nodes polygons in front and back lists. Now it is time to see if the =
Front list=20
is a Leaf.The test is very simple. We iterate through the Front List =
(it's a=20
linked list remember) and if we find that EVERY polygon in the Front =
List has=20
already been used as a split plane then this is a Leaf. In the following =
code we=20
set a variable 'count' to zero .If this variable is still zero at the =
end of the=20
loop then this front list is a leaf. <BR><BR><CODE>int =
count=3D0;<BR>POLYGON *=20
tempf=3DFrontList;<BR>while (tempf!=3DNULL)<BR>{<BR>if=20
(tempf-&gt;BeenUsedAsSplitter=3D=3Dfalse) =
count++;<BR>tempf=3Dtempf-&gt;Next;<BR>}=20
<BR><BR></CODE>So now it is time to deal with the front and back lists =
and see=20
if we have to create more Nodes and carry on splitting etc.First we =
check if=20
'count=3D=3D0' in which case the current Front List IS a leaf. Remember =
when looking=20
at the following code that both 'NumberOfPolygons' &amp; 'NumberOfLeafs' =
are=20
global variables that keep track thoughout the building of the BSP tree =
how many=20
polygons and leafs have been added to the Polygon and Leaf array =
respectively.=20
Remember also that at start up we allocated enough space for 100 =
elements in=20
each array.Also you can see that the on the first recurse of this code =
both=20
NumberOfPolygons and NumberOfLeafs would be zero. <BR><BR><CODE>if (=20
count=3D=3D0)<BR>{<BR>POLYGON *Iterator=3DFrontList;<BR>POLYGON=20
*Temp;<BR>LeafArray[NumberOfLeafs].StartPolygon=3DNumberOfPolygons;<BR><B=
R>while=20
(Iterator!=3DNULL)<BR>{<BR>PolygonArray[NumberOfPolygons]=3D*Iterator;<BR=
>IncreaseNumberOfPolygons();<BR>Temp=3DIterator;<BR>Iterator=3DIterator-&=
gt;Next;<BR>delete=20
Temp;<BR>}<BR>LeafArray[NumberOfLeafs].EndPolygon=3DNumberOfPolygons;<BR>=
LeafArray[NumberOfLeafs].BoundingBox=3DLeafBox;<BR>NodeArray[Node].Front=3D=
NumberOfLeafs;<BR>NodeArray[Node].IsLeaf=3D1;<BR>IncreaseNumberOfLeafs();=
=20
<BR>}<BR><BR></CODE>OK its time to fill out a new Leaf Element in the =
Leaf=20
Array.Obviously this will be Leaf[0] for the first leaf created.We set =
its=20
StartPolygon value to the current number of polygons added to the =
Polygon=20
Array.This once again will be zero if this is the first leaf because =
polygons=20
are only added to the polygon array once they end up in leafs.Infact =
this is the=20
code that adds them. We then loop through every polygon in the front =
list and=20
copy it into the Polygon Array using =
'PolygonArray[NumberOfPolygons]=3D*Iterator'.=20
Next up we call the function 'IncreaseNumberOfPolygons' which needs =
explaining.=20
This function basically just adds 1 on to the NumberOfPolygons variable =
BUT if=20
'NumberOfPolygons' gets larger than MAXNUMBEROFPOLYGONS (which initially =
starts=20
off at 100 remember) then the Array is resized using realloc. Each of =
the global=20
arrays (PolygonArray,NodeArray,PlaneArray etc) has a corresponding =
function like=20
this.<BR>After we have copied the Polygon Data from the Linked list into =
our=20
master Polygon Array and Incremented the Polygon Count we move on to the =
Next=20
Polygon in the Linked List, removing the Current Polygons because we no =
longer=20
need it. After all Polygons in the front list have been added to the =
polygon=20
array we then store the current value of 'NumberOfPolygons' in the Leaf=20
structures 'EndPolygon'. Start Polygon and End Polygon now describe a =
range in=20
the master Polygon Array where its polygons are stored. Actually =
EndPolygon is=20
never actually rendered but is actually where the Next Leaf will start. =
Remember=20
(for i=3Dstart;i<FONT color=3Dred>&lt;</FONT>end;i++) only polygons from =
'start' to=20
'end-1' rendered. <BR><BR>Now because this is a leaf we also want to =
store the=20
Bounding Box of the leaf so we can perform Frustum Rejection (more on =
this=20
later) at render time.Remember we already have the Bounding Box for the =
Leaf(the=20
Leafs Polygons are just the Front List Polygons) stored in LeafBox so we =
copy=20
this over into the Leaf structure also.<BR><BR>Remember we said above =
that if a=20
Nodes Front List is a Leaf then the Node structures 'Front' index will =
hold an=20
index into the Leaf array instead of pointing at another node.So we copy =
the=20
current index of the leaf being created (NumberOfLeafs) into the 'Front' =
field=20
of the Current Node and also set the Nodes 'IsLeaf' variable to =
1.Setting the=20
Nodes 'IsLeaf' variable to 1 instead of the defualt value of 0, tells us =
when=20
traversing the tree NOT that this node is a leaf BUT that to the front =
of this=20
node is a leaf so we can interpret this Nodes 'Front' variable as an =
index in to=20
the 'Leaf' array and not an index into the 'Node' array as usual. This =
Leaf in=20
the Leaf Array has now been filled in correctly and is pointed to by the =
Current=20
node so finally we Increase the 'NumberOfLeafs ' variable so that the =
next leaf=20
that gets created uses the Next position in the Master Leaf Array. =
Notice how I=20
call the funtion 'IncreaseNumberOfLeafs' which adds 1 to 'NumberOfLeafs' =
and=20
Resizes the Array if needed. <BR><BR>OK so thats what happen if the =
FrontList is=20
a leaf (count=3D0) but if the front list is NOT a leaf (in other words =
there are=20
still some polygons in the list that have not yet been used as splitters =
then we=20
have to make this function call itself passing in a new node that is =
pointed to=20
by the Current Nodes front pointer.<BR><BR><CODE>else=20
<BR>{<BR>NodeArray[Node].IsLeaf=3D0;<BR>NodeArray[Node].Front=3DNumberOfN=
odes+1;<BR>IncreaseNumberOfNodes();<BR>BuildBspTree(NumberOfNodes,FrontLi=
st);<BR>}<BR><BR></CODE>You=20
can see that we set 'IsLeaf' to zero because the Current Nodes 'Front' =
field=20
will not contain the index of a leaf but instead an index of another =
node in the=20
Node Array.So we set this Nodes 'Front' to index the 'Next Node we are =
About to=20
Create(NumberOfNodes+1)' and then increase the NumberOfNodes variable =
which is=20
now holding the index of this new node.Therefore the function calls =
itself=20
passing in the New Node (CurrentNode+1) index in the array and passing =
in the=20
CurrentFront list as the New Nodes PolygonList. Thats the Front List =
dealt=20
with.<BR><BR>Now we have to deal with the Back List.The Back list can =
never be a=20
Leaf because of the way the tree is built so if there is a Back List of =
polygons=20
we create a new Node and attach it to this Nodes back , or if there are =
NO=20
polygons in the back list (BackList=3D=3DNULL) then to the back of this =
Node is=20
Solid Space so simply put a -1 in this Nodes Back Variable.Here is the =
code to=20
handle the back list.<BR><BR><CODE>if=20
(BackList=3D=3DNULL)<BR>{<BR>NodeArray[Node].Back=3D-1;<BR>}<BR>else<BR>{=
<BR>NodeArray[Node].Back=3DNumberOfNodes+1;<BR>IncreaseNumberOfNodes();<B=
R>BuildBspTree(NumberOfNodes,BackList);<BR>}=20
<BR>}// end function<BR><BR></CODE>BuildBSPTree function complete. I =
will now=20
show the function in its entirety so you can view it in its complete =
form and=20
after that we will talk about the 'support' functions that BuildBSPTree=20
uses.<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>BuildBSPTree=20
Function<BR><BR></U></FONT></CENTER><CODE>void BuildBspTree(long =
Node,POLYGON *=20
PolyList)<BR>{<BR>POLYGON *polyTest=3DNULL;<BR>POLYGON =
*FrontList=3DNULL;<BR>POLYGON=20
*BackList=3DNULL;<BR>POLYGON *NextPolygon=3DNULL;<BR>POLYGON=20
*FrontSplit=3DNULL;<BR>POLYGON *BackSplit=3DNULL;<BR>D3DXVECTOR3=20
vec1,vec2;<BR>D3DXVECTOR3 a,b;<BR>float result;<BR><BR><FONT=20
color=3Dred>NodeArray[Node].Plane=3DSelectBestSplitter(PolyList);</FONT><=
BR>polyTest=3DPolyList;<BR>NodeArray[Node].BoundingBox.BoxMax=3DD3DXVECTO=
R3(-40000,-40000,-40000);<BR>NodeArray[Node].BoundingBox.BoxMin=3DD3DXVEC=
TOR3(40000,40000,40000);<BR><BR>while=20
(polyTest!=3DNULL )<BR>{<BR>NextPolygon=3DpolyTest-&gt;Next;// remember =
because=20
polytest-&gt;Next will be altered<BR><BR>switch=20
(ClassifyPoly(&amp;PlaneArray[NodeArray[Node].Plane],polyTest))<BR>{<BR><=
FONT=20
color=3Dblue>case=20
CP_ONPLANE:</FONT><BR>a=3DPlaneArray[NodeArray[Node].Plane].Normal;<BR>b=3D=
polyTest-&gt;Normal;=20
<BR>result=3D(float)fabs ((a.x-b.x)+(a.y-b.y)+(a.z-b.z));<BR>if=20
(result&lt;0.1)<BR>{ =
<BR>polyTest-&gt;Next=3DFrontList;<BR>FrontList=3DpolyTest;=20
<BR>}<BR>else<BR>{<BR>polyTest-&gt;Next=3DBackList;<BR>BackList=3DpolyTes=
t;=20
<BR>}<BR>break;<BR><BR><FONT color=3Dblue>case=20
CP_FRONT:</FONT><BR>polyTest-&gt;Next=3DFrontList;<BR>FrontList=3DpolyTes=
t;=20
<BR>break;<BR><BR><FONT color=3Dblue>case=20
CP_BACK:</FONT><BR>polyTest-&gt;Next=3DBackList;<BR>BackList=3DpolyTest; =

<BR>break;<BR><BR>case CP_SPANNING:<BR>FrontSplit=3Dnew =
POLYGON;<BR>BackSplit=3Dnew=20
POLYGON;<BR>ZeroMemory(FrontSplit,sizeof(POLYGON));<BR>ZeroMemory(BackSpl=
it,sizeof(POLYGON));<BR><FONT=20
color=3Dred>SplitPolygon</FONT>(polyTest,&amp;PlaneArray[NodeArray[Node].=
Plane],FrontSplit,BackSplit);<BR>FrontSplit-&gt;BeenUsedAsSplitter=3Dpoly=
Test-&gt;BeenUsedAsSplitter;<BR>BackSplit-&gt;BeenUsedAsSplitter=3DpolyTe=
st-&gt;BeenUsedAsSplitter;<BR>FrontSplit-&gt;TextureIndex=3DpolyTest-&gt;=
TextureIndex;<BR>BackSplit-&gt;TextureIndex=3DpolyTest-&gt;TextureIndex;<=
BR><BR><FONT=20
color=3Dred>DeletePolygon</FONT>=20
(polyTest);<BR><BR>FrontSplit-&gt;Next=3DFrontList;<BR>FrontList=3DFrontS=
plit;<BR>BackSplit-&gt;Next=3DBackList;<BR>BackList=3DBackSplit;<BR>break=
;<BR>default:<BR>break;<BR><BR>}=20
//switch<BR>polyTest=3DNextPolygon;<BR>}// end while loop<BR><BR>int=20
count=3D0;<BR>POLYGON * tempf=3DFrontList;<BR>while =
(tempf!=3DNULL)<BR>{<BR>if=20
(tempf-&gt;BeenUsedAsSplitter=3D=3Dfalse) =
count++;<BR>tempf=3Dtempf-&gt;Next;<BR>}=20
<BR><BR><FONT=20
color=3Dred>CalculateBox(&amp;NodeArray[Node].BoundingBox,FrontList);</FO=
NT><BR>BOUNDINGBOX=20
LeafBox=3DNodeArray[Node].BoundingBox;<BR><FONT=20
color=3Dred>CalculateBox(&amp;NodeArray[Node].BoundingBox,BackList);</FON=
T><BR><BR>if=20
( count=3D=3D0)<BR>{<BR>POLYGON *Iterator=3DFrontList;<BR>POLYGON=20
*Temp;<BR>LeafArray[NumberOfLeafs].StartPolygon=3DNumberOfPolygons;<BR>wh=
ile=20
(Iterator!=3DNULL)<BR>{<BR>PolygonArray[NumberOfPolygons]=3D*Iterator;<BR=
>IncreaseNumberOfPolygons();<BR>Temp=3DIterator;<BR>Iterator=3DIterator-&=
gt;Next;<BR>delete=20
Temp;<BR>}<BR>LeafArray[NumberOfLeafs].EndPolygon=3DNumberOfPolygons;<BR>=
LeafArray[NumberOfLeafs].BoundingBox=3DLeafBox;<BR>NodeArray[Node].Front=3D=
NumberOfLeafs;<BR>NodeArray[Node].IsLeaf=3D1;<BR><FONT=20
color=3Dred>IncreaseNumberOfLeafs();</FONT> <BR>}<BR>else=20
<BR>{<BR>NodeArray[Node].IsLeaf=3D0;<BR>NodeArray[Node].Front=3DNumberOfN=
odes+1;<BR><FONT=20
color=3Dred>IncreaseNumberOfNodes();</FONT><BR>BuildBspTree(NumberOfNodes=
,FrontList);<BR>}<BR><BR>if=20
(BackList=3D=3DNULL)<BR>{<BR>NodeArray[Node].Back=3D-1;<BR>}<BR>else<BR>{=
<BR>NodeArray[Node].Back=3DNumberOfNodes+1;<BR><FONT=20
color=3Dred>IncreaseNumberOfNodes();</FONT><BR>BuildBspTree(NumberOfNodes=
,BackList);<BR>}=20
<BR><BR>}// end function<BR><BR></CODE>You can see above that I have =
highlighted=20
in Red where support functions have been used.Read the above code and =
make sure=20
you understand how the tree is being built.It does not matter whether or =
not you=20
know how the support functions work we will look at these in a moment =
but make=20
sure you can see above what they are being used for and what they are =
returning=20
to the calling function. <BR><BR>Most of the Support functions above are =

virtually identicle to the Support function used in the previous=20
tutorial.Because they were explained in detail in that tutorial I will =
not=20
explain them in detail again here but will instead just show them and =
point out=20
where they have been changed to support the Solid Leaf Tree and our new =
Array=20
based stratagy.<BR><BR>The the first function call I have highlighted =
above is=20
the call=20
:-<BR><BR><CODE>NodeArray[Node].Plane=3DSelectBestSplitter(PolyList);</CO=
DE><BR><BR>This=20
function is passed the list of polygons and selects the best one to be =
used as=20
the current split plane.The plane is created and added to the master =
PlaneArray=20
and the funtion returns the Index of that plane in the Plane Array so =
that the=20
Node can store it.Here is the SelectBestSplitter Funtion. <BR><BR><U>
<CENTER><FONT color=3Dgreen size=3D4>The 'Select Best Splitter'=20
Function</FONT></CENTER></U><BR><BR>The Job of this function is to find =
the Best=20
Polygon to use as a split plane.As discussed in the previous tutorial =
this=20
completely depends on the Polygon Choosing Heuristic used.In my code I =
have used=20
(frontlist)-(backlist)+(splits*3). This seems to give a nice balance =
between=20
keeping a relatively balanced tree and minimizing Splits as much as =
possible to=20
keep the polygon count down.Although you may not think the Balance of a =
tree is=20
important it is in fact Vitally important.If a tree is unbalanced down =
one side=20
then that side will have a much deeper depth.This could make tree =
traversal in=20
certain areas slow and inconsistant. Perhaps Balance is even more =
important than=20
splits, I do not know I have never really benchmarked it but you do want =
to keep=20
the tree as balanced as possible.Here is the code:- <BR><BR><CODE>long=20
SelectBestSplitter(POLYGON *PolyList)<BR>{<BR>POLYGON*=20
Splitter=3DPolyList;<BR>POLYGON* CurrentPoly=3DNULL;<BR>unsigned long=20
BestScore=3D1000000;<BR>POLYGON * SelectedPoly=3DNULL; <BR><BR>while=20
(Splitter!=3DNULL)<BR>{<BR>if=20
(Splitter-&gt;BeenUsedAsSplitter!=3Dtrue)<BR>{<BR>PLANE=20
SplittersPlane;<BR>SplittersPlane.Normal=3DSplitter-&gt;Normal;<BR>Splitt=
ersPlane.PointOnPlane=3D*(D3DXVECTOR3=20
*)&amp;Splitter-&gt;VertexList[0];<BR>CurrentPoly=3DPolyList;<BR>unsigned=
 long=20
score,splits,backfaces,frontfaces;<BR>score=3Dsplits=3Dbackfaces=3Dfrontf=
aces=3D0;<BR><BR>while=20
(CurrentPoly!=3DNULL)<BR>{<BR>int=20
result=3DClassifyPoly(&amp;SplittersPlane,CurrentPoly);<BR>switch (=20
result)<BR>{<BR>case CP_ONPLANE:<BR>break;<BR>case=20
CP_FRONT:<BR>frontfaces++;<BR>break;<BR>case=20
CP_BACK:<BR>backfaces++;<BR>break;<BR>case=20
CP_SPANNING:<BR>splits++;<BR>break;<BR>default:<BR>break;<BR>}//=20
switch<BR><BR>CurrentPoly=3DCurrentPoly-&gt;Next;<BR>}// end while =
current=20
poly<BR><BR>score=3Dabs(frontfaces-backfaces)+(splits*3);<BR>if=20
(score&lt;BestScore)<BR>{<BR>BestScore=3Dscore;<BR>SelectedPoly=3DSplitte=
r;<BR>}<BR><BR>}//=20
end if this splitter has not been used =
yet<BR>Splitter=3DSplitter-&gt;Next;<BR>}//=20
end while splitter !=3D null=20
<BR><BR>SelectedPoly-&gt;BeenUsedAsSplitter=3Dtrue;<BR>PlaneArray[NumberO=
fPlanes].PointOnPlane=3D*((D3DXVECTOR3=20
*)&amp;SelectedPoly-&gt;VertexList[0]);<BR>PlaneArray[NumberOfPlanes].Nor=
mal=3DSelectedPoly-&gt;Normal;<BR>IncreaseNumberOfPlanes();<BR>return=20
(NumberOfPlanes-1);<BR>} // End Function<BR><BR></CODE>You should =
recognize most=20
of this stuff from the previous tutorial but there are some differences =
so I=20
will summerize.<BR>We loop through every polygon in the list and test it =
(as a=20
split plane) against every other polygon in the list.We do not want to =
select=20
any polygons we have already used as a split plane in the past so we =
have to=20
check the Polygons BeenUsedAsSplitter variable to see if we want to test =
this=20
Polygon as a split plane.We also make sure we are not testing this =
polygons=20
against itself. Just as before we use each polygon as a split plane and =
keep a=20
score based on how many splits it caused and how balanced the front and =
back=20
polygon sets would be. It is worth noting that the LOWEST score is best =
so every=20
time we find a new Lowest score we store a pointer to that polygon so =
come the=20
end of the while loops 'SelectedPoly' points to the Polygon that we will =

actually use to create a split plane from.<BR><BR>Once we have decided =
that this=20
is the polygon we are going to use the first thing we do is set that =
polygons=20
'BeenUsedAsSplitter' variable so that this polygon (or any child splits =
that may=20
occur from this polygon in the future) can never be selected as the =
SplitPlane=20
again.<BR>Next we actually enter the Plane Data into the PlaneArray.If =
with all=20
the Master arrays NumberOfPlanes holds the Next plane to be created.We =
fill out=20
the Plane structure by using the first vertex in the polygon (as the =
point on=20
the plane) and the polygons Normal obviously is the Planes normal also. =
We then=20
call 'IncreaseNumberOfPlanes' to increment the NumberOfPLanes counter so =
that=20
the next time this function is called it will be indexing the Next =
element in=20
the plane array. We end up by returning the Index of the Plane we have =
just=20
created in the plane array so that the return value can be stored in the =
current=20
nodes 'Plane' variable. As I said before this is very similar to the =
function=20
covered in Part 1 of this tutorial series so please read this first as =
it gives=20
much more information about what exactly selecting the Best Splitter=20
means.<BR><BR>The Next support function we call in 'BuildBSPTree' is the =

SplitPolygon function which splits a polygon two seperate polygons. This =

function will not be explained AT ALL in this part of the tutorial =
because the=20
function is mainly the same with just a few alterations to handle =
functions=20
instead of pointers.I give a VERY detailed explanation of splitting =
polygons in=20
Part 1 so read this first and then check out the downloadable source =
code for=20
the small changes I have made. <BR><BR>The next support funtion however =
is new=20
to this tutorial.'CalculateBox' simply takes a list of polygons and a =
box and=20
adjusts the Bounding Box to fit the polygons.The 'CalculateBox' does NOT =

initiate the BoundingBox values before the test .This is by design =
because we=20
have to call this function twice remember once for the Front list and =
once for=20
the Back list. Because the Bounding Box structure passed in is not =
initialized=20
by this function, this is why we initialized it ourselves at the start =
of the=20
'BuildBSPTree' function and set the box's Maximum and Minimum value to=20
impossible values.<BR><BR>The actual code to the function iteslf is very =
simple.=20
Simply loop through every Polygon in the list and every vertex in that =
polygon=20
and check to see if the vertex's X,Y or Z is smaller or larger than the =
Bounding=20
Box current Minimum X,Y or Z or Maximum X,Y and Z respectively.If so =
then make=20
then set this as the new Bounding Box value. Here is the =
code.<BR><BR><CODE>void=20
CalculateBox(BOUNDINGBOX *Box,POLYGON *Polylist)<BR>{<BR>WORD =
i;<BR>POLYGON=20
*PolyPointer=3DPolylist ;<BR>while (PolyPointer!=3DNULL)<BR>{<BR><BR>for =

(i=3D0;i&lt;PolyPointer-&gt;NumberOfVertices;i++)<BR>{<BR>// check =
Minimum=20
Bounds<BR>if (PolyPointer-&gt;VertexList[i].x&lt;Box-&gt;BoxMin.x)=20
Box-&gt;BoxMin.x=3DPolyPointer-&gt;VertexList[i].x;<BR>if=20
(PolyPointer-&gt;VertexList[i].y&lt;Box-&gt;BoxMin.y)=20
Box-&gt;BoxMin.y=3DPolyPointer-&gt;VertexList[i].y;<BR>if=20
(PolyPointer-&gt;VertexList[i].z&lt;Box-&gt;BoxMin.z)=20
Box-&gt;BoxMin.z=3DPolyPointer-&gt;VertexList[i].z;<BR><BR>// check =
Maximum=20
Bounds<BR>if (PolyPointer-&gt;VertexList[i].x&gt;Box-&gt;BoxMax.x)=20
Box-&gt;BoxMax.x=3DPolyPointer-&gt;VertexList[i].x;<BR>if=20
(PolyPointer-&gt;VertexList[i].y&gt;Box-&gt;BoxMax.y)=20
Box-&gt;BoxMax.y=3DPolyPointer-&gt;VertexList[i].y;<BR>if=20
(PolyPointer-&gt;VertexList[i].z&gt;Box-&gt;BoxMax.z)=20
Box-&gt;BoxMax.z=3DPolyPointer-&gt;VertexList[i].z;=20
<BR>}<BR><BR>PolyPointer=3DPolyPointer-&gt;Next;<BR>}<BR>}<BR><BR></CODE>=
Another=20
support function used by the BuildBSPTree function is one called =
'DeletePolygon'=20
and this function can be found in 'memoryalloc.cpp'.We call this =
function=20
whenever we want to remove a polygon from memory.Remember that calling =
the c++=20
'delete' command will remove the memory allocated by the Polygon =
structure=20
itself BUT will not remove the memory allocated dynamically for the =
Vertex and=20
Index arrays that are pointed to by the polygon structure.This would =
cause a=20
memory leak.In short then we have to delete the Index and Vertex List =
memory=20
first (while we still have pointers to the memory) and then delete the =
Polygon=20
structure. Here is the DeletePolygon function.<BR><BR><CODE>void =
DeletePolygon=20
(POLYGON *Poly)<BR>{<BR>delete Poly-&gt;VertexList;<BR>delete=20
Poly-&gt;Indices;<BR>delete Poly;<BR>}<BR><BR></CODE>Another thing that =
can look=20
quite confusing is the fact that when we copy over the FrontList =
polygons over=20
into a new Leaf (if count=3D=3D0) we do infact call the c++ command =
'delete' instead=20
of our function 'DeletePolygons'.This is because although we no longer =
need the=20
polygon structure (the one in the front list) itself any more the memory =
for the=20
Vertex Array and the Index Array will still be pointed at by the polygon =

structure in the PolygonArray.There for we do not want the vertex or =
index=20
memory released. <BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D4>IncreaseNumberOf....?=20
</FONT></U></CENTER><BR>We have just one more function to look at before =
we have=20
finished looking at the actual compiler itself. Every time we increased =
the=20
current number of Polygons,Planes,Nodes or Leafs etc, instead of just =
using=20
"NumberOfLeafs++" we called 'IncreaseNumberOfLeafs'.There is one of =
these=20
functions for EACH master Array (Planes,Nodes,leafs etc) and for the =
most part=20
all they do is Increment the count like "NumberOfLeafs++", however if =
this takes=20
the total number of leafs over the current size of the array then the =
Array is=20
resized by calling 'realloc' to add another 100 elements to the array in =

question. All these functions are stored in 'memoryalloc.cpp' but they =
are all=20
exactly the same as each other really except for the fact that each one =
deals=20
with a specific array.Because of this we will only have a look at the =
code for=20
the 'IncreaseNumberOfNodes' function below but just remember that all =
the other=20
'IncreaseNumberOf...' functions are nearly exactly the same. =
<BR><BR><CODE>void=20
IncreaseNumberOfNodes(void)<BR>{<BR>NumberOfNodes++;<BR>if=20
(NumberOfNodes=3D=3DMAXNUMBEROFNODES)<BR>{<BR>MAXNUMBEROFNODES+=3D100;<BR=
>NodeArray=3D(NODE=20
*)realloc (NodeArray,MAXNUMBEROFNODES *=20
sizeof(NODE));<BR>}<BR>}<BR><BR></CODE>You can see that we increase=20
NumberOfNodes variable and also check if this takes the number of nodes =
past the=20
current size of the array.If so we add 100 to the size of the array and =
resize=20
the memory block calling the C function 'realloc'. <BR><BR><FONT =
color=3Dred>
<CENTER><U><FONT size=3D4>'ClassifyPolygon changes from Part=20
I'</FONT></U></CENTER></FONT><BR><BR>Before we move on I would just like =
to say=20
that the 'ClassifyPoly' routine used in the above functions has had to =
be=20
altered slightly from the previous tutorial as mentioned earlier. In the =
last=20
tutorial we hard coded our 'ClassifyPoly' function to return CP_FRONT =
even if=20
the polygon lay on the test plane.This was because we did not need the=20
CP_ONPLANE case in the Node compiler so it stopped us having to =
duplicate code=20
in the switch statement in the BuildBSP function.The new version also =
returns=20
CP_ONPLANE and is listed below with the altered line highlighted. Note =
that the=20
ClassifyPoint function is unchanged (except that it now uses d3dx math =
functions=20
for computing Dotproduct) and that both 'ClassifyPoint' and =
'ClassifyPoly' are=20
described in detail in Part 1.<BR><BR><CODE>int ClassifyPoly(PLANE=20
*Plane,POLYGON * Poly)<BR>{<BR>int Infront=3D0;<BR>int =
Behind=3D0;<BR>int=20
OnPlane=3D0;<BR>float result;<BR>D3DXVECTOR3 *vec1=3D(D3DXVECTOR3=20
*)&amp;Plane-&gt;PointOnPlane;<BR>for (int=20
a=3D0;a&lt;Poly-&gt;NumberOfVertices;a++)<BR>{<BR>D3DXVECTOR3 =
*vec2=3D(D3DXVECTOR3=20
*)&amp;Poly-&gt;VertexList[a];<BR>D3DXVECTOR3=20
Direction=3D(*vec1)-(*vec2);<BR>result=3DD3DXVec3Dot(Direction,Plane-&gt;=
Normal);<BR><BR>if=20
(result&gt;0.001)<BR>{<BR>Behind++;<BR>}<BR>else<BR>if=20
(result&lt;-0.001)<BR>{<BR>Infront++;<BR>}<BR>else<BR>{<BR>OnPlane++;<BR>=
Infront++;<BR>Behind++;<BR>}<BR>}<BR><BR><FONT=20
color=3Dred>if (OnPlane=3D=3DPoly-&gt;NumberOfVertices) return=20
CP_ONPLANE;</FONT><BR>if (Behind=3D=3DPoly-&gt;NumberOfVertices) return=20
CP_BACK;<BR>if (Infront=3D=3DPoly-&gt;NumberOfVertices) return =
CP_FRONT;<BR>return=20
CP_SPANNING;<BR>}<BR><BR></CODE>The last function in the BuildBSPTree =
function=20
that we have not talked about is the SplitPolygon function.As I said =
earlier=20
there really was a quite large and detailed explanation about this =
function in=20
the Part 1 tutorial so please refer back to this tutorial if you are =
having=20
trouble remembering or if you do not understand the code. For those of =
you that=20
can remember I will just show it here as a refresher and to show whats =
changed=20
(as of writing I have not yet updated Part1 from dx7 to dx8 so here it =
is in its=20
new form using the D3DX functions instead of the D3D Framework from dx7. =
Apart=20
from these changes it is exactly the same).<BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D4>Split=20
Polygon</FONT></U></CENTER><BR><CODE><FONT size=3D2>void =
SplitPolygon(POLYGON=20
*Poly,PLANE *Plane,POLYGON *FrontSplit,POLYGON =
*BackSplit)<BR>{<BR>D3DLVERTEX=20
FrontList[40],BackList[40],FirstVertex;<BR>D3DXVECTOR3=20
PlaneNormal,IntersectPoint,PointOnPlane,PointA,PointB;<BR>WORD=20
FrontCounter=3D0,BackCounter=3D0,loop=3D0,CurrentVertex=3D0;<BR>float =
percent; // used=20
for return storage of percentage<BR><BR>// Find any vertex on the plane =
to use=20
later in plane intersect=20
routine<BR>PointOnPlane=3DPlane-&gt;PointOnPlane;<BR><BR>// first we =
find out if=20
the first vertex belongs in front or back=20
list<BR>FirstVertex=3DPoly-&gt;VertexList[0];<BR><BR>switch =
(ClassifyPoint(=20
(D3DXVECTOR3 *)&amp;FirstVertex,Plane))<BR>{<BR><FONT color=3Dblue>case=20
CP_FRONT:</FONT><BR>FrontList[FrontCounter++]=3DFirstVertex;<BR>break;<BR=
><FONT=20
color=3Dblue>case=20
CP_BACK:</FONT><BR>BackList[BackCounter++]=3DFirstVertex;<BR>break;<BR><F=
ONT=20
color=3Dblue>case=20
CP_ONPLANE</FONT>:<BR>BackList[BackCounter++]=3DFirstVertex;<BR>FrontList=
[FrontCounter++]=3DFirstVertex;<BR>break;<BR>default:<BR>PostQuitMessage(=
0);;<BR>}<BR><BR>for=20
(loop=3D1;loop&lt;Poly-&gt;NumberOfVertices+1;loop++)<BR>{<BR>if=20
(loop=3D=3DPoly-&gt;NumberOfVertices)<BR>{<BR>CurrentVertex=3D0;<BR>}<BR>=
else<BR>{<BR>CurrentVertex=3Dloop;<BR>}<BR>PointA=3D*(D3DXVECTOR3=20
*)&amp;Poly-&gt;VertexList[loop-1];<BR>PointB=3D*(D3DXVECTOR3=20
*)&amp;Poly-&gt;VertexList[CurrentVertex];<BR><BR>PlaneNormal=3DPlane-&gt=
;Normal;<BR><BR>int=20
Result=3DClassifyPoint(&amp;PointB,Plane);<BR>if=20
(Result=3D=3DCP_ONPLANE)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;Verte=
xList[CurrentVertex];<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexList[=
CurrentVertex];<BR>}<BR>else<BR>{<BR>if=20
(Get_Intersect(&amp;PointA,&amp;PointB,&amp;PointOnPlane,&amp;PlaneNormal=
,&amp;IntersectPoint,=20
&amp;percent)=3D=3Dtrue)<BR>{<BR>// create new vertex and calculate new =
texture=20
coordinate<BR>float=20
deltax,deltay,texx,texy;<BR>deltax=3DPoly-&gt;VertexList[CurrentVertex].t=
u-Poly-&gt;VertexList[loop-1].tu;<BR>deltay=3DPoly-&gt;VertexList[Current=
Vertex].tv-Poly-&gt;VertexList[loop-1].tv;<BR>texx=3DPoly-&gt;VertexList[=
loop-1].tu+(deltax*percent);<BR>texy=3DPoly-&gt;VertexList[loop-1].tv+(de=
ltay*percent);<BR>D3DLVERTEX=20
copy;//=3DD3DLVERTEX(IntersectPoint,D3DCOLOR_ARGB(255,255,255,255),0,texx=
,texy);<BR>copy.x=3DIntersectPoint.x;<BR>copy.y=3DIntersectPoint.y;<BR>co=
py.z=3DIntersectPoint.z;<BR>copy.color=3DD3DCOLOR_ARGB(255,255,255,255);<=
BR>copy.specular=3D0;<BR>copy.tu=3Dtexx;<BR>copy.tv=3Dtexy;<BR><BR>if=20
(Result=3D=3DCP_FRONT )<BR>{<BR>BackList[BackCounter++]=3Dcopy;=20
<BR>FrontList[FrontCounter++]=3Dcopy;<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexL=
ist[CurrentVertex];<BR>}<BR>}=20
<BR><BR>if=20
(Result=3D=3DCP_BACK)<BR>{<BR>FrontList[FrontCounter++]=3Dcopy;<BR>BackLi=
st[BackCounter++]=3Dcopy;=20
<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;VertexLis=
t[CurrentVertex];<BR>}<BR>}=20
<BR>}// end get intersect<BR><BR>else<BR><BR>{<BR>if=20
(Result=3D=3DCP_FRONT)<BR>{<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>FrontList[FrontCounter++]=3DPoly-&gt;VertexL=
ist[CurrentVertex];<BR>}<BR>}<BR>if=20
(Result=3D=3DCP_BACK)<BR>{<BR>if=20
(CurrentVertex!=3D0)<BR>{<BR>BackList[BackCounter++]=3DPoly-&gt;VertexLis=
t[CurrentVertex];<BR>}<BR>}<BR>}<BR>}//=20
end for not onplane<BR>}//end for loop<BR><BR>//OK THEN LETS BUILD THESE =
TWO=20
POLYGONAL BAD BOYS :)=20
<BR><BR>FrontSplit-&gt;NumberOfVertices=3D0;<BR>BackSplit-&gt;NumberOfVer=
tices=3D0;<BR>//=20
Reserve Memory for Front and Back Vertex Lists<BR>FrontSplit =
-&gt;VertexList=3D=20
new D3DLVERTEX [FrontCounter];<BR>BackSplit -&gt;VertexList=3D new =
D3DLVERTEX=20
[BackCounter ];<BR><BR>for=20
(loop=3D0;loop&lt;FrontCounter;loop++)<BR>{<BR>FrontSplit-&gt;NumberOfVer=
tices++;<BR>FrontSplit-&gt;VertexList[loop]=3DFrontList[loop];<BR>}<BR>fo=
r=20
(loop=3D0;loop&lt;BackCounter;loop++)<BR>{<BR>BackSplit-&gt;NumberOfVerti=
ces++;<BR>BackSplit-&gt;VertexList[loop]=3DBackList[loop];<BR>}<BR><BR>Ba=
ckSplit-&gt;NumberOfIndices=3D(BackSplit-&gt;NumberOfVertices-2)*3;<BR>Fr=
ontSplit-&gt;NumberOfIndices=3D(FrontSplit-&gt;NumberOfVertices-2)*3;<BR>=
<BR>//=20
Reserve Memory for Front and Back Index Lists<BR>FrontSplit =
-&gt;Indices=3D new=20
WORD [FrontSplit-&gt;NumberOfIndices];<BR>BackSplit -&gt;Indices=3D new =
WORD=20
[BackSplit -&gt;NumberOfIndices]; <BR><BR>// Fill in the Indices<BR>WORD =

v0,v1,v2;<BR>for=20
(loop=3D0;loop&lt;FrontSplit-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if =
(loop=3D=3D0)=20
<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>v1=3Dv2;<BR>v=
2++;<BR>}<BR><BR>FrontSplit-&gt;Indices[loop*3]=3Dv0;<BR>FrontSplit-&gt;I=
ndices[(loop*3)+1]=3Dv1;<BR>FrontSplit-&gt;Indices[(loop*3)+2]=3Dv2;<BR>}=
<BR><BR>for=20
(loop=3D0;loop&lt;BackSplit-&gt;NumberOfIndices/3;loop++)<BR>{<BR>if =
(loop=3D=3D0)=20
<BR>{<BR>v0=3D0;<BR>v1=3D1;<BR>v2=3D2;<BR>}<BR>else<BR>{<BR>v1=3Dv2;<BR>v=
2++;<BR>}<BR><BR>BackSplit-&gt;Indices[loop*3]=3Dv0;<BR>BackSplit-&gt;Ind=
ices[(loop*3)+1]=3Dv1;<BR>BackSplit-&gt;Indices[(loop*3)+2]=3Dv2;<BR>}<BR=
>FrontSplit-&gt;Normal=3DPoly-&gt;Normal;<BR>BackSplit-&gt;Normal=3DPoly-=
&gt;Normal;<BR>}<BR></FONT></CODE><BR><FONT=20
color=3Dgreen size=3D5>
<CENTER><U>We have Compiled Solid Leaf BSP Tree. What=20
Next?</U></CENTER></FONT><BR><BR>We now have Compiled BSP Tree but have =
not yet=20
written any functions to traverse or render the tree.Traversing the Tree =
is=20
exactly as it was before but with one big difference.You may remember =
that with=20
the Solid Node compiler we had Solid or Empty 'Leaf Nodes' attached to =
each tree=20
which contained no polygons but did signify that if we end up in the =
node then=20
we are in solid or empty space. I thought this was a huge waste of =
memory which=20
is why we now use the Node Structures Front and Back variables for dual =
purpose.=20
The Front variable either points to another Node in front of this one or =
IF the=20
Nodes 'IsLeaf variable equals 1 then it is an index into the leaf =
array.This=20
means we have to be checking before we move instead of after we move as =
we did=20
before. In other words, instead of moving down the front tree and saying =
'Is=20
this a Leaf we are currently in' we must check 'Is it a leaf or node?' =
BEFORE we=20
move down. This is the same with the 'Back' variable which is either the =
index=20
of another node (we can go down there then) OR it is set to '-1' which =
is solid=20
space so we can not. If we didnt check before we moved then our renderer =
would=20
try and access NodeArray[-1] when travelling down the back of a Node =
which has=20
no children (is solid space).<BR><BR>Showing you the actual rendering =
function=20
is one of those chicken and egg situations.It uses the PVS set to render =
which=20
we have not created yet although you could ofcourse write a render just =
as we=20
did before which traverses the tree checking every node and either =
rendering=20
behind or in front of it depending on the position of the camera as =
regards to=20
the node. We are NOT going to do that however and this is why I covered =
earlier=20
how the PVS set is stored. If you have forgotten then please refer back =
to=20
remind yourself .It is not important yet to know how the PVS set is =
generated=20
but it is important to understand how the PVS set is stored once it is=20
generated.<BR><BR>Rendering the level works like this. First of all we =
call the=20
RenderTree function passing in as a parameter the position vector of the =
camera=20
(or player etc).This position will then traverse the BSP tree (using the =
methods=20
described above , check first and then moving) until it finds the =
current Leaf=20
the camera is in. After that it calls 'DrawTree' which will draw the =
level using=20
the Current Leafs PVS set.This means we dont traverse the entire level =
as we did=20
before visiting every single node and drawing it but instead just =
traverse the=20
tree until we find the Leaf the camera is in and call DrawTree to draw =
the=20
Polygons that can be seen from that leaf. Below I show the code to the=20
'RenderTree' function that traverses the tree using the "check first and =
then=20
go' method to find the Leaf the camera is in.Once the Leaf is found it =
calls=20
'DrawTree' which we will look at in a moment. Note that I do NOT use =
recursion=20
to traverse the tree in this tutorial but instead perform the traversal =
in a=20
'while' loop. This should give us a bit of a speed advantage because we =
are=20
loosing all that STACK Pushing and Popping and should also get rid of =
any chance=20
of STACK overflow during the rendering of really large levels. It still =
does=20
exactly the same as the recursive functions we used in Part1 but just =
does it in=20
a loop.I will take you through this function a few lines at a time.=20
<BR><BR><CODE>void RenderTree(D3DVECTOR pos)<BR>{<BR>int =
Node=3D0;<BR>int=20
leaf=3D0;<BR></CODE>This function will be called once per frame to =
render the tree=20
and will be passed in the Position of the Camera/Player in the game =
world.. This=20
code finds the LEAF the camera is in and then calls DrawTree to render =
that=20
leaf.We set 'Node' to zero at first obviously because we need to start =
testing=20
our camera position at the root of the tree.<BR>We now enter an infinite =
loop=20
that will only terminate when the Leaf is found that the camera is.The =
function=20
basically just checks the Camera Position against the Current 'Node' and =
then=20
adjusts 'Node' to the new Node/Leaf and loops round again.When a leaf is =
found=20
the leaf is drawn (using 'DrawTree') and this function returns.The level =
will be=20
completely rendered at this point.We will look at each 'case' one at a=20
time.<BR><BR><CODE>while(1)<BR>{<BR>switch(ClassifyPoint(&amp;pos,&amp;Pl=
aneArray[NodeArray[Node].Plane]))<BR>{<BR><FONT=20
color=3Dblue>case CP_FRONT:</FONT> <BR>if=20
(NodeArray[Node].IsLeaf!=3D0)<BR>{<BR>leaf=3DNodeArray[Node].Front;<BR>Dr=
awTree(leaf);<BR>return;<BR>}<BR>else<BR>{<BR>Node=20
=3D NodeArray[Node].Front;<BR>}<BR>break;<BR><BR></CODE>If the camera =
position is=20
infront of this 'Node' then we need to travel down this Nodes front tree =
to=20
further refine the search.HOWEVER, the Front of this tree may not point =
to=20
another Node and may in fact be the Leaf we are looking for so we check =
the=20
Nodes 'IsLeaf' variable to see of this is the case.If 'IsLeaf!=3D0' then =
we are at=20
the end branch of this tree and this Nodes Front pointer actually =
contains the=20
Index(into the LeafArray) of the Leaf we are in.This means our search is =
over.We=20
simply call 'DrawTree' and pass in this Index so that the DrawTree =
function can=20
render the Leafs PVS Set. Then we return from this function because the =
job is=20
done.<BR><BR>If IsLeaf is Zero however then this means we can safely =
travel down=20
the front of this tree (because there is another node there) so we set =
the=20
'Node' variable to the new Node index and and do another Iteration of =
the=20
'while' loop using the new 'Node' to compare our camera position =
against.=20
<BR><BR>If we are not in front of this Node then we check to see if the =
camera=20
position is behind the 'Node' instead.If it is then we do something very =

similiar as shown below. <BR><BR><CODE><FONT color=3Dblue>case CP_BACK:=20
</FONT><BR>if=20
(NodeArray[Node].Back=3D=3D-1)<BR>{<BR>return;<BR>}<BR>else<BR>{<BR>Node =
=3D=20
NodeArray[Node].Back;<BR>}<BR>break;<BR><BR></CODE>As with the =
'CP_FRONT' case=20
we have to check to see that we can go down the Back of this node.If =
this Nodes=20
'Back' variable equals '-1' then there are no more Nodes to travserse =
and the=20
camera is infact in solid space. This should NEVER happen becuse it =
would mean=20
that your camera is inside a wall or something like that but we dont =
want any=20
crashes before you implement your collision detection because then you =
could=20
walk through a wall accidentally.To keep things safe I simply return if =
the=20
camera is in solid space which means nothing gets rendered.Like I said =
though,=20
this should never happen.<BR>If there is a Back Node though then we =
adjust the=20
Node variable to the New Node and do another loop of the while 'loop' =
with the=20
new node being used as the split plane to test. <BR><BR>The last case to =
test is=20
the CP_ONPLANE case which means the camera point is actually right on =
the split=20
plane.In this case I just treat it exactly the same as CP_FRONT meaning =
the code=20
is the same as CP_FRONT.<BR><BR><CODE><FONT color=3Dblue>case=20
CP_ONPLANE:</FONT><BR>if=20
(NodeArray[Node].IsLeaf!=3D0)<BR>{<BR>leaf=3DNodeArray[Node].Front;<BR>Dr=
awTree(leaf);<BR>return;<BR>}<BR>else<BR>{<BR>Node=20
=3D NodeArray[Node].Front;<BR>}<BR><BR>default:<BR>break;<BR>}<BR>}// =
end=20
while<BR>}// End Function</CODE><BR><BR>Thats it.Quite a small function =
really=20
considering what it does.Here is the function in its=20
entirety:-<BR><BR><CODE>void RenderTree(D3DVECTOR pos)<BR>{<BR>int=20
Node=3D0;<BR>int=20
leaf=3D0;<BR></CODE><CODE>while(1)<BR>{<BR>switch(ClassifyPoint(&amp;pos,=
&amp;PlaneArray[NodeArray[Node].Plane]))<BR>{<BR><FONT=20
color=3Dblue>case CP_FRONT:</FONT> <BR>if=20
(NodeArray[Node].IsLeaf!=3D0)<BR>{<BR>leaf=3DNodeArray[Node].Front;<BR>Dr=
awTree(leaf);<BR>return;<BR>}<BR>else<BR>{<BR>Node=20
=3D NodeArray[Node].Front;<BR>}<BR>break;<BR><BR></CODE><CODE><FONT=20
color=3Dblue>case CP_BACK: </FONT><BR>if=20
(NodeArray[Node].Back=3D=3D-1)<BR>{<BR>return;<BR>}<BR>else<BR>{<BR>Node =
=3D=20
NodeArray[Node].Back;<BR>}<BR>break;<BR><BR></CODE><CODE><FONT =
color=3Dblue>case=20
CP_ONPLANE:</FONT><BR>if=20
(NodeArray[Node].IsLeaf!=3D0)<BR>{<BR>leaf=3DNodeArray[Node].Front;<BR>Dr=
awTree(leaf);<BR>return;<BR>}<BR>else<BR>{<BR>Node=20
=3D NodeArray[Node].Front;<BR>}<BR><BR>default:<BR>break;<BR>}<BR>}// =
end=20
while<BR>}// End Function</CODE><BR><BR><FONT color=3Dgreen =
size=3D5><U>Rendering a=20
Leaf : (A detailed look at the 'DrawTree' function)</U></FONT> =
<BR><BR>Although=20
we have not yet discussed how to create the actual PVS Data for the =
Solid Leaf=20
Tree we have discussed how the PVS Data will eventually be stored in =
memory.If=20
you remember we said that there will be one master array called =
'PVSData' that=20
will hold ALL the PVS visibility information for all the leafs.The PVS =
data is=20
stored in the array in Leaf order. In other words Leaf 1 has its =
visibility=20
information first followed by Leaf 2 etc right up to the total number of =
leafs=20
in the tree. Also remember that each leafs visibility information will =
be a run=20
of bytes containing 1 bit for each leaf visible from that leaf. Now you =
might=20
think to access a leafs visibility information we could simply access =
the array=20
using something like:-<BR><BR><EM>BYTE *=20
LeafVis=3D&amp;PVSData[ThisLeaf*(NumberOfLeafs/8));</EM><BR><BR>This =
would assume=20
that each leaf has exactly the same amount of information in BYTES.After =
all=20
each Leaf has to have a bit per leaf so you would think that because one =
Byte=20
can hold 8 bits we simply divide the Number Of Leafs by 8 to find out =
how many=20
bytes each Leaf has for its visibility information and then multiply =
that by the=20
Current Leaf we are trying to access the data for. This is NOT going to =
work=20
because remember each Leafs Visibility information will be 'Zero Run =
Length=20
Encoded' as discussed earlier.This means each leaf could have a varying =
number=20
of bytes depending on how many leafs that leaf can see.To get around =
this=20
problem we record where each Leafs Visibility Information begins in the =
array=20
when we are compressing and building the PVS array. We will look at this =
later=20
when we actually create the PVS but in order to understand the following =

function code (DrawLeaf) just know that the 'PVSIndex' field of the Leaf =

structure will hold the index of the BYTE into the Master PVS array that =
that=20
Leafs Visibility information starts. We touched on the code for this =
function=20
earlier but lets have another look now that you know how the Solid Leaf =
Tree has=20
been compiled and how the Leaf data structures have been filled out. The =

following function is the ONLY render function.This function is the sole =

function responsable for putting the polygons on the screen. Everything =
that=20
gets rendered gets rendered in this function.This function will only get =
called=20
once per frame and was called by the previous function we just looked=20
at.Remember this function is called by the 'RenderTree' function after =
the=20
Current Leaf the camera is in has been located.The RenderTree function =
called=20
this function with the index of the Leaf the camera is currently in. =
Here is the=20
code that renders everything you see in the demo, a bit at a=20
time.<BR><BR><CODE>void DrawTree(long leaf)<BR>{<BR>POLYGON =
*CurrentPoly;<BR>int=20
i;<BR>long PVSOFFSET=3DLeafArray[leaf].PVSIndex;<BR>BYTE=20
*PVSPointer=3DPVSData;<BR>PVSPointer+=3DPVSOFFSET;<BR>long=20
currentleaf=3D0;<BR><BR></CODE>Above you can see the code creates a BYTE =
pointer=20
to point to the first BYTE of this Leafs Visibility information.The Leaf =
itself=20
holds the Number of Bytes in from the beginning of the array (stored in=20
PVSIndex) so this is the offset into the master PVSData array where this =
leafs=20
visibility information starts.So we create a pointer to the PVSData =
array and=20
simply add the offset on.PVSPointer now points at this Leafs PVS =
information.=20
Current Leaf is set to zero. This variable will keep track of which leaf =
in THIS=20
leafs PVS information we are currently checking the visibility BIT of. =
When=20
Current Leaf equals NumberOfLeafs we know we have checked all the leafs =
in this=20
leafs PVS information and nothing more has to be rendered.<BR><BR>The =
Next bit=20
will take a little explaining. Batching polygons in groups of the =
textures they=20
use can be very important. Changing textures is one of the most =
expensive=20
renderstates D3D performs as it can often cause much swapping of data =
from=20
system memory to video memory when space is limited.When we find a =
polygon that=20
is visible we can't just render it because that would mean Setting =
Textures for=20
EVERY polygon in the PVS Data set.This is very costly.Instead we need to =
batch=20
the Polygons in groups of textures that they use so for example we would =
render=20
all the polygons that use Texture1 together followed by all the polygons =
that=20
use Texture2 etc and so on. To get around this problem I have created an =
array=20
of polygon pointers (one for each texture) that will be used to =
construct a=20
linked list. I have 25 Textures used in the demo so I have an array of =
25=20
Polygon Pointers that are defined Globally like =
this:-<BR><BR><EM>POLYGON *=20
pTexturePolygonList[25];</EM> <BR><BR>You may remember that when we =
created our=20
BSP we fed our polygons into the compiler using a linked list where =
every=20
polygon was linked together using the Polygons 'Next' pointer.Now =
because those=20
polygon have since been copied into an array in linear order of the =
leafs to=20
which they belong these fields are no longer being used.We will use it =
each=20
frame to add the polygon to the Linked list to which it belongs =
depending on the=20
texture it uses. We will step though the PVS Data but when we find a =
visible=20
Leaf, instead of rendering its polygons we will check which texture that =
polygon=20
uses and add it to the appropriate Linked list.In other words, if the =
the=20
current polygon being checked has 6 in its TextureIndex field we will =
add that=20
to the linked list being pointed to by pTexturePolygon[6].By the time we =
have=20
traversed through the PVS data for this leaf we will have 25 linked =
lists.We=20
will SetTexture 1 and then render all the polygons in linked list=20
'pTexturePolygonList[1]' and then set texture 2 and then render all the =
polygon=20
in Linked list 'pTexturePolygonList[2]' and so on. This means at most we =
will=20
only be setting a new texture 25 times per frame instead of every =
polygon.<BR>We=20
will see this in action shortly but the next snippet of code in the =
'DrawTree'=20
function simply sets all these pointers to null each frame. =
<BR><BR><CODE>// Set=20
All the Texture Batch Pointers to NULL<BR>for=20
(i=3D0;i&lt;25;i++)<BR>{<BR>pTexturePolygonList[i]=3DNULL;<BR>}<BR><BR></=
CODE>Ok=20
thats done. Now its time to check the Visibility information for this =
leaf.We=20
create a while loop that wil exit once CurrentLeaf=3DNumberOfLeafs =
because this=20
means we have checked all the visibility information and we now have our =
25=20
linked lists of polygons ready to be rendered.. <BR><BR><CODE>while=20
(currentleaf&lt;NumberOfLeafs)<BR>{<BR>if (*PVSPointer!=3D0)<BR>{ =
<BR>for=20
(i=3D0;i&lt;8;i++)<BR>{ <BR>BYTE mask=3D1&lt;&lt;i;<BR>BYTE=20
pvs=3D*PVSPointer;<BR><BR>if (pvs&amp;mask)<BR>{<BR><BR></CODE>First we =
check if=20
the current Byte is non zero.If it is non zero then it means some of the =
BITs=20
are set to one in this byte so at least one(but could be all) of the =
leafs=20
represented by this byte must be visible. <BR>We need to find out which =
bits are=20
visible so we create a for next loop from 0-7 (one byte holds 8 leafs =
visibility=20
bits remember) to find out which bits have been set.We do this by =
creating a=20
MASK that begins with a value of 1 and gets shifted right by one =
position each=20
iteration of the four next loop.By ANDing this BYTE with the PVS Byte we =
can see=20
if that BIT is set to one or zero.Each time through the for next loop=20
CurrentLeaf is also increased by one so we know which leaf we are =
checking.If=20
the AND result is not zero it means this leaf has its bit set so it is=20
Potentially visible. <BR><BR>As discussed earlier Potentially Visible =
does not=20
mean IS visible from the current location so we can further refine (lose =
even=20
more polys) the PVS set by checking the Potentially Visible leafs =
bounding box=20
against the View frustum.I will show you how to write Frustum Rejection =
code for=20
bounding boxes later but this is the reason while compiling the Solid =
Leaf Tree=20
we stored the Leafs Bounding Box in the Leaf Structure.We will see later =
the=20
code for the 'LeafInFrustum' function.Just know for now that it returns =
true if=20
part of this leaf is within the frustum and so should be=20
rendered.<BR><BR><CODE>if (LeafInFrustum(currentleaf)=3D=3Dtrue ||=20
DontFrustumReject=3D=3Dtrue)<BR>{ </CODE><BR><BR>Above the =
DontRejectFrustum=20
variable is used in the demo to Disable Frustum rejection so you can see =
the=20
effect it has in the top down view.This is toggled by pressing =
'F2'.<BR><BR>If=20
we have made it here then the Leaf is visible and all polygons belonging =
to this=20
leaf should be rendered.So what we do is gather the polygons used by =
this leaf=20
(remember a leafs polygons are all stored in the PolygonArray next to =
each=20
other) and add them to the appropriate TexturePolygonList to which they =
belong.=20
<BR><BR><CODE>unsigned long=20
start=3DLeafArray[currentleaf].StartPolygon;<BR>unsigned long=20
finish=3DLeafArray[currentleaf].EndPolygon;<BR>unsigned long =
Count=3D0;<BR><BR>for=20
(Count=3Dstart;Count&lt;finish;Count++) // Collect the polys and add to =
Texture=20
List<BR>{<BR>CurrentPoly=3D&amp;PolygonArray[Count];<BR>CurrentPoly-&gt;N=
ext=3DpTexturePolygonList[CurrentPoly-&gt;TextureIndex];<BR>pTexturePolyg=
onList[CurrentPoly-&gt;TextureIndex]=3DCurrentPoly;<BR>}<BR>}//=20
end if leaf infrustum<BR>}// end for if pvsdata<BR>currentleaf++;<BR>}// =
end for=20
i;<BR>PVSPointer++;<BR>}<BR></CODE><BR>Above we add each polygon in the =
leaf to=20
the Texture Polygon List by checking the polygons texture index.In other =
words=20
each poly in the leaf is checked and sent to the linked list to which it =

belongs.These lists will be rendered at the end of this function =
rendering all=20
polygons in order of texture.<BR><BR>After this we increase the current =
leaf for=20
each BIT checked in the current byte and when that is done we increment=20
PVSPointer so that it points to the Next Byte (8 leafs) in the PVS data. =
And=20
that is all there is to dealing with BYTEs in the PVS array that have =
some BITs=20
set.<BR><BR>If this BYTE in the Leafs PVS data does equal zero however =
we dont=20
have to check the bits at all. This means we are in Zero Run Length =
Encoding=20
(compression) Mode and the NEXT byte in the PVS data array will equal =
how many=20
bytes of zero there are or in other words, the length of the=20
run.<BR><BR><CODE>else<BR>{// we have hit a zero so read in next byte =
for run=20
length<BR>PVSPointer++;<BR>BYTE=20
RunLength=3D*PVSPointer;<BR>PVSPointer++;<BR>currentleaf+=3DRunLength*8;<=
BR>}<BR><BR>}//=20
end for while<BR><BR></CODE>Above shows what happen if the Current Byte =
the PVS=20
data is zero. We read in the next Byte which will tell us how many zero =
bytes=20
are in a run and we adjust our 'currentleaf' parameter so that it skips =
past all=20
the leafs in the run. Remember that RunLength is the number of bytes in =
th run=20
and each byte hold 8 bits of information for each leaf so that is why we =
adjust=20
'currentleaf' by 'Runlength*8'.<BR>We then increase the 'PVSPointer' so =
that it=20
will point at the next byte in the array for the next iteration of the =
while=20
loop. <BR><BR>That is the main while loop covered. Once we get here the =
while=20
loop has finished and we have a (possible) 25 linked lists of polygons , =
each=20
list tied to a particular texture. Our next job now is easy, we simply =
loop from=20
0-24 checking that each Polygon list is not NULL, and if it isnt it =
means there=20
are polygons to be rendered for that texture. So, we set the texture and =
do a=20
while loop to render the polygons for each list.Here is the last bit of =
the=20
'DrawTree' function that actually draws ALL the polygons that can be =
seen this=20
frame.<BR><BR><CODE>for (i=3D0;i&lt;NumberOfTextures;i++)<BR>{<BR>if=20
(pTexturePolygonList[i]!=3DNULL)<BR>{<BR>lpDevice-&gt;SetTexture(0,lpText=
ureSurface[i]);<BR>CurrentPoly=3DpTexturePolygonList[i];<BR>lpDevice-&gt;=
SetVertexShader(=20
D3DFVF_LVERTEX );<BR>while=20
(CurrentPoly!=3DNULL)<BR>{<BR><BR>lpDevice-&gt;DrawIndexedPrimitiveUP(D3D=
PT_TRIANGLELIST,0,CurrentPoly-&gt;NumberOfVertices,=20
CurrentPoly-&gt;NumberOfIndices/3,&amp;CurrentPoly-&gt;Indices[0],=20
D3DFMT_INDEX16=20
,&amp;CurrentPoly-&gt;VertexList[0],sizeof(D3DLVERTEX));<BR><BR>CurrentPo=
ly=3DCurrentPoly-&gt;Next;<BR>}<BR>}<BR>}<BR>lpDevice-&gt;SetTexture(0,NU=
LL);<BR>}//End=20
Function<BR><BR></CODE>All done . Scene rendered. Above we Set the =
current=20
texture in TextureStage 0 and also use the Temporary variable =
'CurrentPoly' to=20
point at the head of each List.This will be used to step though each =
polygon=20
list.We then use 'CurrentPoly' to iterate through the Linked List until =
we reach=20
the end of that list.When there is a polygon we Render it using=20
DrawIndexedPrimitiveUP.<BR><BR>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD bgColor=3Dred><U><FONT color=3Dwhite><FONT size=3D2>DX8 =
NOTE</U><BR>For=20
      those of you that have not used DrawIndexedPrimitiveUP before the =
syntax=20
      is:-<BR><BR><CODE>DrawIndexedPrimitiveUP(<BR>D3DPRIMITIVETYPE=20
      PrimitiveType,<BR>UINT MinIndex,<BR>UINT NumVertices,<BR>UINT=20
      PrimitiveCount,<BR>CONST void* pIndexData,<BR>D3DFORMAT=20
      IndexDataFormat,<BR>CONST void* pVertexStreamZeroData,<BR>UINT=20
      VertexStreamZeroStride);<BR><BR></CODE>'MinIndex' is the index of =
the=20
      Minimum Vertex in the vertex array that will be used by this =
call.Because=20
      every Polygon in the scene has its own Vertex List we want to use =
all the=20
      vertices for this polygon so we start at zero. Primitive Count is =
a new=20
      parameter also.Instead of specifying the Number OF indices you now =
specify=20
      how many primitives will have to be rendered to make up this=20
      polygon.Remember your polygon may have been broken down into many=20
      triangles by the 'AddPolygon' function. For triangle Lists it =
works out we=20
      can just divide the Number Of Indices by three to get the =
primitive count.=20
      Above I have used D3DFMT_INDEX16 to tell direct3d that my Indices =
array=20
      holds 16bit (WORD) values.You can have 32 bit indices now if you =
need=20
      them. The one from last parameter is just a pointer to your vertex =
data=20
      and the last parameter describes the size to step between each =
vertex to=20
      get to the next one in the array (in bytes).This is equal tothe =
size of=20
      out D3DLVERTX structure. <BR></FONT></FONT>
    <TD></TD></TR></TBODY></TABLE>All done.For completeness here is the =
entire=20
DrawTree function:-<BR><BR><CODE><FONT size=3D2>void DrawTree(long=20
leaf)<BR>{<BR>POLYGON *CurrentPoly;<BR>int i;<BR>long=20
PVSOFFSET=3DLeafArray[leaf].PVSIndex;<BR>BYTE=20
*PVSPointer=3DPVSData;<BR>PVSPointer+=3DPVSOFFSET;<BR>long =
currentleaf=3D0;<BR><BR>//=20
Set All the Texture Batch Pointers to NULL<BR>for=20
(i=3D0;i&lt;25;i++)<BR>{<BR>pTexturePolygonList[i]=3DNULL;<BR>}<BR><BR>wh=
ile=20
(currentleaf&lt;NumberOfLeafs)<BR>{<BR>if (*PVSPointer!=3D0)<BR>{ =
<BR>for=20
(i=3D0;i&lt;8;i++)<BR>{ <BR>BYTE mask=3D1&lt;&lt;i;<BR>BYTE =
pvs=3D*PVSPointer;<BR>if=20
(pvs&amp;mask)<BR>{<BR>if (LeafInFrustum(currentleaf)=3D=3Dtrue ||=20
DontFrustumReject=3D=3Dtrue)<BR>{ <BR>unsigned long=20
start=3DLeafArray[currentleaf].StartPolygon;<BR>unsigned long=20
finish=3DLeafArray[currentleaf].EndPolygon; <BR>unsigned long =
Count=3D0;<BR><BR>for=20
(Count=3Dstart;Count&lt;finish;Count++)=20
<BR>{<BR>CurrentPoly=3D&amp;PolygonArray[Count];<BR>CurrentPoly-&gt;Next=3D=
pTexturePolygonList[CurrentPoly-&gt;TextureIndex];=20
pTexturePolygonList[CurrentPoly-&gt;TextureIndex]=3DCurrentPoly; =
}<BR>}// end if=20
leaf infrustum<BR><BR>}// end for if pvsdata<BR>currentleaf++;<BR>}// =
end for=20
i;<BR>PVSPointer++;<BR>}// if pvspointer!=3D0; In other words if this is =
not a=20
compressed byte<BR><BR>else<BR><BR>{// we have hit a zero so read in the =
next=20
byte and see how long the run of zeros is<BR>PVSPointer++;<BR>BYTE=20
RunLength=3D*PVSPointer;<BR>PVSPointer++;<BR>currentleaf+=3DRunLength*8;<=
BR>}<BR>}//=20
end for while<BR><BR>//Render Polygons in the textures lists.<BR><BR>for =

(i=3D0;i&lt;NumberOfTextures;i++)<BR>{<BR>if=20
(pTexturePolygonList[i]!=3DNULL)<BR>{<BR>lpDevice-&gt;SetTexture(0,lpText=
ureSurface[i]);<BR>CurrentPoly=3DpTexturePolygonList[i];<BR>lpDevice-&gt;=
SetVertexShader(=20
D3DFVF_LVERTEX );<BR><BR>while=20
(CurrentPoly!=3DNULL)<BR>{<BR>lpDevice-&gt;DrawIndexedPrimitiveUP(D3DPT_T=
RIANGLELIST,0,CurrentPoly-&gt;NumberOfVertices,=20
CurrentPoly-&gt;NumberOfIndices/3,&amp;CurrentPoly-&gt;Indices[0],=20
D3DFMT_INDEX16=20
,&amp;CurrentPoly-&gt;VertexList[0],sizeof(D3DLVERTEX));<BR><BR>CurrentPo=
ly=3DCurrentPoly-&gt;Next;<BR>}<BR>}<BR>}<BR>lpDevice-&gt;SetTexture(0,NU=
LL);<BR>}//End=20
Function<BR><BR></FONT></CODE><BR><BR>We have now written the functions =
to=20
compile our BSP tree and render the tree using a PVS. We do of course =
still have=20
to to compile the PVS before we can use our render function which is =
what we are=20
about to start looking at.Before we do though there is one more function =
I=20
thought I had better put in for completeness.<BR><BR>In the previous =
tutorial we=20
created a LineOfSight function that was created for determining if any =
solid=20
space existed between two points.It was also used for collision =
detection and=20
was a very handy function to have for all sorts of reasons.You could =
also use=20
the LineOfSight function to create lightmaps or to see if a Monster can =
See the=20
player during the game.<BR><BR>Because we now have a Solid LEAF tree =
(using the=20
'check first then go' system ) instead of the Node Tree this function =
had to be=20
modified slightly.Once again I decribed how this function worked in Part =
1 (with=20
pretty pictures and everything:)) so I am not going to explain it again =
but=20
simply show you the new Slightly modified Version with a few comments on =
the=20
changes.<BR><BR><CODE><FONT size=3D2>bool LineOfSight (D3DXVECTOR3=20
*Start,D3DXVECTOR3 *End, long Node)<BR>{<BR>float temp;<BR>D3DXVECTOR3=20
intersection;<BR>NODE *CurrNode=3D&amp;NodeArray[Node];<BR>PLANE=20
*Plane=3D&amp;PlaneArray[CurrNode-&gt;Plane];<BR><BR>int=20
PointA=3DClassifyPoint(Start, Plane);<BR>int PointB=3DClassifyPoint(End, =

Plane);<BR><BR></CODE>Point A and Point B hold the Start and End points =
of the=20
Ray we are using to test against the tree.If BOTH points are on the =
Current=20
Nodes Planes then we will simply treat it as being in front of the plane =
and=20
recur down the Front of this node.We check this Nodes IsLeaf variable =
just to=20
check that there is another Node down the front tree of this node.If =
there is=20
then we recurse down that tree with the Ray.If IsLeaf is non zero =
however then=20
there is not another NOde and the Front Variable holds the Leaf index.We =
can=20
return true because Leafs are empty space and both points are obviously =
in this=20
leaf.<BR><BR><CODE>if (PointA=3D=3DCP_ONPLANE &amp;&amp;=20
PointB=3D=3DCP_ONPLANE)<BR>{<BR>if (CurrNode-&gt;IsLeaf=3D=3D0)// this =
is not a leaf so=20
recurse<BR>{<BR>return=20
LineOfSight(Start,End,CurrNode-&gt;Front);<BR>}<BR>else<BR>{<BR>return =
true; //=20
This is a front leaf.Front Leafs are always empty so this is empty=20
space<BR>}<BR>}</CODE><BR><BR>Next we check if PointA is in front of the =
Node=20
and Point B is behind the node.First we check if the Back part of the =
Node is=20
solid space (if 'Back=3D=3D-1') and return false if it is because there =
is no line=20
of sight if part of the ray is in solid space. If this is not the case =
we then=20
split the Ray with the plane (using Getintersect decribed in detail in =
part1).We=20
then check if there is a Node to the front of this node as we did =
above.If there=20
is not a leaf to the front of this node but instead there is another =
node the we=20
return true only if Both fragments of the ray are in empty space.We do =
this by=20
recursing with both ray segments and returning true only if they both =
return=20
TRUE.If there is a Leaf to the front of this node however we know that =
the front=20
ray fragment must be in empty space(so we dont have to check that) so we =
return=20
true if the Back ray fragment is in emprty space.<BR><BR><CODE>if=20
(PointA=3D=3DCP_FRONT &amp;&amp; PointB=3D=3DCP_BACK)<BR>{<BR>if =
(CurrNode-&gt;Back=3D=3D-1)=20
return false;<BR><BR>Get_Intersect=20
(Start,End,&amp;Plane-&gt;PointOnPlane,&amp;Plane-&gt;Normal,&amp;interse=
ction,&amp;temp);<BR><BR>if=20
(CurrNode-&gt;IsLeaf=3D=3D0)<BR>{<BR>return=20
LineOfSight(Start,&amp;intersection,CurrNode-&gt;Front) &amp;&amp;=20
LineOfSight(End,&amp;intersection,CurrNode-&gt;Back)=20
;<BR>}<BR>else<BR>{<BR>return true &amp;&amp;=20
LineOfSight(End,&amp;intersection,CurrNode-&gt;Back);<BR>}<BR>}<BR><BR></=
CODE><BR>If=20
none of the above have been true then we check the other way round =
seeing if=20
PointA is to the Back of the node and if PointB is to the =
front.<BR><BR><CODE>if=20
(PointA=3D=3DCP_BACK &amp;&amp; PointB=3D=3DCP_FRONT)<BR>{<BR>if =
(CurrNode-&gt;Back=3D=3D-1)=20
return false;<BR>Get_Intersect=20
(Start,End,&amp;Plane-&gt;PointOnPlane,&amp;Plane-&gt;Normal,&amp;interse=
ction,&amp;temp);<BR><BR>if=20
(CurrNode-&gt;IsLeaf=3D=3D0)<BR>{<BR>return=20
LineOfSight(End,&amp;intersection,CurrNode-&gt;Front) &amp;&amp;=20
LineOfSight(Start,&amp;intersection,CurrNode-&gt;Back)=20
;<BR>}<BR>else<BR>{<BR>return true &amp;&amp;=20
LineOfSight(Start,&amp;intersection,CurrNode-&gt;Back);<BR>}<BR>}<BR><BR>=
</CODE>If=20
we get as far as here it must mean one of the points is on the plane and =
the=20
other is not.In this case we treat the point ON the plane as being the =
same as=20
the Point not on the plane.In other words we send it down the side of =
the tree=20
that the other point lays in.<BR><BR><CODE><BR>if (PointA=3D=3DCP_FRONT =
||=20
PointB=3D=3DCP_FRONT)<BR>{<BR>if =
(CurrNode-&gt;IsLeaf=3D=3D0)<BR>{<BR>return=20
LineOfSight(Start,End,CurrNode-&gt;Front);<BR>}<BR>else<BR>{<BR>return=20
true;<BR>}<BR>}<BR><BR>else<BR><BR>{<BR>if=20
(CurrNode-&gt;Back=3D=3D-1)<BR>{<BR>return =
false;<BR>}<BR>else<BR>{<BR>return=20
LineOfSight(Start,End,CurrNode-&gt;Back);<BR>}<BR>}<BR>return=20
true;<BR>}<BR><BR></FONT></CODE>Thankfully we have now Ported over all =
our Solid=20
Node Based functionality to work with the Solid Leaf Tree which means =
its time=20
to move on to the interesting stuff. Please make sure you understand =
everything=20
we have talked about above before reading on because we are now going to =
cover=20
calculating the PVS for the tree and it is vital that you understand how =
the=20
Solid Leaf Tree works and how it is laid out in memory. With that said, =
lets=20
move onto the good stuff. <BR><BR><FONT color=3Dgreen size=3D5>
<CENTER><STRONG><U>Creating a PVS for the Solid Leaf=20
Tree</U></STRONG></CENTER></FONT><BR><BR>Creating a PVS is not a simple =
task to=20
undertake.Its one of those things that seems so hard when you are =
struggling to=20
understand it and then seems so simple once you do understand it that =
you can=20
not believe you struggled to understand it in the first place. =
Unfortunately=20
because of the little information there is on creating a PVS on the net =
at time=20
of writing it took me 3 months to struggle to grasp the concepts and =
implement=20
the code for this tutorial. I hope I can explain it to you in a way that =
you can=20
understand it easily and avoid the headaches I had.<BR><BR>Basically the =
process=20
of Pre Calculating a PVS is broken down into two steps. Portal =
Generation is the=20
First step and Anti-Penumbra Clipping is the second. We will ofcourse =
start at=20
step one Portal Generation.<BR><BR><FONT color=3Dgreen size=3D4><U>
<CENTER>What is a Portal ?</CENTER></U></FONT>In order to calculate =
which leafs=20
in the tree can see each other we need to know the GAPS that exist =
between those=20
leafs.For example if you have 2 rooms with a door way between them we =
need to=20
know how much of room 2 can be seen through the doorway whilst standing =
in room=20
1. The problem is that is the only information we do not have about our =
3d=20
world.Our polygon set tells us where there are NOT gaps but does not =
tell us=20
where there ARE gaps. To get around this problem we will create =
temporary=20
polygons called Portals (thats right! Portals are just polygons) that =
will be=20
the size and dimensions of all the gaps between all the leafs in the =
tree. If=20
you think back to the two rooms example with the doorway, we need to =
somehow=20
create a polygon that would fit into the doorway to plug it up so to =
speak.=20
These portals will not be rendered or even kept after the PVS has been=20
calculated but they are needed because if we can create a Portal to plug =
up the=20
doorway then getting the dimensions of this Portal will get us the =
dimensions of=20
the doorway which is exactly what we need.<BR><BR>As you can probably =
imagine=20
creating portal Polygons to fit into all the gaps in our level is going =
to=20
create many many portals.In otherwords if a room has 5 doorways we will =
need=20
create a portal in each doorway and so on for every leaf . <BR>If you =
look at=20
the diagram below you should be able to see where the portals should =
be.I have=20
highlighted them in red. You can see that the portals themselves lay on =
the Node=20
that divides them.Below we have three leafs. You can see that portal 1 =
describes=20
the entrance from leaf E,F,d1 and A,c2,d2 and vice versa. Portal 2 =
describes the=20
entrance A,c2,d2 into leaf b,c1 and vice versa.<BR><BR>
<CENTER><IMG height=3D293=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsj.gif"=20
width=3D276></CENTER>Because of the nature of BSP trees portals between =
two leafs=20
will always be on one of the Split planes in out tree.Above Portal 1 is =
on Node=20
F's split plane and Portal 2 is on Node A's split plane. So how do we =
create=20
these Portal?<BR><BR><FONT color=3Dgreen size=3D5><U>
<CENTER>Portal Generation</CENTER></U></FONT><BR><BR>First of all I am =
going to=20
write a list of the steps involved in Portal Generation which may scare =
you half=20
to death but do not worry I will show this being done in a moment with =
lots of=20
diagrams:). To create a Complete Portal set for our Solid leaf bsp tree =
we have=20
to do the following.<BR><BR>1.We have to Build a Large polygon =
(potential=20
portal) on each Node plane in our tree.This polygon should be large =
enough so=20
that it encompasses all the Leafs down the front and the back of the =
Node.We do=20
this step for each node.This polygon is an initial portal that we will =
later=20
send through the tree and clip down to size.<BR><BR>2.For each node, =
once we=20
have created the initial large portal we then have to send it down the =
BSP tree=20
starting at the root node. The great thing about the Solid Leaf Tree is =
that=20
because all the space is divided into Solid/Empty areas we can simply =
send it=20
down the tree and repeatedly clip the portal against the other nodes in =
the tree=20
knowing that any portal fragments that end up in solid space can be =
removed=20
because a Portal can not exist in the middle of a wall obviously.What =
this means=20
is that we can create a large square Portal and send it down the BSP =
tree and=20
clip it against all the nodes of our tree.As the Portal gets recursively =

split,any portal fragments that end up in Solid Space are deleted and we =
are=20
left with the shape and size of the portal as it should be to fit the =
gap=20
between the two leafs the portal is being generated for. <BR>However the =

Clipping of the Portal to the tree is a little complex but I will =
describe it=20
here in a little detail and then we will look at it in much more detail =
later=20
when we write the clip function.Clipping the portal to the tree involved =

traverse each node in the tree and testing the Portal against the Node =
plane to=20
see whether it is to the Front,Back,Spanning or on the plane.These are =
how the=20
cases are dealt with<BR><BR>CP_FRONT:<BR>If the portal (or portal =
fragment) is=20
to the front of the current test node then we either send it down the =
front tree=20
if another front node exists OR if there is a leaf there it means this =
portal=20
has ended up in this leaf and we store the index of this leaf in the =
portal.Each=20
portal will keep track of the leaf/leafs that it ends up in as this =
describes=20
the two leafs the portal connects.Valid portals must be in two leafs so =
any=20
Portals that only end up in one leaf will be deleted . As an example, =
you can=20
not have a door way in your house that can only be seen from that room =
can you?=20
There must be something on the other side.If a portal only ends up in =
one leaf=20
then it is buried in a wall or something like that so is removed.=20
<BR><BR>CP_BACK:<BR>If the Portal is to the back of the current node =
then we=20
either send it down the back tree is a node exists OR of this nodes =
'Back' =3D-1=20
the the portal has ended up in solid space and can be=20
deleted.<BR><BR>CP_ONPLANE:<BR>This is a little tricky this one.If the =
Portal is=20
on the plane then we first send the Portal down the Front Tree.This =
portal will=20
can get split and carved whilst travelling down the front Tree so that =
the=20
returned result is no longer one portal but a list of portal fagments =
that=20
survived the Front tree.We then send each of these Portal Fragments down =
the=20
back tree one at a time , clipping the fragment to the back tree..Any =
fragments=20
that survive both trees are returned as being =
Portals.<BR><BR>CP_SPANNING:<BR>If=20
the Portal is spanning the Node plane then we split the portal into two =
(a front=20
and a back portal) and send the Front Portal down the front tree and =
then send=20
the Back portal down the back tree. We then return the resulting =
frgament from=20
both trees. Dont Panic you will see the code shortly:).Its not as bad as =
it=20
sounds. <BR><BR>3) At this point we will now have a list of many many=20
Portals.Not all Portals will be valid however as some may only exist in =
one=20
leaf.Portals must be in two leafs so we will then remove any portals =
that are=20
only in one leaf.<BR><BR>4)At this point we have a valid list of all the =
portals=20
in our scene.Each portal will contain which leafs it is in and for ease =
later on=20
we will also store in each leaf which Portals it contains.Just as a =
reminder=20
lets have a look at the 'Leaf' structure again and you should be able to =
see=20
what those other fields were for.<BR><BR><CODE>struct LEAF{<BR>long=20
StartPolygon;<BR>long EndPolygon; <BR><FONT color=3Dred>long =
PortalIndexList[50];=20
<BR>long NumberOfPortals;<BR></FONT>long PVSIndex; <BR>BOUNDINGBOX=20
BoundingBox;<BR>};<BR><BR></CODE>Above I have highlighted the two fields =
we have=20
not yet discussed.NumberOfPortals simply holds the NumberOfPortals that =
this=20
leaf has in it.Remember that a room could have many many doorways.=20
PortalIndexList is just an array in indexes into the master Portal =
Array.We will=20
talk about the Portal Stucture in a moment but just know for now that =
this array=20
is just like the other master arrays (LeafArray,NodeArray etc) except =
that it=20
holds Pointers to PORTALs.When the Valid Portals are created they will =
be added=20
to this array.<BR><BR>If the above explanation had made you head spin a =
little=20
bit dont worry as we are now going to put it to practice with a load of =
diagrams=20
so you can see step by step how the Portal Generation system works.=20
<BR><BR><FONT color=3Dgreen size=3D4><U>
<CENTER>Building a Portal</CENTER></U></FONT><BR><BR>The first step to =
creating=20
a portal mentoined above was to create a Polygon on each Node plane that =
was=20
large enough to encompass the data set of that node.This is why we =
stored the=20
Bounding Box information of each node during the Tree compilation =
because this=20
information will be needed to create such a polygon. We will start at =
the root=20
of the tree so the first Node we will create a portal for is Node =
F.Diagram K,=20
shows what this initial portal will look like.<BR><BR>
<CENTER><IMG height=3D282=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsk.gif"=20
width=3D619></CENTER><BR><EM>PLEASE NOTE: The Walls in the Above diagram =
are all=20
facing INWARDS</EM>.<BR><BR>Now we said above that we now have to =
traverse the=20
tree starting at the root and classifying it against each pain.The first =
Node=20
this polygon is tested against then is NODE F which obviously returns =
ON_PLANE=20
because this is the Node the Portal was created from to begin with.I =
said above=20
that if a portal is On the plane with the Node then we have to send the =
portal=20
down both sides of that nodes tree.This means we have to first of all =
send it=20
down the front tree of F. This means the next node we test it against is =
Node E=20
to which this Portal Spans the plane.<BR><BR>
<CENTER><IMG height=3D285=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsl.gif"=20
width=3D628></CENTER>The Portal is split into Portal A and Portal B.We =
send portal=20
A down the Back of E but this is solid space so Portal A gets deleted =
because it=20
cant be a valid portal.Portal B however is the front split so we now =
send that=20
down Node E's front tree where it comes to Node D1.The Portal is =
spanning Node=20
d1 also so this Portal has to be split also.<BR>
<CENTER><IMG height=3D291=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsm.gif"=20
width=3D593></CENTER>Portal B is now split into Portal C and D.D is =
behind Node d1=20
so trying to send it down the back of d1 results in it being in solid =
space and=20
so is deleted because it can not be a valid portal.Portal C however is =
sent down=20
Node D1's Front List at which point it ends up in Leaf [F,E,d1]. The =
work is now=20
done for this side of Node Fs tree because we have gone right down the =
front=20
tree of Node F , Carving it down to size as we go ,until we hit a leaf, =
so we=20
record in that portal which leaf it is in and return.We are now back at =
Node F=20
having done the Front Tree.We now have a portal returned which is nearly =
the=20
right size but not quite.Part of the Portal is still in Wall F when the =
Portal=20
should start where A meets F. Because this Polygon was On Plane with =
Node F we=20
now have to send the Portal Fragment down the Back tree of F and do the =
same=20
thing again.<BR><BR>First we come to Node C of which this portal C is in =
front=20
of so we send it down Node C's front tree.Next we come to Node A which =
Portal C=20
spans<BR><BR>
<CENTER><IMG height=3D297=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsn.gif"=20
width=3D627></CENTER>So we split Portal C into Portal E and Portal =
F.Portal F is=20
sent down Node A's front list where it is tested against Node d2 and is =
found to=20
be infront of Node d2.It is then passed down Node d2's front list where =
it ends=20
up in a leaf [c2,A,d2] which means this portal has during its life has =
ended up=20
in Leaf [c2,A,d2] and [F,E,d1] and so is a valid portal.Portal F in the =
above=20
diagram is exactly how our portal should be.It is important to =
understand also=20
that when a Portal is Split into two child Portals,the child portals =
inherit the=20
History of the Parent Portal.In otherwords,if the Parent Portal has =
already=20
ended up in a leaf, then the two child pointers also have that data =
copies over=20
into them so that they too have ended up in the same leaf as the =
parent.This is=20
similar to how we split the Polygons in the BSP compiler .If you =
remember we=20
carried the History of the Parent Polygon into the two child Splits so =
that if=20
the Parent had been used as a split plane then the the two child Splits =
were=20
marked as having been used as a split plane also.With the Child Portals =
though,=20
instead of inheriting whether the Polygon has been used as a split =
plane, we=20
inherit the journey of the Parent portal or more basically which Leafs =
the=20
parent portal has landed in up to that point.<BR>Dont forget though that =
at Node=20
A we also had a back split 'Portal E' to consider.This was the bit of =
the=20
original portal that seemed to be buried in Wall F.We send it down Node =
A's Back=20
list where it comes to Node B.It is Behind Node B and Therefore in Solid =
space=20
and so is deleted.<BR><BR>Thats the basic idea of portal generation.We =
have just=20
created the portal for Node F but we have to step through every Node in =
the tree=20
and do this for every node.Looking at the diagram above try seeing what =
happens=20
when you build a portal on Node E.This Node should not have any portals =
that end=20
up in two leafs and you will find that using this system it wont have.Oh =
hell=20
let me draw some more diagrams just to show you what I mean. We will now =
see=20
what happens when we try to create portals for a Node that will not have =
any=20
valid portals .Lets build a Portal on Node E and see what our Portal =
Generator=20
will do with it. <BR><BR>
<CENTER><IMG height=3D290=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvso.gif"=20
width=3D631></CENTER><BR><BR>Once again we build a Portal on Node E =
(called Portal=20
A) initially large enough to contain all the data(polygons) in its Front =
and=20
Back Trees.We sent it in at the Root node (NODE F).Portal A is spanning =
Node F=20
so we have to split it into portals B and C. We send Portal B down the =
front of=20
Node F where it comes to Node E of which it is On the Plane of so we =
have to=20
process it down both sides.We send it down Node E's front first where it =
comes=20
to Node d1.It is spanning d1 so Portal B gets split in to Portal D and =
E.D is=20
sent down the front where it end up in leaf [F,E,d1] and portal E is =
sent down=20
Node D1's back where it is in solid space and so gets deleted. <BR><BR>
<CENTER><IMG height=3D285=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsp.gif"=20
width=3D624></CENTER><BR><BR>Remember that Portal D originally was sent =
here from=20
Node E (the Node it was On the plane of) so is now returned there where =
it will=20
be sent down the back list of Node E.But there is only solid space down =
the back=20
of node E so we dont send it down there but instead just return it. =
Later when=20
we test the portals we will find out that that portal only ended up in =
one Leaf=20
[F,E,d1] and so is not a valid portal and so should be deleted. And =
there you=20
have, no portals were generated for Node E which is correct.<BR><BR><U>
<CENTER><FONT color=3Dgreen size=3D4>Creating the Initial Portal at Each =

Node</FONT></CENTER></U><BR><BR>The first part of the puzzle to solve is =
how to=20
Create the Initial Portal on each Node plane that is large enough to =
encompass=20
that Nodes data set.Below I will take you through a couple of lines at a =
time=20
the code to the 'CalculateInitialPortal' function but first lets just =
have a=20
look at what the PORTAL structure looks like.It is very similar to our =
POLYGON=20
structure but has a few extra fields.<BR><BR><CODE>struct PORTAL=20
<BR>{<BR>D3DLVERTEX *VertexList;<BR>D3DXVECTOR3 Normal;<BR>WORD=20
NumberOfVertices;<BR>WORD NumberOfIndices;<BR>WORD *Indices;<BR>PORTAL * =

Next;<BR>PORTAL * Prev;<BR>BYTE NumberOfLeafs;<BR>long=20
LeafOwnerArray[2];<BR>};<BR><BR></CODE>This first five fields of this =
structure=20
are the same as the POLYGON structure.This allows us to easily cast a =
PORTAL=20
pointer to a POLYGON Pointer so that we can pass in Portals to our=20
'SplitPolygon','ClassifyPoly' &amp; 'ClassifyPoint' functions.This =
structure=20
though has a Next and a Prev pointer that will be used to point to other =
portals=20
in linked lists.We use the previous portal so that we can remove portals =
from=20
the linked list without destroying the chain.We will see this in action=20
shortly.<BR>The Next Variable is 'NumberOfLeafs' which will be =
incremented every=20
time the portal being created ends up in a leaf. If at the end of the =
portal=20
creation this field does not equal '2' then this is not a valid portal =
because=20
only one side of it is in a leaf. Portals Must exist in two leafs. The =
final=20
'LeafOwnerArray' field is an array of Indexes into the LeafArray =
describing what=20
two leafs the portal is in , in other words which two leafs is this =
portal the=20
doorway between.<BR><BR>Lets have a look at the code to the=20
'CalculateInitialPortal' function.This function is called for each Node =
in the=20
tree during the Portal Generation process.We pass in the NOde we want to =

generate the Portal For.Remember that this Initial Portal is a Large =
portal that=20
encompasses the Nodes data set.This portal will be carved up as we send =
it down=20
the tree and will possible end up getting carved into many Real=20
Portals.<BR><BR><CODE>PORTAL * CalculateInitialPortal(long=20
Node)<BR>{<BR>D3DXVECTOR3=20
MaxP,MinP,CB,CP;<BR>MaxP=3DNodeArray[Node].BoundingBox.BoxMax;// Get =
this Nodes=20
Bounding Box =
ranges<BR>MinP=3DNodeArray[Node].BoundingBox.BoxMin;<BR>D3DXVECTOR3=20
PlaneNormal=3DPlaneArray[NodeArray[Node].Plane].Normal;<BR><BR><BR>CB=3D(=
MaxP+MinP)/2;<BR>float=20
DistanceToPlane=3DD3DXVec3Dot(&amp;(PlaneArray[NodeArray[Node].Plane].Poi=
ntOnPlane-CB),&amp;PlaneNormal);<BR>CP=3DCB+(PlaneNormal*DistanceToPlane)=
;<BR><BR></CODE>First=20
we get the Nodes Bounding Box MAX and MIN points and use them to =
calculate the=20
Center of the Bounding Box ( CB ). Next we use the dot product to find =
the=20
distance from 'CB' to the Plane. This is just standard DotProduct stuff =
so if=20
you are not familiar you may want to read our <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/math_rot3.html">DotProduc=
t</A>=20
Tutorial. Anyway if we create a Vector from the Box Center Point (CP) to =
a Point=20
known to be on the Plane (we have this stored in the Nodes Plane =
structure) and=20
then Dotproduct that vector with the Plane Normal we get returned the =
Shorted=20
Distance to the plane from this point. If we travel in the direction of =
the=20
Plane Normal from 'CB' we will be on the plane at point 'CP'.CP will be =
the=20
Center of the Portal we are going to create. Look below at Figure Q =
which shows=20
a Portal being calculated (SIDE VIEW like a cross section).=20
<CENTER><IMG height=3D446=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsq.gif"=20
width=3D580> </CENTER>You can see from this diagram where Point CP =
actually is.We=20
now have the Center of our portal but now we need to find the vertices =
are going=20
to go.The portal we create will be square so we need four vertices. To =
do this=20
we have to create a Local axis for the Portal.We already have the =
portals Look=20
Vector (the Normal) but we need to create its Right Vector(U in the =
diagram) and=20
Up vector (V in the Diagram).<BR>Performing the Cross Product on two =
Vectors=20
returns a Vector that is Orthogonal to the other two.In the above =
diagram you=20
can see then that if we feed the Plane Normal (which will also be the =
portal=20
normal) and the World UP vector we will have returned a Vector that is=20
Orthogonal to both (Vector U).This is our right Vector.This then means =
that if=20
we Perform the Cross product on the Normal and this new right Vector the =
cross=20
product will return the Up vector (Vector V) in the diagram because this =
is=20
orthogonal to the other two axis. Although this works fine in the above =
example=20
problems can arise if for example the Plane Normal is the same as the =
World Up=20
vector because feeding the Cross Product two vector that are the same =
will fail=20
and the cross product will return an incorrect result . This is because =
if both=20
axis are the same then there is an infinite number of orthogonal vectors =
that=20
could be returned. To get around this we have to check the Plane Normal =
to=20
decide whether we are going to use the World Y axis (like above), the =
World X=20
axis or the World Z axis to Cross (cross product) with the Normal to get =
Vector=20
U.Below we check the Normal of the Plane and create a Vector that is =
LEAST=20
aligned to the plane normal.This vector when used with the plane Normal =
in a=20
Cross product calculation will return Vector U in the above diagram.=20
<BR><BR><CODE><FONT size=3D2>D3DXVECTOR3 =
A=3DD3DXVECTOR3(0.0f,0.0f,0.0f);<BR>if(=20
fabs(PlaneNormal.y) &gt; fabs(PlaneNormal.z) ) <BR>{<BR>if( =
fabs(PlaneNormal.z)=20
&lt; fabs(PlaneNormal.x) )<BR>{<BR>A.z =3D 1;<BR>}<BR>else <BR>{<BR>A.x =
=3D 1;<BR>}=20
<BR>}<BR>else <BR>{<BR>if (fabs(PlaneNormal.y )&lt;=3D =
fabs(PlaneNormal.x) )=20
<BR>{<BR>A.y =3D 1;<BR>}<BR>else <BR>{<BR>A.x =3D=20
1;<BR>}<BR>}<BR><BR></FONT></CODE>At this point, Vector 'A' will either =
contain=20
(1,0,0),(0,1,0) or (0,0,1) depending on which vector is least aligned =
with the=20
plane normal. All we have to do now is Cross Vector A with the Plane =
Normal to=20
get Vector U (our right vector).We Normalize (make it a unit vector) U =
and then=20
Cross 'U' with the Plane Nomral to get Vector 'V' our up vector.Once =
again=20
Normalizing the Result.<BR><BR><CODE>D3DXVec3Cross=20
(&amp;U,&amp;A,&amp;PlaneNormal);<BR>D3DXVec3Normalize(&amp;U,&amp;U);<BR=
>D3DXVec3Cross=20
(&amp;V,&amp;U,&amp;PlaneNormal);<BR>D3DXVec3Normalize(&amp;V,&amp;V);<BR=
><BR></CODE>We=20
now have our U and V vectors which along with our Plane Normal vector =
describes=20
the Local Axis of the Portal. At this point I am now going to show =
Figure Q)=20
again to save you scrolling back up everytime I refer to the diagram.=20
<CENTER><IMG height=3D446=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsq.gif"=20
width=3D580> </CENTER>Next we get the Length of the Vector from center =
point (CP)=20
to the Node Bounding Box maximum Points. This will basically be the =
distance=20
from the Center of the Bounding Box to the Box Corners.In other words, =
half the=20
distance from top right of the Bounding Box to bottom left.This Distance =
is how=20
much we need to scale out U and V vectors so that CP+V will describe the =
Top=20
edge of the portal,CP-V will describe the Bottom edge of the portal, =
CP+U will=20
describe the right Right edge of the Portal and CP-U will describe the =
Left edge=20
of the Portal. <BR><BR><CODE>D3DXVECTOR3 =
BoxHalfLength=3D(MaxP-CB);<BR>float=20
Length=3DD3DXVec3Length(&amp;BoxHalfLength);<BR>U=3DU*Length;<BR>V=3DV*Le=
ngth;<BR><BR></CODE>With=20
these Vectors now scaled like this we can create the the four vertices =
for our=20
portal like so:-<BR><BR><CODE><FONT size=3D2>D3DXVECTOR3 P[4];<BR>P[0] =
=3D CP + U -=20
V;// Bottom Right<BR>P[1] =3D CP + U + V;// Top Right<BR>P[2] =3D CP - U =
+ V;// Top=20
Left<BR>P[3] =3D CP - U - V;// Bottom Left<BR><BR></FONT></CODE>Thats =
the vertices=20
created for the portal.Now we just fill in the Portal Structure much the =
same=20
way we fill in the Polygon Structure in the 'AddPolygon' structure.We =
break the=20
square into two triangles indexed by 6 indices.<BR><BR><CODE><FONT =
size=3D2>PORTAL=20
*Portal=3Dnew=20
PORTAL;<BR>ZeroMemory(Portal,sizeof(PORTAL));<BR><BR>Portal-&gt;Normal=3D=
PlaneNormal;<BR>Portal-&gt;NumberOfVertices=3D4;<BR>Portal-&gt;NumberOfIn=
dices=3D6;<BR>Portal-&gt;VertexList=20
=3D new D3DLVERTEX [Portal-&gt;NumberOfVertices];<BR>Portal-&gt;Indices =
=3D new WORD=20
[Portal-&gt;NumberOfIndices ];<BR><BR>for (int=20
i=3D0;i&lt;4;i++)<BR>{<BR>Portal-&gt;VertexList[i].x=3DP[i].x;<BR>Portal-=
&gt;VertexList[i].y=3DP[i].y;<BR>Portal-&gt;VertexList[i].z=3DP[i].z;<BR>=
Portal-&gt;VertexList[i].color=3DD3DCOLOR_RGBA(rand()%255,rand()%255,rand=
()%255,240);<BR>Portal-&gt;VertexList[i].specular=3D0;<BR>Portal-&gt;Vert=
exList[i].tu=3D0;<BR>Portal-&gt;VertexList[i].tv=3D0;<BR>}<BR>Portal-&gt;=
Indices[0]=3D0;<BR>Portal-&gt;Indices[1]=3D1;<BR>Portal-&gt;Indices[2]=3D=
3;<BR>Portal-&gt;Indices[3]=3D3;<BR>Portal-&gt;Indices[4]=3D1;<BR>Portal-=
&gt;Indices[5]=3D2;<BR>Portal-&gt;Next=3DNULL;<BR>Portal-&gt;Prev=3DNULL;=
<BR>Portal-&gt;NumberOfLeafs=3D0;<BR>return=20
Portal;<BR>}<BR><BR></FONT></CODE>Thats the 'CalculateInitialPortal' =
function=20
done then. I will just show it in its complete form now (without my=20
interruptions every couple of lines) so you can follow it more=20
easily.<BR><BR><CODE><FONT size=3D2>PORTAL * CalculateInitialPortal(long =

Node)<BR>{<BR>D3DXVECTOR3=20
MaxP,MinP,CB,CP;<BR>MaxP=3DNodeArray[Node].BoundingBox.BoxMax;// Get =
this Nodes=20
Bounding Box =
ranges<BR>MinP=3DNodeArray[Node].BoundingBox.BoxMin;<BR>D3DXVECTOR3=20
PlaneNormal=3DPlaneArray[NodeArray[Node].Plane].Normal;<BR><BR><BR>CB=3D(=
MaxP+MinP)/2;<BR>float=20
DistanceToPlane=3DD3DXVec3Dot(&amp;(PlaneArray[NodeArray[Node].Plane].Poi=
ntOnPlane-CB),&amp;PlaneNormal);<BR>CP=3DCB+(PlaneNormal*DistanceToPlane)=
;</FONT><BR><BR></CODE><CODE><FONT=20
size=3D2>D3DXVECTOR3 A=3DD3DXVECTOR3(0.0f,0.0f,0.0f);<BR>if( =
fabs(PlaneNormal.y)=20
&gt; fabs(PlaneNormal.z) ) <BR>{<BR>if( fabs(PlaneNormal.z) &lt;=20
fabs(PlaneNormal.x) )<BR>{<BR>A.z =3D 1;<BR>}<BR>else <BR>{<BR>A.x =3D =
1;<BR>}=20
<BR>}<BR>else <BR>{<BR>if (fabs(PlaneNormal.y )&lt;=3D =
fabs(PlaneNormal.x) )=20
<BR>{<BR>A.y =3D 1;<BR>}<BR>else <BR>{<BR>A.x =3D=20
1;<BR>}<BR>}<BR><BR></FONT></CODE><CODE>D3DXVec3Cross=20
(&amp;U,&amp;A,&amp;PlaneNormal);<BR>D3DXVec3Normalize(&amp;U,&amp;U);<BR=
>D3DXVec3Cross=20
(&amp;V,&amp;U,&amp;PlaneNormal);<BR>D3DXVec3Normalize(&amp;V,&amp;V);<BR=
><BR></CODE><CODE>D3DXVECTOR3=20
BoxHalfLength=3D(MaxP-CB);<BR>float=20
Length=3DD3DXVec3Length(&amp;BoxHalfLength);<BR>U=3DU*Length;<BR>V=3DV*Le=
ngth;<BR><BR></CODE><CODE><FONT=20
size=3D2>D3DXVECTOR3 P[4];<BR>P[0] =3D CP + U - V;// Bottom =
Right<BR>P[1] =3D CP + U +=20
V;// Top Right<BR>P[2] =3D CP - U + V;// Top Left<BR>P[3] =3D CP - U - =
V;// Bottom=20
Left<BR></FONT></CODE><CODE><FONT size=3D2>PORTAL *Portal=3Dnew=20
PORTAL;<BR>ZeroMemory(Portal,sizeof(PORTAL));<BR><BR>Portal-&gt;Normal=3D=
PlaneNormal;<BR>Portal-&gt;NumberOfVertices=3D4;<BR>Portal-&gt;NumberOfIn=
dices=3D6;<BR>Portal-&gt;VertexList=20
=3D new D3DLVERTEX [Portal-&gt;NumberOfVertices];<BR>Portal-&gt;Indices =
=3D new WORD=20
[Portal-&gt;NumberOfIndices ];<BR><BR>for (int=20
i=3D0;i&lt;4;i++)<BR>{<BR>Portal-&gt;VertexList[i].x=3DP[i].x;<BR>Portal-=
&gt;VertexList[i].y=3DP[i].y;<BR>Portal-&gt;VertexList[i].z=3DP[i].z;<BR>=
Portal-&gt;VertexList[i].color=3DD3DCOLOR_RGBA(rand()%255,rand()%255,rand=
()%255,240);<BR>Portal-&gt;VertexList[i].specular=3D0;<BR>Portal-&gt;Vert=
exList[i].tu=3D0;<BR>Portal-&gt;VertexList[i].tv=3D0;<BR>}<BR>Portal-&gt;=
Indices[0]=3D0;<BR>Portal-&gt;Indices[1]=3D1;<BR>Portal-&gt;Indices[2]=3D=
3;<BR>Portal-&gt;Indices[3]=3D3;<BR>Portal-&gt;Indices[4]=3D1;<BR>Portal-=
&gt;Indices[5]=3D2;<BR>Portal-&gt;Next=3DNULL;<BR>Portal-&gt;Prev=3DNULL;=
<BR>Portal-&gt;NumberOfLeafs=3D0;<BR>return=20
Portal;<BR>}<BR><BR></FONT></CODE>That wasn't so bad was it ?<BR><BR>We =
now have=20
a function that can create the Initial Portal, next we will look at the =
function=20
that actually Processes the Portal down the tree and actually creates =
the final=20
portal. This function called 'Clip Portal' is the one function that =
generates=20
our portals. It is a recursive function and all you have to do is pass =
the=20
function a Portal (Our Initial Portal) and the function will return a =
Linked=20
List of Real Portals (Fragments of the Initial Portal) that survived the =

Clipping process. If the function returns NULL then none of =
'InitialPortal'=20
survived the Clip Process. After we talk about the Code for the =
'ClipPortal'=20
function we will take a look at the parent function that calls both=20
'CalculateInitialPortal' &amp; 'ClipPortal' for every Node in the tree =
and=20
generates the master PortalArray that will be used for the PVS =
set.<BR><BR>I=20
will try and go easy with you explaining this next function because this =
is the=20
Real MEAT of the portal generator and is the function that does all the =
work.As=20
a result it can look a bit daunting on first look.But I will take it =
real=20
slow.<BR><BR><U><FONT size=3D5>
<CENTER><STRONG><FONT color=3Dgreen>The 'Clip Portal' Function (Pretty=20
Scary)</FONT></STRONG></CENTER></FONT></U><BR><BR>Actually the =
'ClipPortal'=20
function is very similar to the actual BSP Compiler in many ways.We =
simply Send=20
the Portal through the tree Classifying it against each node. All the =
Portal=20
Related functions are contained in 'Portal.cpp'.Anyway, here it is a few =
lines=20
at a time.:-<BR><BR><CODE>PORTAL * ClipPortal(long Node,PORTAL=20
*Portal)<BR>{<BR>PORTAL=20
*PortalList=3DNULL,*FrontPortalList=3DNULL,*BackPortalList=3DNULL,*Iterat=
or=3DNULL,*FrontSplit=3DNULL,*BackSplit=3DNULL;<BR><BR>switch=20
(ClassifyPoly(&amp;PlaneArray[NodeArray[Node].Plane],(POLYGON=20
*)Portal))<BR>{<BR><BR></CODE>We will call ClipPortal initially from out =

BuildPortals function (which we will look at later) and pass in the=20
InitialPortal we created by calling 'CalculateInitialPortal'. We will =
also pass=20
in a value of Zero because we want the clipping to start for the portal =
at the=20
Root node of the BSP Tree. Next we do something you should be very =
familiar with=20
by now, we classify the Portal against the Node Plane. Notice above that =
because=20
the first part of our PORTAL structure is the same as our POLYGON =
structure we=20
can safely cast the PORTAL to type POLYGON to save have to re write the=20
functions to deal with portals. The Rest of the function simply is =
divided into=20
four 'Case' blocks for our switch statement with instructions on what to =
do if=20
the Portal is CP_FRONT,CP_BACK,CP_SPANNING or CP_ONPLANE. We will look =
at these=20
cases one at a time starting with CP_FRONT. Also it may help to refer =
back to=20
Diagrams K through P while reading the code as this is where we showed =
the=20
Portal being clipped Graphically which may help you picture it in your =
head.=20
<BR><BR><U><FONT size=3D4><FONT =
color=3Dblue>CP_FRONT</FONT></FONT></U><BR><BR>If=20
the Portal is to the Front of the Node then we have two possible courses =
of=20
action. If there IS a front Node (IsLeaf=3D=3D0) then we simply call =
this function=20
again recursively using the 'Front' Node to send the Portal down the =
Front Tree.=20
The function will return a list of Portal Fragments that survived the =
front tree=20
in a linked list which we point to using 'PortalList'.The function may =
return=20
'NULL' if nothing of this portal survives the recursive clipping =
process.We then=20
'Return' this Linked List from the function.<BR>However if there is a =
Leaf to=20
the front of this node (IsLeaf!=3D0) then the portal has made it to a =
leaf (empty=20
space) and has finished its journey in this part of the tree. We record =
in the=20
Portal Structures 'LeafOwnerArray' the Index of the leaf it has landed =
in and=20
also increment the Portals 'NumberOfLeafs' variable so that we can keep =
track of=20
how many leafs it lands in. Remember that Portals that only end up in =
one Leaf=20
at the end will be removed because they are not Valid Portals. Portals =
Must end=20
up in two leafs. <BR><BR>After we have recorded the leaf information in =
the=20
Portal we simply Return the Portal.<BR><BR><CODE><FONT size=3D2>case =
CP_FRONT:=20
<BR><BR>if (NodeArray[Node].IsLeaf=3D=3D0)<BR>// Not a Leaf=20
{<BR>PortalList=3DClipPortal(NodeArray[Node].Front,Portal);<BR>return =
PortalList;=20
<BR>}<BR>else // Is a=20
Leaf<BR>{<BR>Portal-&gt;LeafOwnerArray[Portal-&gt;NumberOfLeafs]=3DNodeAr=
ray[Node].Front;<BR>Portal-&gt;NumberOfLeafs++;<BR>Portal-&gt;Next=3DNULL=
;<BR>Portal-&gt;Prev=3DNULL;<BR>return=20
Portal;<BR>}<BR><BR>break;<BR><BR></FONT></CODE>Phew that was nice and =
easy.=20
Luckily the CP_BACK case is equally as stress free.<BR><BR><U><FONT =
size=3D4><FONT=20
color=3Dblue>CP_BACK</FONT></FONT></U><BR><BR>In order to send the =
Portal down the=20
Back tree we first have to check a Back tree actually exists.If it does =
then we=20
send the portal down the Back tree by calling the 'ClipPortal' function =
again=20
with the New Back Node.The function will return a Linked List of portal=20
fragments that survive the tree or 'NULL' if none nothing of this Portal =

survives.We then return this Linked list .<BR>If there is no Back tree =
however=20
it means that this portal has ended up in solid space and so can not =
possibly be=20
a Portal.In that case we delete the portal and return 'NULL' . This =
Portal has=20
died. (RIP my young portal friend).<BR><BR><CODE><FONT size=3D2>case=20
CP_BACK:<BR>if (NodeArray[Node].Back!=3D-1)// another Node=20
exists<BR>{<BR>PortalList=3DClipPortal(NodeArray[Node].Back,Portal);<BR>r=
eturn=20
PortalList;<BR>}<BR>else// were are in solid space<BR>{<BR>DeletePortal =
(=20
Portal);<BR>return NULL; <BR>}<BR>break;<BR><BR></FONT></CODE>So as you =
can see=20
if a portal (or more likely a portal fragment) end up in the Front or =
Back=20
'case' it is either passed down the front or back of the tree,deleted or =

returned having had its Leaf information saved. It is not very likely =
that our=20
Initial Portal will ever fall into these two cases because it is very =
large and=20
will be spanning several polygons.The next 'case' (CP_SPANNING) is the =
code that=20
is responsible for splitting the Portals into fragments and sending each =

Fragment down the tree keeping track of which fragments survive and =
returning=20
all the fragments from the function in a Linked List.<BR><BR><U><FONT =
color=3Dblue=20
size=3D4>CP_SPANNING:</FONT></U><BR><BR>If the Portal is Spanning the =
Node Plane=20
then we have to split the portal into two fragments.We also want to =
remove the=20
parent portal because it is no longer needed. As with splitting the =
Polygons in=20
our BSP Compiler Child Portal Splits also retain the information of the =
parent=20
that created them.Remember the parent portal may have already been =
recorded as=20
having been in a leaf which means the Child Splits have also been in =
that leaf=20
because they were part of the Parent at the time. In order to do this we =
simply=20
have to copy over the Parent 'LeafOwnerArray' and 'NumberOfLeafs' fields =
into=20
both the Child Split portals before we delete the Parent=20
portal.<BR><BR><CODE>case CP_SPANNING:<BR><BR>FrontSplit=3Dnew=20
PORTAL;<BR>BackSplit=3Dnew=20
PORTAL;<BR>ZeroMemory(FrontSplit,sizeof(PORTAL));<BR>ZeroMemory(BackSplit=
,sizeof(PORTAL));<BR><BR>SplitPortal(Portal,&amp;PlaneArray[NodeArray[Nod=
e].Plane],FrontSplit,BackSplit);<BR>DeletePortal=20
(Portal);<BR><BR></CODE>You can see above that we create two new Portals =

'FrontSplit' and 'BackSplit' and pass them into the 'SplitPortal' =
function to be=20
filled.The parent Portal is then deleted.<BR><BR>The 'SplitPortal' =
function is=20
just a wrapper function that calls 'SplitPolygon' and then copies over =
the=20
additional Portal information ('LeafOwnerArray' &amp; 'NumberOfLeafs') =
into the=20
Child Splits as mentioned above.<BR><BR>We now have two Portals to =
process from=20
here, 'FrontSplit' and 'BackSplit'.We deal with them one at a time. So =
first we=20
deal with the Front Split.<BR><BR><CODE>if =
(NodeArray[Node].IsLeaf=3D=3D0)//There is=20
another Front=20
NODE<BR>{<BR>FrontPortalList=3DClipPortal(NodeArray[Node].Front,FrontSpli=
t);<BR>}<BR>else//=20
Its about to get pushed into a=20
Leaf<BR>{<BR>FrontSplit-&gt;LeafOwnerArray[FrontSplit-&gt;NumberOfLeafs]=3D=
NodeArray[Node].Front;<BR>FrontSplit-&gt;NumberOfLeafs++;<BR>FrontSplit-&=
gt;Prev=3DNULL;<BR>FrontSplit-&gt;Next=3DNULL;<BR>FrontPortalList=3DFront=
Split;<BR>}<BR><BR></CODE>This=20
should look a bit familiar to you by now.The first thing we have to do =
is send=20
the Front Split down the Front Tree of the Current Node if a Front Tree=20
exists.If not then the Front Split has ended up in a Leaf so we record =
in the=20
Portal which leaf it has ended up in.The idea is that we will send the =
Front=20
Split down the Front Tree and get returned a Linked List of fragments =
that=20
Survived the Front Tree. A pointer to these fragments is returned and =
stored in=20
'FrontPortalList'. You can see that if the Front Split end up in a Leaf =
then we=20
simply set 'FrontPortalList' to point at the Front Split portal because =
this is=20
obviously the only Portal in the front because it will not get clipped =
into any=20
more fragments.If however there is Front Tree to send the Front Split =
down then=20
'FrontPortalList' will contain either the Fragments of the Front Split =
that=20
survived or NULL if nothing of the Front Split survived the Front Tree =
(totally=20
Clipped Away). <BR><BR>Our next task is now to do the same with the Back =
Split=20
and send that down the Back Tree if one exists storing a pointer to the =
returned=20
fragments in 'BackPortalList' or delete Back Split completely if there =
is no=20
Back tree (Back=3D=3D-1) because the entire Back Split must be solid=20
space.<BR><BR><CODE>if (NodeArray[Node].Back!=3D-1)=20
<BR>{<BR>BackPortalList=3DClipPortal(NodeArray[Node].Back,BackSplit);<BR>=
}<BR>else=20
// in solid space so delete<BR>{ <BR>DeletePortal (=20
BackSplit);<BR>}<BR><BR></CODE>As you can see above, if there is a back =
tree we=20
get either the Portal Fragments of the Back Split returned in =
BackPortalList or=20
NULL if nothing of the Back Split survived.Else if there is no back tree =
this=20
means the Back Split is in solid space and there for is completely =
removed=20
(clipped out).<BR><BR>At this point we now have a possible two linked =
lists, one=20
containing the Fragments of the Front Split that survived and one =
containing the=20
Fragments of the Back Split that survived. What we now have to do is =
link these=20
two linked lists together into one main linked list that will be =
returned from=20
the function containing ALL (both front and back) fragments that have =
survived.=20
<BR><BR><CODE><FONT size=3D2>if=20
(FrontPortalList!=3DNULL)<BR>{<BR>Iterator=3DFrontPortalList;<BR>while=20
(Iterator-&gt;Next!=3DNULL)<BR>{<BR>Iterator=3DIterator-&gt;Next;<BR>}<BR=
>if=20
(BackPortalList!=3DNULL)<BR>{<BR>Iterator-&gt;Next=3DBackPortalList;<BR>B=
ackPortalList-&gt;Prev=3DIterator;<BR>}<BR>return=20
FrontPortalList;<BR>}//something in the front list <BR><BR>else =
////There is=20
nothing in the front list<BR><BR>{<BR>if (BackPortalList!=3DNULL) return =

BackPortalList;<BR>return NULL;<BR>}<BR><BR>return=20
NULL;<BR>break;<BR><BR></FONT></CODE>All we do above is attach the=20
'BackPointerList' to the end of the 'FrontPortalList'.First we check if =
there=20
are any fragments in the Front Portal List. If there is then we find the =
last=20
fragment in the front list and if there are fragments in the back list =
we attach=20
the last portal in the Front List to the Back list.In other words, =
instead of=20
the last portal in the front list haveing its 'Next' pointer set to null =
we now=20
set the 'Next' pointer to point at the Back List.We have now merged the =
lists in=20
to one large one.Obviously if there are no portals in the back List then =
just=20
Front List is returned.<BR>If there are no portals in front list then we =
just=20
return back list. All Done.<BR><BR>Sometimes it can be hard to picture =
recursive=20
function in your head but try and imagine the cascade effect of this =
splitting=20
and merging lists as we progress down the tree. I have drawn a diagram =
(Figure=20
R) that shows this splitting and merging in a simply 3 Node four leaf =
set=20
up.<BR><BR>
<CENTER><IMG height=3D500=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsr.gif"=20
width=3D449> </CENTER><BR><BR>Above we send in the initial portal into =
the=20
'ClipPortal' function at Node 0.The portal is spanning the plane so is =
split=20
into Front and Back.Lets process the front List.The front split is sent =
down to=20
Node 1 which it is also spanning so is split once again into Front and =
Back=20
Splits and sent down the Front and Back tree respectively.Both the Front =
and=20
Back Splits of N1 end up in Leafs so are returned back to Node 1 where=20
'FrontPortalList' contains one portal and the BackPortalList' contains =
one=20
Portal.These two lists are merged into one so that the list contains =
BOTH=20
Portals and is returned from Node 1's function back to Node 0 =
function.At Node 0=20
we now have a front list containing two portal fragment.Now we process =
Node 0's=20
Back Split which in the above diagram take a similar path. , being split =
again=20
at Node 2 with both Node2's Front and Back splits ending up in =
leafs.These Leaf=20
portals are returned to Node 2 where they are merged into one list and =
returned=20
back to Node 0. Node 0 now has a FrontPortalList containing two =
fragments and a=20
BackPortalList containing two fragments.These are merged into one list =
that=20
contains four fragments and the funtion returns back to the function =
that called=20
'ClipPortal' with the Portal Fragments List.<BR><BR>In the above example =
all=20
fragments ended up in leafs but you should be able to see that if at any =
point a=20
fragment ended in sold space it would be removed.For example if Leaf =
4(L4) was=20
not there and in fact solid space was there then Node 2's BackPortalList =
would=20
be NULL and the Front portal List would contain one polygon.In this case =
the=20
Front Portal List of Node 2 would be returned to Node 0.Node 0 then =
would only=20
have one portal in its Back Portal List.The final list merged at Node 0 =
then=20
would only contain three portal fragments.<BR><BR>I would just like to =
say that=20
the Diagram is a little inaccurate because obviously there is not such =
thing as=20
a Back Leaf in our solid Node tree.It was just to prove a point on how =
lists get=20
merged.In a real Solid Leaf Tree, Leaf L4 would be a Front Leaf attached =
to an=20
intermediate Node where L4 currently is.<BR><BR>Study the diagram and =
read the=20
text again a few more times and it should start becoming clear to you. =
The=20
'Splitting Case' in this function is the main part of the code and is =
solely=20
responsible for clipping the portals into fragments and returning the=20
Fragments.<BR><BR>We do however have one more case to consider in our=20
'ClipPortal' function and that is probably the nastiest 'case' of =
all.The=20
ON_PLANE case. <BR><BR><U><FONT size=3D4><FONT=20
color=3Dblue>CP_ONPLANE</FONT></FONT></U><BR><BR>The CP_ONPLANE case is =
very=20
important because without it a portal can not at any point go down both =
sides of=20
the tree.This is needed because if a portal lays between two leafs, one =
leaf=20
will be to the back of the portal and one leaf will be to the =
front.Sending the=20
Portal down BOTH sides of the tree is the only way that a Portal can end =
up in=20
more than one leaf.The code we have seen up to this point mearly sends =
down the=20
Front Tree or the Back tree or Splits that portal and sends the Front or =
Back=20
split down the relative trees. In other words they clip and push the =
portal=20
until it pops out in a leaf (one leaf) and then returns.We know for a =
fact that=20
a Portal must exist down its Front and Back tree (remember that a portal =
was=20
created from a NODE plane and so is on that plane) if it is to be a =
valid portal=20
because it must exist in a leaf each side of the Node Plane it was =
created from.=20
To picture this better in your head imagine Two rooms with a doorway in =
between=20
them.The Node that the dorrway is on has a leaf (room) to each side of=20
it.Therefore when we create a portal on that node (for the doorway) we =
can only=20
record which leafs the portal lands in by testing the Front AND the back =
of the=20
doorway.We would send the Portal down the front of the doorway and say =
"Yes this=20
portal is in room 1" and then send it down the back of the dorway and =
say "yes=20
this portal is also in room 2", in other words we have just figured out =
that the=20
doorway portal connects rooms 1 and 2.<BR><BR>In order to do this we =
have to=20
first of all send the portal down the front tree where we will get =
returned any=20
Portal Fragments that have survived the font tree.At this point the =
ON_PLANE=20
case has been no different from the CP_SPANNING case .The difference is =
though,=20
with the CP_SPANNING case we created a List for the Front Split and the =
Back=20
Split and then merged them together.Up until this point though the Front =
and=20
Back lists had been seperate (Front Split and Back Split were two =
speperate=20
portals). With CP_ONPLANE we have to clip the SAME portals down BOTH =
sides of=20
the tree, so we once we have our Front Portal List we have to send EACH =
portal=20
in that Front List down the back Tree and Clip each one to the back Back =
Tree.=20
In other words, we send the initial portal down the Front Tree and get =
back a=20
list of fragments that survived.We then send each fragment in this list =
down the=20
Back tree also so the any fragment that survives has been clipped to =
both=20
trees.<BR><BR>This sounds quite horrible doesnt it but in fact it's not =
that=20
bad.The Nasty bit is that we first get a List of Front Portal Fragments =
and then=20
Send each Fragment down the back tree which can get split into more =
fragments.So=20
we get Fragment lists returned for each fragment aaaAARRHGGGH. Lets have =
a look=20
at the code anyway.<BR><BR><CODE>case CP_ONPLANE:<BR><BR>if=20
(NodeArray[Node].IsLeaf!=3D0) // this is a Leaf Node<BR>{=20
<BR>Portal-&gt;LeafOwnerArray[Portal-&gt;NumberOfLeafs]=3DNodeArray[Node]=
.Front;<BR>Portal-&gt;NumberOfLeafs++;<BR>Portal-&gt;Next=3DNULL;<BR>Port=
al-&gt;Prev=3DNULL;<BR>FrontPortalList=3DPortal;=20
<BR>}<BR>else<BR>{<BR>FrontPortalList=3DClipPortal(NodeArray[Node].Front,=
Portal);<BR>}<BR><BR>if=20
(FrontPortalList=3D=3DNULL) return NULL;<BR>if =
(NodeArray[Node].Back=3D=3D-1) return=20
FrontPortalList;<BR></CODE><BR><BR>Well there is nothing new to us so =
far. If=20
the Portal is on the plane we have to send it down the Front Tree first =
to get=20
returned back a list of portal fragments that have been clipped to the =
front=20
tree.However if there is no front tree (IsLeaf!=3D0) then there is a =
leaf to the=20
front of this node so we simply record in the portal which leaf number =
it has=20
landed in.This means no clipping will take place down the front tree so =
this=20
portal will not get split into fragments so we simply set =
'PortalFrontList' to=20
point at this portal.<BR>If there is a Front Tree however we send the =
portal=20
down the front tree and get returned a list of portal fragments that =
have=20
survived the front tree or NULL if nothing of the portal =
survived.<BR><BR>We can=20
now check 'FrontPortalList' because if it is NULL then there is no point =

continuing because this can not be a portal if it does not survive the =
front=20
tree so we just return null. Also if this node does not have a back tree =
we just=20
return the front portal list.You are probably thinking that if there is =
no back=20
tree then this can not be a portal and thats what I thought at first as =
well.You=20
must remember though that the solid leaf tree is compiled in such a way =
polygons=20
sharing the plane and facing the same way as the Split Plane are placed =
in the=20
Nodes Front tree.Therefore we can only be certain that it is not a valid =
portal=20
if it does not survive the Front Tree. This means we may return some =
portals=20
that only exist in one leaf and are not valid portals but they will be =
taken out=20
later on once the portal list is returned.Remember that the 'ClipPortal' =

function will have been called by the 'BuildPortals' function which we =
have not=20
looked at yet but will in a moment. The 'BuildPortals' function will =
check=20
through the List of portals returned by 'ClipPortal' and remove any =
portals that=20
do not exist in two leafs.<BR><BR>Ok then, so if we have made it to here =
it=20
means we have at least one but perhaps many fragments in our Front =
Portal=20
List.It also means that there is a back tree or otherwise we would have =
just=20
returned 'FrontPortalList'. So what we have to do now is is step through =
each=20
Fragment in 'FrontPortalList' and send it down the Back tree of this =
node.This=20
will in turn send back a list of Fragments (for EACH fragment in the =
Front List)=20
that survived the Back tree. <BR><BR><CODE>while =
(FrontPortalList!=3DNULL)<BR>{=20
<BR>PORTAL *tempnext=3DFrontPortalList-&gt;Next;=20
BackPortalList=3DNULL;<BR>BackPortalList=3DClipPortal(NodeArray[Node].Bac=
k,FrontPortalList);//=20
fragment this fragment into the back tree<BR><BR></CODE>So we start a =
while loop=20
to step through each Portal (Fragment) in PortalFrontList.Each time =
through the=20
loop we store in 'tempnext' a pointer to the Next Portal in =
FrontPortalList=20
because the current portal will be getting sent down the back tree and =
possibly=20
deleted which means when the function returns FrontPortalList could be =
NULL so=20
'FrontPortalList-&gt;Next' would hold complete gibberish and we would =
loose a=20
way to step though the list.As you can see above we send the Current =
Fragment=20
(pointed to by 'FrontPortalList' down the back tree and store a pointer =
to the=20
list of Fragments that have survived in 'BackPortalList'. =
'BackPortalList' will=20
be NULL if nothing of the Current Front List fragment survived the=20
tree.<BR><BR>If there are some portals that have survived this fragment =
(and=20
this iteration of the while) then we get the Last Fragment in the list =
and=20
attach it to our master portal list 'PortalList'. Remember that =
'BackPortlist'=20
will contain each loop the Fragments that have survived for the current =
fragment=20
that was in the Front list. Any portals that have been returned in=20
BackPortalList each time through the whole loop are added to =
'PortalList' at the=20
end of each loop so that when we exit the loop 'PortalList' will contain =
a=20
Linked List of ALL the Fragments that survived the front and back trees =
for each=20
loop. So below is the very last section of the Clip Portal=20
function.<BR><BR><CODE>if=20
(BackPortalList!=3DNULL)<BR>{<BR>Iterator=3DBackPortalList;<BR>while=20
(Iterator-&gt;Next!=3DNULL)<BR>{<BR>Iterator=3DIterator-&gt;Next;<BR>}<BR=
><BR>//=20
attach the last fragment to the first fragment from a previos=20
loop.<BR><BR>Iterator-&gt;Next=3DPortalList;<BR>if=20
(PortalList!=3DNULL)<BR>{<BR>PortalList-&gt;Prev=3DIterator;<BR>}<BR>Port=
alList=3DBackPortalList;=20
// portal List now points at the current complete list of fragment =
collected=20
from each loop<BR>}<BR><BR>FrontPortalList=3Dtempnext;<BR>}<BR>return=20
PortalList;<BR>// ALL DONE<BR>break;<BR><BR></CODE>Well admittedly that =
function=20
can fry your brain a little bit first time through but if you are =
comfortable=20
with recursion then there is nothing here very different from any other=20
recursive function. Its good to try and and do a dry run in your head =
and=20
following the code imagine the root a portal might take.Anyway, to give =
you a=20
much better view of the function I will now show you it in its complete =
form.I=20
have colored the different section to make easier reading. =
<BR><BR><CODE><FONT=20
size=3D2>PORTAL * ClipPortal(long Node,PORTAL *Portal)<BR>{<BR>PORTAL=20
*PortalList=3DNULL,*FrontPortalList=3DNULL,*BackPortalList=3DNULL,*Iterat=
or=3DNULL,*FrontSplit=3DNULL,*BackSplit=3DNULL;<BR>switch=20
(ClassifyPoly(&amp;PlaneArray[NodeArray[Node].Plane],(POLYGON=20
*)Portal))<BR>{<BR><BR><FONT color=3Dgreen>case CP_ONPLANE: Send down =
Both=20
Trees<BR>if (NodeArray[Node].IsLeaf!=3D0) // this is a Leaf Node<BR>{ =
<BR>// The=20
Front is a=20
Leaf<BR>Portal-&gt;LeafOwnerArray[Portal-&gt;NumberOfLeafs]=3DNodeArray[N=
ode].Front;<BR>Portal-&gt;NumberOfLeafs++;<BR>Portal-&gt;Next=3DNULL;<BR>=
Portal-&gt;Prev=3DNULL;<BR>FrontPortalList=3DPortal;=20
<BR>}<BR>else<BR>{<BR>// Send the Portal Down the Front List and get =
returned a=20
list of PortalFragments that survived the Front=20
Tree<BR>FrontPortalList=3DClipPortal(NodeArray[Node].Front,Portal);<BR>}<=
BR><BR>//=20
Then send each fragment down the back tree.<BR>if =
(FrontPortalList=3D=3DNULL) return=20
NULL;<BR>if (NodeArray[Node].Back=3D=3D-1) return FrontPortalList; =
<BR><BR>while=20
(FrontPortalList!=3DNULL)<BR>{ <BR>PORTAL=20
*tempnext=3DFrontPortalList-&gt;Next;<BR>BackPortalList=3DNULL;<BR>BackPo=
rtalList=3DClipPortal(NodeArray[Node].Back,FrontPortalList);<BR><BR>if=20
(BackPortalList!=3DNULL)<BR>{<BR>Iterator=3DBackPortalList;<BR>while=20
(Iterator-&gt;Next!=3DNULL)<BR>{<BR>Iterator=3DIterator-&gt;Next;<BR>}<BR=
>// attach=20
the last fragment to the first fragment from a previos loop.=20
Iterator-&gt;Next=3DPortalList;<BR>if=20
(PortalList!=3DNULL)<BR>{<BR>PortalList-&gt;Prev=3DIterator;<BR>}<BR>Port=
alList=3DBackPortalList;=20
// portal List now points at the current complete list of fragment =
collected=20
from each loop<BR>}<BR><BR>FrontPortalList=3Dtempnext;<BR>}<BR>return=20
PortalList;<BR>break;<BR></FONT><BR><BR><FONT color=3Dred>case CP_FRONT: =
// Either=20
send it down the front tree or add it to the portal list because it has =
come out=20
//Empty Space<BR><BR>if=20
(NodeArray[Node].IsLeaf=3D=3D0)<BR>{<BR>PortalList=3DClipPortal(NodeArray=
[Node].Front,Portal);<BR>return=20
PortalList;<BR>}<BR>else // The Front Node is a Empty Leaf so Add it to =
the=20
Portal=20
List<BR>{<BR>Portal-&gt;LeafOwnerArray[Portal-&gt;NumberOfLeafs]=3DNodeAr=
ray[Node].Front;<BR>Portal-&gt;NumberOfLeafs++;<BR>Portal-&gt;Next=3DNULL=
;<BR>Portal-&gt;Prev=3DNULL;<BR>return=20
Portal;<BR>}<BR>break;<BR><BR><BR></FONT><FONT color=3Dgray>case =
CP_BACK:// either=20
asend it downthe back tree or Delete it if no back tree exists<BR><BR>if =

(NodeArray[Node].Back!=3D-1)<BR>{<BR>PortalList=3DClipPortal(NodeArray[No=
de].Back,Portal);<BR>return=20
PortalList;<BR>}<BR>else<BR>{<BR>DeletePortal ( Portal);<BR>return =
NULL;<BR>}=20
break;<BR><BR></FONT><BR><FONT color=3Dblue>case=20
CP_SPANNING:<BR><BR>FrontSplit=3Dnew PORTAL;<BR>BackSplit=3Dnew=20
PORTAL;<BR>ZeroMemory(FrontSplit,sizeof(PORTAL));<BR>ZeroMemory(BackSplit=
,sizeof(PORTAL));<BR>SplitPortal(Portal,&amp;PlaneArray[NodeArray[Node].P=
lane],FrontSplit,BackSplit);<BR>DeletePortal=20
(Portal);<BR>if=20
(NodeArray[Node].IsLeaf=3D=3D0)<BR>{<BR>FrontPortalList=3DClipPortal(Node=
Array[Node].Front,FrontSplit);<BR>}<BR>else//=20
Its about to get pushed into a=20
Leaf<BR>{<BR>FrontSplit-&gt;LeafOwnerArray[FrontSplit-&gt;NumberOfLeafs]=3D=
NodeArray[Node].Front;<BR>FrontSplit-&gt;NumberOfLeafs++;<BR>FrontSplit-&=
gt;Prev=3DNULL;<BR>FrontSplit-&gt;Next=3DNULL;<BR>FrontPortalList=3DFront=
Split;<BR>}<BR><BR>if=20
(NodeArray[Node].Back!=3D-1) // the backsplit is in solid=20
space<BR>{<BR>BackPortalList=3DClipPortal(NodeArray[Node].Back,BackSplit)=
;<BR>}<BR>else=20
// delete it its in solid space<BR>{ <BR>DeletePortal ( =
BackSplit);<BR>}<BR>if=20
(FrontPortalList!=3DNULL)// Find the End of the list and attach it to =
Front Back=20
List<BR>{<BR>Iterator=3DFrontPortalList;<BR>while=20
(Iterator-&gt;Next!=3DNULL)<BR>{<BR>Iterator=3DIterator-&gt;Next;<BR>}<BR=
>if=20
(BackPortalList!=3DNULL)<BR>{<BR>Iterator-&gt;Next=3DBackPortalList;<BR>B=
ackPortalList-&gt;Prev=3DIterator;<BR>}<BR>return=20
FrontPortalList;<BR>}// there is something in the front list<BR><BR>else =

////There is nothing in the front list<BR>{<BR>if =
(BackPortalList!=3DNULL) return=20
BackPortalList;<BR>return NULL;<BR>}<BR><BR><BR>return=20
NULL;<BR>break;<BR></FONT><BR>default:<BR>return NULL;<BR>break;<BR>} =
//end=20
switch<BR>return NULL;<BR>}<BR><BR></FONT></CODE>Well I have to say that =
if you=20
have understood everything up until now then its all gonna get a little =
bit=20
easier from here on in.In my opinion 'Portal Generation' is the hardest =
thing to=20
grasp and also rather hard to explain or even to show on paper for that=20
matter.Well I did mention earlier when we were looking at the =
CP_SPANNING case=20
of the above function that it uses a function called 'SplitPortal' to =
wrap the=20
'SplitPolygon' function call and also copy over the extra portal =
information=20
over from the parent about to be split into the two child splits.This=20
information that had to be retained was mainly just what leafs the =
Portal the=20
parent had landed in up to that point.I will just show you the =
'SplitPortal'=20
function for completeness.<BR><BR><CODE><CODE>void SplitPortal(PORTAL=20
*Portal,PLANE *Plane,PORTAL *FrontSplit,PORTAL=20
*BackSplit)<BR>{<BR>SplitPolygon((POLYGON *)Portal,Plane,(POLYGON=20
*)FrontSplit,(POLYGON=20
*)BackSplit);<BR>FrontSplit-&gt;NumberOfLeafs=3DPortal-&gt;NumberOfLeafs;=
<BR>BackSplit-&gt;NumberOfLeafs=3DPortal-&gt;NumberOfLeafs;<BR>memcpy(Fro=
ntSplit-&gt;LeafOwnerArray,Portal-&gt;LeafOwnerArray,sizeof(long)*Portal-=
&gt;NumberOfLeafs);<BR>memcpy(BackSplit-&gt;LeafOwnerArray,Portal-&gt;Lea=
fOwnerArray,sizeof(long)*Portal-&gt;NumberOfLeafs);<BR>}<BR><BR></CODE></=
CODE><BR><BR>Ok=20
well we have looked at the 'CalculateInitialPortal' function that =
creates the=20
first Large portal on the Planes and we have had a look at the =
'ClipPortal'=20
function that will clip this Initial Portal to the tree and send back a =
List of=20
portals that have survived. Lets now have a look at the function that =
calls both=20
of these functions to actually create the real Master Portal Array that =
will be=20
used for Pre Calculating the PVS. This function is called 'BuildPortals' =
and is=20
the function that is called from our main intializatoin routine =
'InitPolygons'=20
that we saw earlier.Here is the InitPolygons function again just to =
remind=20
you.As you can see from the code below we have already called =
'BuildBspTree' to=20
Compile the Solid Leaf Tree and the next function we have to call (and =
write) is=20
'BuildPortals' to build the Portal set for the tree. When the =
'BuildPortal'=20
function returns the Global portal array 'PortalArray' will hold all the =
Portals=20
for the tree. Unlike the other master arrays (LeafArray,PolygonArray =
etc)=20
PortalArray is actually an array of Pointers to type PORTAL instead of =
being a=20
block of PORTAL structures. <BR><BR><CODE>void =
InitPolygons(void)<BR>{<BR><FONT=20
color=3Dgreen>ReserveInitialMemoryForArrays();<BR><BR>PolygonList=3DNULL;=
<BR>PolygonList=3DLoadMWM("demolevel.mwm");<BR></FONT>LoadTextures();<BR>=
<BR>BuildBspTree(0,PolygonList);<BR>BuildPortals();<BR>...<BR>...<BR>}<BR=
><BR></CODE>BuildPortals=20
is the main PortalCreation function and the only one that the main =
application=20
has to call to generate the portals for the tree. Its job is to step =
through=20
every Node in our BSP tree and at each Node it calls =
'CreateInitialPortal' to=20
create the Initial Portal for that Node and then Calls 'ClipPortal' to =
send that=20
Portal down the tree. After the call to 'ClipPortal' , our BuildPortals =
function=20
will then have a list of Portal Fragments for the Current Node.It will =
then Loop=20
through the portal list and remove any Portals that are not in Two =
leafs.This is=20
a simple case of checking the Portals 'NumberOfLeafs' flag to see that =
it is=20
equal to Two.<BR><BR>If the Portal has survived this far we only have =
one more=20
check to make on it before it is accepted.We have to check that a portal =
that=20
bridges the same two Leafs doesnt already exist, if it does we compare =
the sizes=20
and keep the largest one whether that be the new portal or the portal =
already in=20
the Master Portal Array. The reason for having to do this may not be =
immediately=20
obvious, it certainly wasnt to me which is why I spent two days =
continually=20
rebooting my machine everytime it crashed during PVS calculation. Let it =
just be=20
known for now that it is possible for bit of a Portal from one Node to =
spill=20
over into another node so that you may have two portals both occupying =
the same=20
space and both existing in the same two leafs.We simply compare the =
sizes of our=20
new portal with the one that already exists and keep the largest one.The =
largest=20
one will always be the correct size where as the smaller one is just a =
peice of=20
a fragment from another node that has found itself occupying the same =
space as=20
our portal but not bridging the gap between the two leafs completely.=20
<BR><BR>This code may look a little strange in the fact that it used a =
few=20
'GOTO' comands(ouch).Sorry but the job of this function was to recurse =
the tree,=20
the problem though is that while recursing the tree this function calls=20
'ClipPortal' which also Recurses the tree. Recursing the Tree While =
recursing=20
the tree is a sure to get us a STACK OVERFLOW on even a moderately sized =
level=20
so I was forced to write the BuildPortal function without =
Recursion.Instead of=20
the function recursively calling itself as we have done up till now with =
all=20
tree traversal function, this function traverses the BSP tree without =
using=20
recursion.This way the tree will only be getting recursed once each loop =
by the=20
call to 'ClipPortals'.<BR><BR>In order to traverse the tree I have =
simulated the=20
stack by allocating an array of NODESTACK structures. The NODESTACK =
structure I=20
have defined like this:- <BR><BR><CODE>struct NODESTACK<BR>{<BR>long=20
Node;<BR>BYTE JumpBackPoint;<BR>};<BR><BR></CODE>Everytime we have to =
traverse=20
the tree we will record the current node we are using and also were we =
have come=20
from so that we can jump back that point.This is basically just =
simulting what a=20
C++ function call would do.If you are half way through 'Function 1' and =
you call=20
'Function 2' the current Variables and line that is currently being =
executed in=20
'Function 1' is saved on the stack.When function two returns the =
computer can=20
return to function one at the same place it left off by popping the =
information=20
back off the stack so that the execution of 'Function 1' can again =
resume from=20
where it left off before 'Function 2' was called.<BR>Here is the code a =
bit at a=20
time.It uses a few support function which we will examine=20
after.<BR><BR><CODE>void BuildPortals(void)<BR>{<BR>long=20
stackpointer=3D0;<BR>NODESTACK *NodeStack=3Dnew =
NODESTACK[NumberOfNodes+1]<BR>int=20
portalindex;<BR>NodeStack[stackpointer].Node=3D0;// root=20
node<BR>NodeStack[stackpointer].JumpBackPoint=3D0;<BR><BR></CODE>Above =
is the code=20
that sets up our Stack. The variable 'stackpointer' is set to zero =
because this=20
will be the Node that we start off with.You can see that after we have =
safely=20
allocated enough memory to hold more than enough nodes we fill in the =
current=20
NodeStack position with the Node we are going to start with (Node 0).=20
JumpBackPoint is set to zero meaning there is no jump back point for the =
first=20
node.Once Node 0 is done it is time to Return from the function because =
the=20
whole tree will have been traversed so this is why we just set the jump =
back=20
point to zero.<BR>Next we start the Traversal bit of the function.This =
is the=20
bit that will actually simulate the Recursion with the label 'START:' =
being the=20
entry point every time we traverse to a new node.=20
<BR><BR><CODE>START:<BR><BR>PORTAL=20
*InitialPortal=3DCalculateInitialPortal(NodeStack[stackpointer].Node);<BR=
>PORTAL=20
*PortalList=3DClipPortal(0,InitialPortal);<BR></CODE><BR>As you can see =
the first=20
thing we do is call the 'CalculateInitialPortal' function to create the =
initial=20
portal for the current node (the index of the node is stored in the=20
NodeStack[stackpointer].Node) and then pass the returned Portal into the =

'ClipPortal' function specifying '0' meaning send it down the root of =
the tree=20
(begin at node '0').After the function returns 'PortalList' will contain =
a=20
Linked List of portals that have survived the tree.<BR>Our next task is =
to step=20
through each portal in the tree and carry out some tests to check =
whether it is=20
a valid portal or not.<BR><BR><CODE>PORTAL *Iterator=3DPortalList; // =
Step through=20
the Portal List</CODE><BR><BR><CODE>while (Iterator!=3DNULL) <BR>{<BR>if =

(Iterator-&gt;NumberOfLeafs!=3D2)// not in two leafs so =
delete<BR>{<BR>PORTAL=20
*temp=3DIterator-&gt;Next;<BR>RemovePortalFromList(Iterator);<BR>Iterator=
=3Dtemp;<BR>}<BR></CODE><BR>We=20
use a temporary pointer 'Iterator' to step through the Linked list with =
each=20
iteration of the while loop.The first check we do is to see that the =
portal=20
exists in Two leafs.If it does not then we remove the Portal from memory =
because=20
it is not a real Portal.Above we use support function =
'RemovePortalFromList'=20
which we will see in a minute but it is a simple function to remove an =
element=20
from a linked list while still keeping the integrity of the list in =
tact.We also=20
use temporary pointer 'temp' to store what the next Portal in the list =
will be=20
because after we have deleted 'Iterator' we will not be able to use=20
Iterator-&gt;Next to get it.After that we are done with this iteration =
of the=20
while loop so we loop around again to test the next Portal in the=20
list.<BR><BR>If the Portal does exist in two leafs then we have a real=20
possibility that this is proper portal.So we have to do another check to =
see if=20
a similar portal (a portal that bridges the same two leafs) has already =
been=20
entered into the array.If so then we have to compare the size of this =
new portal=20
with the size of the one already in the array. If our new portal is =
smaller then=20
we just delete it like we did above and we are done for this iteration =
of the=20
while loop. The checking for duplicate portals in the master Portal =
Array is=20
performed by the support function 'CheckDuplicatePortal' which we will =
see in a=20
moment. <BR><BR><CODE>else<BR>{<BR>if=20
(CheckDuplicatePortal(Iterator,&amp;portalindex)=3D=3Dtrue)<BR>{<BR>PORTA=
L=20
*temp=3DIterator-&gt;Next;<BR>RemovePortalFromList(Iterator);<BR>Iterator=
=3Dtemp;<BR>}<BR><BR></CODE>The=20
'CheckDuplicatePortal' array returns 'TRUE' if there is a Portal already =
in the=20
portal array that is larger then the current one we are testing.In other =
words,=20
if it returns true then the portal we are testing is no good and we want =
to=20
delete it. Notice that we pass in the pointer to an INT 'Portalndex'.The =

contents of this int is modified by the 'CheckDuplicatePortals' =
function.If the=20
function returns false it means we DO want to keep this portal and add =
it to the=20
main portal array.'PortalIndex' will hold the index of the entry in the =
array=20
that we need to put this portal.If there is not a duplicate portal then=20
'PortalIndex' will simply hold the next element on the end of the Portal =
Array=20
so we will just be adding a new pointer to the end of the array =
(PortalIndex=20
will equal NumberOfPortals) however, if there is a duplicate portal in =
the array=20
and this new one is bigger then we want to replace the portal that is =
already in=20
the array with this one ,so 'PortalIndex' will hold the position where =
we should=20
place this new portal in the array to replace the one thats already =
there.=20
<BR><BR>If there is Not a duplicate Portal in the array OR if there is =
but this=20
new one is bigger then we have found ourselves a real portal that needs =
to be=20
added to the master Portal Array.Note that at this point the =
'PortalIndex' will=20
hold the index into the master Portal array that this portal needs to be =
places=20
at.<BR><BR><CODE><FONT size=3D2>else<BR>{=20
<BR>PortalArray[portalindex]=3DIterator;<BR>if=20
(portalindex=3D=3DNumberOfPortals)<BR>{<BR>for (int=20
a=3D0;a&gt;Iterator-&lt;NumberOfLeafs;a++)<BR>{<BR>long=20
Index=3DIterator-&gt;LeafOwnerArray[a];<BR>LeafArray[Index].PortalIndexLi=
st[LeafArray[Index].NumberOfPortals]=3DNumberOfPortals;<BR>LeafArray[Inde=
x].NumberOfPortals++;<BR>}<BR>IncreaseNumberOfPortals();<BR>}=20
<BR><BR><BR>Iterator=3DIterator-&gt;Next;<BR>} // if not a duplicate =
portal<BR>}=20
// end else<BR>}// END WHILE LOOP<BR><BR></FONT></CODE>Above concludes =
the main=20
while loop.If we have made it here this portal needs to be added.As we =
have said=20
'PortalIndex' holds the position in the master Portal Array where this =
portal=20
should be added.If 'PortalIndex=3D=3DNumberOfPortals' however it means =
we are NOT=20
simply replacing a portal that is already there but are adding a new one =
to the=20
end of the array.We then loop through this portals 'LeafOwnerArray' to =
gain=20
access to the Two leafs this portal is in and then record this portals =
index=20
number in the array in the Leaf Structures 'PortalIndexList' array and =
increase=20
the Leafs portal count 'Leaf.NumberOfPortals'. This means we now have in =
the=20
Portal which leafs it exists in and we also have in each leaf a =
reference to=20
this portal.This will come in handy when we calculate the PVS.Remember a =
Leaf=20
could have many portals in it.<BR><BR>After we have added the portal to =
the end=20
we call 'IncreaseNumberOfPortals' which is just another Memory =
Allocation=20
function (like the others we have looked at) that simply re sizes the=20
PortalArray if we have exceeded its current maximum =
capacity.<BR><BR>After that=20
we simply have the code to move to the next fragment in the portal list =
and loop=20
round again.This while loop will continue until all the portals in the =
list have=20
either been added to the master portal array 'PortalArray' or have been=20
rejected. Once the while loop is over it means we are done at this Node =
in the=20
tree .We will now check the Front and Back trees of this node. The above =
while=20
loop will be executed for EVERY node in the tree (wow) .<BR><BR>The last =
bit of=20
code is simply the Tree traversal code that has been written WITHOUT=20
recursion.Normally the following code could be replaced with two lines =
like=20
'BuildPortals(Node Front) and BuildPortals(Node Back) but it looks a =
little ugly=20
now because we have had to get rid of this recursion to stop stack over =
flow on=20
large levels.Below is the code that basically just says 'If ther is a =
Front tree=20
go down it' followed by 'if there is a Back tree go down =
it'<BR><BR><CODE><FONT=20
size=3D2>if=20
(NodeArray[NodeStack[stackpointer].Node].IsLeaf=3D=3D0)<BR>{<BR>NodeStack=
[stackpointer+1].Node=3DNodeArray[NodeStack[stackpointer].Node].Front;<BR=
>NodeStack[stackpointer+1].JumpBackPoint=3D1;<BR>stackpointer++=20
;<BR>goto START;<BR>} <BR><BR>BACK:<BR>if=20
(NodeArray[NodeStack[stackpointer].Node].Back!=3D-1)<BR>{<BR>NodeStack[st=
ackpointer+1].Node=3DNodeArray[NodeStack[stackpointer].Node].Back;<BR>Nod=
eStack[stackpointer+1].JumpBackPoint=3D2;<BR>stackpointer++=20
;<BR>goto START;<BR>}; <BR><BR>END:<BR><BR>stackpointer--;// This is =
like=20
returning from a function<BR>if (stackpointer&gt;-1)<BR>{<BR>if=20
(NodeStack[stackpointer+1].JumpBackPoint=3D=3D1) goto =
BACK;<BR>else<BR>if=20
(NodeStack[stackpointer+1].JumpBackPoint=3D=3D2) goto =
END;<BR>}<BR><BR>delete []=20
NodeStack;<BR>}<BR.<BR> </FONT></CODE>Hopefully you can see what is =
happening=20
here.If there is a Front Node then we put this Front Node in the Next =
Position=20
in the stack array (stackpointer+1) and also store in that stack =
positions=20
'JumpBackPoint' variable a Label Code indicating which label we will =
need to=20
jump back to continue processing the Current Node.When the we get to the =
bottom=20
of the function we simulate a stack by decreasing the Stack pointer so =
we are=20
back at the previous node and jump back to either label =
BACK:(JumpBackPoint=3D1)=20
or label END:(JumpBackPoint=3D2) or we dont jump anywhere and just =
return from the=20
BuildPortals function if (JumpBackPosition=3D0) which should only be =
true for the=20
root node.You can see that if there is a Back node then we do the same =
but place=20
a value of '2' in the JumpBackPoint variable. Unfortunately things look =
a little=20
uglier when we loose the clean looking Rescursive approach but thats =
just=20
something we have to put up with in this case.You can unroll all your =
recursive=20
functions this way and will probably get a speed boost by not using the=20
stack.This is at the expense of some readablility though.If you read =
through the=20
above code and follow the program flow you should see what is happening =
without=20
any problems, we are simply restarting the a loop each time by jumping =
back to=20
the START: label everytime a new node is reached but are storing in the =
stack=20
the current position we are at in the code before the jump.This way, =
when we=20
have dealt with the new node will reach the bottom and will decrease the =

stackpointer variable so we are back at the Node we were at before the =
jump.But=20
we also have to get back to the position in the code we were at before =
the jump=20
which is exactly the purpose of the JumpBackPoint variable.<BR><BR>Well =
that was=20
a crash course on how to get a Recursive Funtion and Un recurse it. =
Thats it for=20
the 'BuildPortals' function, when the function returns the Global array=20
'PortalArray' will hold an array of PORTAL pointers and the Global =
variable=20
'NumberOfPortals' will hold the number of Portal Pointers in that array. =

<BR><BR>Here is the BuildPortals function in its =
entirety:-<BR><BR><CODE>void=20
BuildPortals(void)<BR>{<BR>long stackpointer=3D0;<BR>NODESTACK =
*NodeStack=3Dnew=20
NODESTACK[NumberOfNodes+1]<BR>int=20
portalindex;<BR>NodeStack[stackpointer].Node=3D0;// root=20
node<BR>NodeStack[stackpointer].JumpBackPoint=3D0;<BR><BR></CODE><CODE>ST=
ART:<BR><BR>PORTAL=20
*InitialPortal=3DCalculateInitialPortal(NodeStack[stackpointer].Node);<BR=
>PORTAL=20
*PortalList=3DClipPortal(0,InitialPortal);<BR></CODE><BR><CODE>PORTAL=20
*Iterator=3DPortalList; // Step through the Portal =
List</CODE><BR><BR><CODE>while=20
(Iterator!=3DNULL) <BR>{<BR>if (Iterator-&gt;NumberOfLeafs!=3D2)// not =
in two leafs=20
so delete<BR>{<BR>PORTAL=20
*temp=3DIterator-&gt;Next;<BR>RemovePortalFromList(Iterator);<BR>Iterator=
=3Dtemp;<BR>}<BR></CODE><BR><CODE>else<BR>{<BR>if=20
(CheckDuplicatePortal(Iterator,&amp;portalindex)=3D=3Dtrue)<BR>{<BR>PORTA=
L=20
*temp=3DIterator-&gt;Next;<BR>RemovePortalFromList(Iterator);<BR>Iterator=
=3Dtemp;<BR>}<BR><BR></CODE><CODE><FONT=20
size=3D2>else<BR>{ <BR>PortalArray[portalindex]=3DIterator;<BR>if=20
(portalindex=3D=3DNumberOfPortals)<BR>{<BR>for (int=20
a=3D0;a&gt;Iterator-&lt;NumberOfLeafs;a++)<BR>{<BR>long=20
Index=3DIterator-&gt;LeafOwnerArray[a];<BR>LeafArray[Index].PortalIndexLi=
st[LeafArray[Index].NumberOfPortals]=3DNumberOfPortals;<BR>LeafArray[Inde=
x].NumberOfPortals++;<BR>}<BR>IncreaseNumberOfPortals();<BR>}=20
<BR><BR><BR>Iterator=3DIterator-&gt;Next;<BR>} // if not a duplicate =
portal<BR>}=20
// end else<BR>}// END WHILE LOOP<BR><BR></FONT></CODE><CODE><FONT =
size=3D2>if=20
(NodeArray[NodeStack[stackpointer].Node].IsLeaf=3D=3D0)<BR>{<BR>NodeStack=
[stackpointer+1].Node=3DNodeArray[NodeStack[stackpointer].Node].Front;<BR=
>NodeStack[stackpointer+1].JumpBackPoint=3D1;<BR>stackpointer++=20
;<BR>goto START;<BR>} <BR><BR>BACK:<BR>if=20
(NodeArray[NodeStack[stackpointer].Node].Back!=3D-1)<BR>{<BR>NodeStack[st=
ackpointer+1].Node=3DNodeArray[NodeStack[stackpointer].Node].Back;<BR>Nod=
eStack[stackpointer+1].JumpBackPoint=3D2;<BR>stackpointer++=20
;<BR>goto START;<BR>}; <BR><BR>END:<BR><BR>stackpointer--;// This is =
like=20
returning from a function<BR>if (stackpointer&gt;-1)<BR>{<BR>if=20
(NodeStack[stackpointer+1].JumpBackPoint=3D=3D1) goto =
BACK;<BR>else<BR>if=20
(NodeStack[stackpointer+1].JumpBackPoint=3D=3D2) goto =
END;<BR>}<BR><BR>delete []=20
NodeStack;<BR>}<BR><BR></FONT></CODE><U>
<CENTER><FONT color=3Dgreen>Support function: RemovePortalFromList &amp; =

CheckDuplicatePortal</FONT></CENTER></U><BR><BR>We are now nearly =
finished with=20
Portal Generation but as promised I will just talk about the two support =

functions used by the BuildPortals function.The first support function =
used=20
'RemovePortalFromList' needs no explaining really.It is standard code to =
remove=20
an element from a linked list.In case you are wondering this is why our =
portal=20
also had a 'Prev' pointer , its purpose is just to allow us to remove un =
wanted=20
portals from linked lists easily.The function works by deleting Portal n =

(n=3Dportal you passed in to be deleted) and making Portal =
n-1-&gt;Next=3DPortal n+1=20
and also the same in reverse so that Portal n+1-&gt;Prev=3DPortal-1 =
which=20
therefore unlinks Portal n from the list and then Portal n is deleted. =
Here is=20
the Code to 'RemovePortalFromList' .<BR><BR><CODE><FONT size=3D2>void=20
RemovePortalFromList(PORTAL *RemovePortal)<BR>{<BR>PORTAL=20
*temp=3DRemovePortal;<BR>PORTAL=20
*PrevPortal,*NextPortal;<BR><BR>if(RemovePortal-&gt;Prev!=3DNULL)<BR>{<BR=
>PrevPortal=3DRemovePortal-&gt;Prev;<BR>if=20
(RemovePortal-&gt;Next!=3DNULL)<BR>{<BR>PrevPortal-&gt;Next=3DRemovePorta=
l-&gt;Next;<BR>}<BR>else<BR>{<BR>PrevPortal-&gt;Next=3DNULL;<BR>}<BR>}// =

if there is a prev<BR><BR>if=20
(RemovePortal-&gt;Next!=3DNULL)<BR>{<BR>NextPortal=3DRemovePortal-&gt;Nex=
t;<BR>if=20
(RemovePortal-&gt;Prev!=3DNULL)<BR>{<BR>NextPortal-&gt;Prev=3DRemovePorta=
l-&gt;Prev;<BR>}<BR>else<BR>{<BR>NextPortal-&gt;Prev=3DNULL;<BR>}<BR>}<BR=
>DeletePortal=20
( temp );<BR>}<BR><BR></FONT></CODE>Before we move away from Portal =
Generation=20
we will just have a look at the last support function called by the=20
'BuildPortals' function. Remember that if valid Portal List was returned =
from=20
'ClipPortal' we still had to check that a Portal that connected the same =
two=20
leafs did'nt already exist in the master Portal Array.If one did, then =
the=20
'CheckDuplicatePortal' functions job was to compare the size of the new =
Portal=20
with the one already in the array and discard the smaller one and keep =
the=20
larger one.You may want to take a quick flick back to the 'BuildPortals' =
code=20
just to refresh your self how this function was used.<BR>If you remember =
we=20
passed in a pointer to an 'int' that would be filled with the correct =
position=20
in the array that the new portal should be added.If a duplicate portal =
did not=20
exist in the array then the function returns 'false' and the 'int' =
(called=20
'PortalIndex' in the 'BuildPortals' function) is filled with an an index =
to the=20
end of the array. In otherwords, there is no duplicate portal to be =
replaced so=20
this new portal has to be added to the end of the array.<BR>If a =
duplicate=20
portal does exist but the Portal already in the array is larger than the =
new one=20
then the function returns 'true' and no action is taken except that the =
new=20
portal is deleted.This indicates that no change needs to be performed on =
the=20
master PortalArray because the new Portal is not as large as the one =
already in=20
the array.<BR>If there is a Smaller Portal in the Array than the one we =
are=20
testing then this means we need to replace the old portal already in the =
array=20
with the new one.In this instance the function returns 'false' and =
'PortalIndex'=20
hold the index into the master Portal Array of the Portal that needes to =
be=20
replaced.The 'PortalIndex' is used later on in the Build Portals =
function to=20
actually place the portal in the array at this position. <BR><BR>Here is =
the=20
code to the 'CheckDuplicatePortal' function with explanations every =
couple of=20
lines:-<BR><BR><CODE><FONT size=3D2>bool CheckDuplicatePortal (PORTAL *=20
CheckPortal,int *index)<BR>{<BR>long=20
CheckPortalLeaf1=3DCheckPortal-&gt;LeafOwnerArray[0];<BR>long=20
CheckPortalLeaf2=3DCheckPortal-&gt;LeafOwnerArray[1];<BR><BR></FONT></COD=
E>First=20
get both the leafs that the Portal exists in (this is stored in the =
Portal=20
LeafOwnerArray remember).We will need these leafs to check all the other =
portal=20
in the Portal Array and see if any other Portal exists in the Same two =
leafs.If=20
so then we have found a duplicate portal. <BR><BR><CODE><FONT =
size=3D2>long=20
PALeaf1=3D0;<BR>long PALeaf2=3D0;<BR>for (long=20
i=3D0;i&lt;NumberOfPortals;i++)<BR>{<BR>PALeaf1=3DPortalArray[i]-&gt;Leaf=
OwnerArray[0];<BR>PALeaf2=3DPortalArray[i]-&gt;LeafOwnerArray[1];<BR><BR>=
if=20
((CheckPortalLeaf1=3D=3DPALeaf1 &amp;&amp; =
CheckPortalLeaf2=3D=3DPALeaf2) ||=20
(CheckPortalLeaf1=3D=3DPALeaf2 &amp;&amp;=20
CheckPortalLeaf2=3D=3DPALeaf1))<BR>{<BR><BR></FONT></CODE>Above we loop =
through each=20
portal in the array and get the two leafs that the portal exists in.If =
this=20
Portal exists in the same two leafs as our 'CheckPortal' then we have =
found a=20
match and need to compare sizes as shown below. <BR><BR><CODE><FONT=20
size=3D2>D3DXVECTOR3 =
Max1,Min1,Max2,Min2;<BR><BR>GetPolygonBounds((POLYGON=20
*)CheckPortal,&amp;Min1,&amp;Max1);<BR>GetPolygonBounds((POLYGON=20
*)PortalArray[i],&amp;Min2,&amp;Max2);<BR><BR>float=20
NewSize=3DD3DXVec3Length(&amp;(Max1-Min1));// Measure the Lengths of the =
vector=20
to<BR>// see which is bigger<BR>float=20
OldSize=3DD3DXVec3Length(&amp;(Max2-Min2));<BR><BR></FONT></CODE>Above =
we set up=20
some Vectors that will be used to hold a Bounding Box for the polygon.We =
then=20
call 'GetPolygonBounds' which is a simple helper function that just =
tests each=20
vertex in the polygon and returns a Minimum Point and a Maximum Point =
that=20
bounds the Polygon.We call this function twice to retrieve the Bounding =
Box for=20
both the Portal that we are checking ('CheckPortal') and the one that is =

currently already in the array.<BR>With these two points for each =
polygon we can=20
create a vector (max1-min1) and then call the 'D3DXVec3Length' to return =
the=20
Length (Magnitude) of that vector.This is like measuring the distance =
between=20
the two extreme corners of the bounding box.All we have to do now is =
measure the=20
two Lengths 'OldSize' &amp; 'NewSize' <BR><BR><CODE><FONT size=3D2>if=20
(fabs(NewSize)&gt;fabs(OldSize))<BR>{<BR>PORTAL=20
*temp=3DPortalArray[i];<BR>DeletePortal ( temp =
);<BR>*index=3Di;<BR>return=20
false;<BR>}<BR>else<BR>{ <BR>return true;// This portal is already in =
the=20
array<BR>}<BR>}<BR>}<BR></FONT></CODE>As you can see above if the new =
portal=20
'CheckPortal' is larger than the one already in the array then we delete =
the=20
portal currently in the array and record the index number of the portal =
in the=20
array so that it is returned to the calling function 'BuildPortals' and =
the=20
calling function has an index to place the new portal.The function then =
returns=20
'false' informing the calling function that the Portal passed in to the =
function=20
to be checked is valid and should be added to the array at the position =
held in=20
'index'.<BR>If however,the portal already in the array is larger than =
the=20
function returns 'true' informing the calling function that a larger =
portal=20
already exists so the check portal can be deleted.<BR><BR>If there is no =

duplicate portal found then we end up down here were we simply store the =
current=20
Number of Portals in the index and return false.This tells the calling =
function=20
that the check portal should be kept and added at position (index) which =
is at=20
the end of the array. <BR><BR><CODE><FONT=20
size=3D2>*index=3DNumberOfPortals;<BR>return false;// This portal was =
not found=20
inthe array<BR>}<BR><BR></FONT></CODE>Here is the complete=20
code:-<BR><BR><CODE><FONT size=3D2>bool CheckDuplicatePortal (PORTAL *=20
CheckPortal,int *index)<BR>{<BR>long=20
CheckPortalLeaf1=3DCheckPortal-&gt;LeafOwnerArray[0];<BR>long=20
CheckPortalLeaf2=3DCheckPortal-&gt;LeafOwnerArray[1];<BR>long =
PALeaf1=3D0;<BR>long=20
PALeaf2=3D0;<BR>for (long=20
i=3D0;i&lt;NumberOfPortals;i++)<BR>{<BR>PALeaf1=3DPortalArray[i]-&gt;Leaf=
OwnerArray[0];<BR>PALeaf2=3DPortalArray[i]-&gt;LeafOwnerArray[1];<BR><BR>=
if=20
((CheckPortalLeaf1=3D=3DPALeaf1 &amp;&amp; =
CheckPortalLeaf2=3D=3DPALeaf2) ||=20
(CheckPortalLeaf1=3D=3DPALeaf2 &amp;&amp;=20
CheckPortalLeaf2=3D=3DPALeaf1))<BR>{<BR>D3DXVECTOR3=20
Max1,Min1,Max2,Min2;<BR><BR>GetPolygonBounds((POLYGON=20
*)CheckPortal,&amp;Min1,&amp;Max1);<BR>GetPolygonBounds((POLYGON=20
*)PortalArray[i],&amp;Min2,&amp;Max2);<BR><BR>float=20
NewSize=3DD3DXVec3Length(&amp;(Max1-Min1));// Measure the Lengths of the =
vector=20
to<BR>// see which is bigger<BR>float=20
OldSize=3DD3DXVec3Length(&amp;(Max2-Min2));<BR><BR>if=20
(fabs(NewSize)&gt;fabs(OldSize))<BR>{<BR>PORTAL=20
*temp=3DPortalArray[i];<BR>DeletePortal ( temp =
);<BR>*index=3Di;<BR>return=20
false;<BR>}<BR>else<BR>{ <BR>return true;// This portal is already in =
the=20
array<BR>}<BR>}<BR>}<BR>*index=3DNumberOfPortals;<BR>return false;// =
This portal=20
was not found inthe array<BR>}<BR><BR></FONT></CODE>I am not going to =
cover the=20
code to the 'GetPolygonBounds' function because it is just a simplified =
version=20
of the function 'CalculateBox' function that we wrote earlier to build a =

BoundingBox for our leafs and nodes.The only difference is that it only =
has to=20
build it for one polygon. You can check out the code anyway if you =
want.It can=20
be found in 'Portals.cpp'<BR><BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D5><STRONG>We Have the Portals.Can =
we Calculate=20
Our PVS Now Please?</STRONG> </FONT></U></CENTER><BR>Now that we our =
Portal=20
Array fully complete and each portal contains which Leafs it exists in =
and each=20
Leaf in our Leaf Array contains which portals exist in them we now have =
all the=20
information to calculate the PVS. We said earlier that in order to find =
out what=20
was visiible from one room to the next we said we needed to now the size =
of the=20
entrance/exit that joins those two rooms. Now we have exactly that. Each =
portal=20
describes the the exact gap(doorway) between between one leaf and the =
next so=20
the dimensions of the portal also gives us the dimensions of the =
gap.This means=20
we are now entering the final leg of getting our PVS calculator=20
working.<BR><BR>Our next task will be to recursively walk through each =
leaf in=20
the tree and for every portal in that leaf create an ANTI-PENUMBRA =
between that=20
Portal and every Portal in the Leafs adjoining that leaf and so on.Now =
probably=20
that last sentance made very little sense to you, so we will cover this =
very=20
slowly with plenty of diagrams etc so do not fear. The first question =
you are no=20
doubt asking your self is......<BR><BR>
<CENTER><STRONG><FONT color=3Dgreen size=3D4><U>What the Hell is an =
Anti-Penumbra.=20
Is it Uncle Penumbras Wife?</U></FONT> </STRONG></CENTER><BR><BR>A =
Penumbra=20
describes the shadow cast by an object.Any objects within the Penumbra =
are said=20
to be in shadow. An Anti-Penumbra therefore is the exact oppsite. =
Imagine you=20
are in a very dark house where every room is pitch black so you can't =
see a=20
thing (oh scary).Now imagine that one of the rooms was filled with very =
bright=20
light but the door to this room was closed so that it was still pitch =
black=20
outside the room. Imagine now that the door was opened and the light was =
allowed=20
to flood out. You would see the light almost leave the room in a kind of =
Frustum=20
shape as the light can only get out through the doorway hole.Outside the =
room=20
some parts of the adjoining rooms may be at such an angle to the door =
that they=20
still remain in shadow and are therefore not within the =
anti-penumbra.You must=20
have seen this effect dozens of times.The Anti-Penumbra describes =
EVERYTHING=20
that can been seen through the door way.If any parts outside the room =
remain in=20
darkness then that area could not bee seen from anywhere within that=20
room.<BR><BR>
<CENTER><U><FONT color=3Dblue>Creating an=20
Anti-Penumbra</FONT></U><BR><BR></CENTER>For our purposes the =
Anti-Penumbra will=20
be built out of a number of clip planes.We will build the Anti-Penumbra =
using=20
two portals,a Source Portal and a Destination Portal.The Anti-Penumbra =
will then=20
tell us the Maximum that can be seen from the Source Portal through the=20
Destination Portal.This is the Key behind calculating our PVS<BR>Before =
we look=20
at this in action lets first talk about how we build an Anti-Penumbra =
between=20
any two Portals.<BR><BR>As said above the Anti-Penumbra will be nothing =
more=20
than collection of Clipping planes not unlike the the Clip Planes that =
D3D uses=20
to reject all invisible geometry that is not with in the View Frustum. =
As you=20
are probably aware , any three points in 3D space describe a Plane. If =
we have=20
these 3 points then we can create a Plane from them. What we will do is =
Loop=20
through EACH Vertex in the 'Source' Portal and for each one of these =
Vertices we=20
will loop through each EDGE in the Destination portal. Obviously an EDGE =

contains two Vertices so with these vertices and the one from the source =
Portal=20
we have three points which describe a Plane. The Pseudo code then looks =
a little=20
like this. <BR><BR><STRONG>For Each Vertex In Source Portal=20
(SourceVertex)<BR>&nbsp;&nbsp; For Each Edge in Destination Portal =
(EdgeVertex1=20
&amp; EdgeVertex2)<BR>&nbsp;&nbsp;&nbsp;&nbsp; Create Plane using=20
SourceVertex,EdgeVertex1 &amp; EdgeVertex2<BR>&nbsp;&nbsp;&nbsp;&nbsp; =
Is Plane=20
an Anti-Penumbra Clip Plane?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If =
Yes then=20
Add to Clip Plane List<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If No =
then ignore=20
it and move onto next Edge<BR>&nbsp;&nbsp; End For Each Edge<BR>End For =
Each=20
Vertex<BR></STRONG><BR><BR>Now the one million dollar question that begs =
to be=20
asked looking at the above Pseudo code is what 'IS' and Anti-Penumbra=20
Plane.Above you can see that we will create many planes but only ones =
considered=20
to be an 'Anti-Penumbra Plane' are added to the clip list and the rest =
are=20
ignored.<BR>A Plane is considered to be an Anti-Penumbra plane if the =
plane=20
clearly divides the Source Portal and the Destination portal.That is to =
say the=20
Plane is accepted if the Source Portal lays of one side of the Plane and =
the=20
Destination portal lays on the other.<BR>In the diagram below we see an =
example=20
of two planes that might be created in the above loop.The first example =
is=20
rejected because both portals lay on the same side of the portal. <BR>
<CENTER><IMG height=3D512=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvss.gif"=20
width=3D512></CENTER><BR>You can see the first diagram that both the =
portals are=20
on the underside of the plane that is created by the three points.You =
can also=20
see however that the second diagram creates a plane that clearly divides =
space=20
so that the Source Portal lays on the Left side of the plane (top down =
view) and=20
the Destination portal lays on the Right side of the plane.This second =
plane=20
will be accepted by our code and added to the clip list.Its hard to draw =
this=20
stuff very well because of its 3D nature but take a look at the next =
diagram=20
which also clearly show other planes that will be created and accepted =
in the=20
above code.<BR><BR>
<CENTER><IMG height=3D444=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvst.gif"=20
width=3D463></CENTER><BR><BR>You can see see that the Red plane is =
created by=20
using one of the source portals bottom vertices and the top edge of the=20
Destination portal. The creates a plane where the Source portal is on =
the top=20
side of the plane and the Destination portal is on the bottom side. You =
can see=20
the same thing but in reverse is also true with the Green plane in the=20
diagram.Only this time the Souce portal is on the bottom side of the =
plane and=20
the destination portal is on the Top side. <BR><BR>
<TABLE bgColor=3Dred border=3D1>
  <TBODY>
  <TR>
    <TD><FONT color=3Dwhite><U>Please note:</U><BR>I am using the terms =
'Bottom=20
      Side' and 'Top Side' to describe the relation ship of the Portals =
to the=20
      planes in the above diagram a little loosely here purely for the =
sake of=20
      explaining the diagram. In fact the Normals for the Planes can be =
facing=20
      in any direction changing what is considered top and what is =
considered=20
      bottom. This does not matter at all, all we need to know is that =
one=20
      Portal lays on one side and the other Portal lays on the other =
side.The=20
      orientation of the plane is not important.</FONT>=20
</TD></TR></TBODY></TABLE><BR><BR>Now creating the planes is very easy =
and we=20
have done this and explained this in detail before.It is exactly the =
same as=20
creating the Normals for our polygon.The three points (Source point =
&amp;=20
Destination Edge) for a triangle.We just have to create vectors for two =
of these=20
edges and perform the Cross product on them to get the Normal of the =
plane.As=20
our PLANE structure is defined as a Normal and a Point known to be on =
the plane=20
, once we have the normal we can just use any of the 3 points as our =
Point On=20
Plane.We will see this in code in a moment but something that you are =
probably=20
wondering is "So what if we have a list of clip planes at wierd =
angles,how does=20
that help us?". The answer is very much.<BR><BR>When you view the planes =
(like=20
the Red and Green ones shown above) from the source portal to the =
destination=20
portal it just looks like a load of planes colliding and zig zagging =
with each=20
other.The Real magic however is the shape the Planes make when they come =
out of=20
the opposite side of the Destination portal. As the Planes project out =
from the=20
opposing side of the destination portal they form the shape of the =
Anti-Penumbra=20
(a bit like aView Frustum but with no Near or Far Clip Planes).Look at =
the=20
diagram below , the white leafs as visible. <BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsu.gif"=20
width=3D512></CENTER><BR><BR>Once you start adding rooms around the =
portals you=20
start to see how this is all used. In this example we are currently in =
the=20
Source leaf.The portal in the Source Leaf is called the Source =
portal.Because of=20
the way that BSP trees have convex leafs we ALWAYS know that the Leaf on =
the=20
opposing side of a Source portal (the Destination Leaf 'Leaf 2') will =
Always be=20
visible.We then test each portal in the Destination leaf (there is only =
one in=20
the above diagram and these are called Destination Portals) and =
providing that=20
the Destination portal is NOT on the same plane as the Source portal, it =
too is=20
always Visible from the Source Portal.If a Destination portal is on the =
same=20
plane as the Source portal then we just ignore it.If the Destination =
Portal is=20
visible then it is obvious that the Leaf on the other side of the =
Destination=20
portal is also visible (Leaf 3).This Leaf is called a Generator leaf and =
is=20
where the recursive process kicks in to play.We will look at this =
later.For now=20
though just look at how the Anti-Penumbra Planes leave the Opposing side =
of the=20
destination portal to form a Anti-Penumbra in the Leaf 3 (the generator=20
leaf).You can see that any portals in the Generator Leaf (called =
Generator=20
portals) that fall within the Anti-Penumbra (the red area) are =
considered to be=20
visible.And Generator portals that are OUTSIDE the red area are =
ignored.In the=20
above diagram you can see that only one Generator Portal was within =
(partially=20
in also count as in) the Anti-Penumbra and so we know that the Leaf on =
the=20
opposing side of this Portal (Leaf 6) is also visible from the Source =
Leaf.You=20
can see already that we have already rejected Leaf 5 and Leaf 4 from the =
Source=20
Leafs PVS which is correct because there is no way that you could ever =
see in to=20
either of those room from the Source Leaf.<BR><BR>What you have just =
seen above=20
is the start of how the PVS calculator starts to calculate the PVS for a =
given=20
leaf. We do this for every Source portal in the Source Leaf Leaf , and =
for every=20
source portal we create an 'anti-penumbra' with every Destination portal =
in the=20
destination leaf. In other we need to calculate what the Source Leaf can =
see out=20
of all its doorways.Although the above diagram got us started we have =
not yet=20
talked about the recursive process invloved in Calculating the PVS. In =
the Above=20
Diagram we simply stop when Leaf 6 is hit. But what if Leaf 6 also had =
portal?=20
We would also have to check that portal too because we might be able to =
see=20
through one of leaf 6's portals from the source leaf which in turn means =
we=20
would have to recurse into leaf 7 and test its portals etc etc =
etc.<BR><BR>The=20
Process is not as bad as it seems and I have drawn some nice diagrams to =
help=20
see it more clearly.=20
<TABLE width=3D"100%" border=3D1>
  <TBODY>
  <TR>
    <TD width=3D280><IMG height=3D173=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsv1.gif"=20
      width=3D278></TD>
    <TD>A you can see once again the Source,Destination and Generator =
Leafs=20
      are all marked as visible from the Source Leaf and the Clip Planes =
(aka=20
      Anti-penumbra) are built from the Source portal to the Destination =
Portal=20
      describing exactly how much of the Generator Leaf is visible =
through the=20
      Destination portal as viewed from the Source portal. You can see =
that out=20
      of the two Generator Portals only one is partially with in the =
Clip=20
      Planes.The portal outside the planes is ignored and not processed, =
but=20
      above you can see that the other portal is partially in side.So we =
clip=20
      away the part of the generator portal that is Outside so we are =
just left=20
      with a fragment that is within the penumbra. What happens next is =
really=20
      intersting. </TD></TR>
  <TR>
    <TD width=3D280><IMG height=3D179=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsv2.gif"=20
      width=3D274></TD>
    <TD>Because the Generator portal is partially visible it also means =
the=20
      Leaf on the other side of this portal is visible so we mark it as =
so by=20
      adding it to the source leafs PVS. Next this new Leaf becomes the =
New=20
      Generator Leaf and the Old generator Leaf becomes the new =
Destination Leaf=20
      meaning the old generator portal now becomes the new destination =
Portal=20
      .This means we now build a new Anti-Penumbra from the same source =
Portal=20
      but to the new Destination portal (the old Generator Portal that =
was=20
      clipped) fully describing what area in the new Generator leaf is =
still=20
      visible.What is great about this is as we recursively move from =
leaf to=20
      leaf doing this (making old Generator Portal new Destination =
portal and=20
      rebuilding the anti-penumbra) and clipping each generator portal =
to the=20
      Anti-Penumbra,the Anti-Penumbra gets smaller and smaller with each =
recur=20
      until in the end no portals in the current generator leaf are in=20
  side.</TD></TR>
  <TR>
    <TD width=3D280><IMG height=3D174=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsv3.gif"=20
      width=3D272></TD>
    <TD>Here is an exact example of what I mean.You can see that as we =
go into=20
      each new Generator Leaf the Anti-Penumbra get narrower and =
narrower=20
      raising the chances of clipping out all of the Next Generator =
Leafs=20
      portals(Generator Portals).As we enter every Generator leaf that =
leaf is=20
      added to the Source leafs PVS. We now have a PVS for the current =
Source=20
      Leaf.The diagram to the right shows in grey the leafs that could =
possibly=20
      be seen from the Source Leaf.</TD></TR></TBODY></TABLE><BR><BR>Now =
don't worry=20
if you have not a clue how to code any of this as I will step through =
the actual=20
code explaining everything in detail, but just look at the above =
diagrams until=20
you understand in your head how the system works especially the bit =
where we=20
make the Old generator portal the new Destination portal and rebuild the =
Anti=20
penumbra between the Source Portal and the new Destination =
portal.<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>A Few Last Things Before We=20
Code</U></FONT></CENTER><BR>One of the Last things we have to cover =
before you=20
can actually understand the code I am going to show you is how exactly =
we=20
determine whether or not a Generator portal is within the =
Anit-Penumbra.It turns=20
out that this is very easy. Taking a look at the following diagram you =
can see=20
that the grey areas that are NOT visible are on the SAME side of the =
clip plane=20
as the source portal is.<BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsw.gif"=20
width=3D512></CENTER><BR>In other words then, we will check each =
Generator Portal=20
against each Clip Plane.If ANY of the Generator Portals are on the SAME =
side of=20
the plane as the Source Portal then the portals are NOT within the =
Anti-Penumbra=20
and can be rejected.This means we will no longer have to recur into the =
leaf on=20
the other side of that portal. If however a Generator portal is on the =
Opposing=20
Side of a Plane to the Source Portal, then it IS within the =
Anti-Penumbra and so=20
should be tested against the other planes in the Anti-Penumbra.If a =
portal is=20
Spanning the Plane then the Portal gets Clipped to the Plane keeping the =
piece=20
that is on the opposing side of the plane to the source =
portal.<BR><BR>All the=20
functions described below can be found in 'pvs.cpp' in the downloadable =
zip=20
file.We will need suprisingly little code to implement this considering =
that we=20
also have to compress the data as we write it.<BR><BR>The functions =
contained in=20
'PVS.cpp' are as follows:-<BR><BR><FONT color=3Dgreen>long=20
CalculatePVS();</FONT><BR><BR>This is the function called by our =
'InitPolys'=20
routine.It is the only function called by our main program.This function =
uses=20
the following functions to complete its task.<BR><BR><FONT =
color=3Dgreen>void=20
RecursePVS(long SourceLeaf,PORTAL *SrcPortal,PORTAL *TargetPortal,long=20
TargetLeaf,BYTE *LeafPVS);</FONT><BR><BR>Once 'CalculatePVS' has set up =
the=20
Source Portal &amp; Destination Portal this function is the function =
used to=20
recurse the Tree.It is the function that is responsible for making the =
Current=20
Generator portal the new Destination portal and rebuilding the =
Anit-Penumbra=20
(Clip Planes) with each recur.<BR><BR><FONT color=3Dgreen>PORTAL *=20
ClipToAntiPenumbra(PORTAL *SourcePortal,PORTAL *TargetPortal,PORTAL=20
*GeneratorPortal);</FONT><BR><BR>This function is responsible for =
Building the=20
Anti-Penumbra (which is just an array of clip planes) bewteen the Source =
and=20
Destination Portal and clips the Generator Portal to the Planes and =
returns=20
it.It will return 'NULL' if the Generator portal was outside the=20
Anti-Penumbra.<BR><BR><FONT color=3Dgreen>PLANE GetPortalPlane (PORTAL=20
*Portal);</FONT><BR><BR>Small helper function that takes a portal and =
fills out=20
a PLANE struct and returns it.It does this simply by taking the First =
Vertex in=20
the portal and the portal normal and stuffing them in a PLANE=20
structure.<BR><BR><FONT color=3Dgreen>void SetPVSBit (BYTE =
*VisArray,long=20
DestLeaf) ;</FONT><BR><BR>Before we calculate each Leafs PVS the =
'CalculatePVS'=20
function we allocates a temporary array to hold the CURRENT leafs PVS =
data.This=20
array is large enough to hold 1 bit for each leaf. When we find that a =
Generator=20
portal is visible (therefore so is the leaf on the opposing side) we =
need to=20
record that the Leaf on the opposing side of the Generator portal is =
visible=20
from the source leaf. We pass this function the temporary array and the =
Leaf=20
that is visible.This function sets the correct Bit to 1 in the Temporary =

Visibility array.<BR><BR><FONT color=3Dgreen>long CompressLeafSet(BYTE=20
*VisArray,long WritePos);</FONT><BR><BR>Once 'CalculatePVS' has =
calculating the=20
PVS for a given leaf, that leafs PVS array is stored in a Temporary =
array as=20
discussed above.It calls this function to add this data to the master =
PVSDATA=20
array and compress the data as it is added (using zero run length =
encoding).When=20
the 'CalculatePVS' function returns control back to the main program the =

'PVSData' array will hold the PVS for every leaf compressed and each =
Leaf will=20
also have in its PVSIndex field an offset into this array that describes =
the=20
location of the start of its PVSdata. By adding each leafs visiblity =
info to the=20
array one at a time means that we save on memory overhead.Instead of =
having to=20
calculate the whole PVS information in one array and then Compress it =
into=20
another array (therefore needing twice the size of the PVS data during =
the=20
compression because of the need for two array), we will just calulate =
one leafs=20
visibility info at a time and then add that to the PVSData array. The =
buffer=20
that was used to hold the uncompressed Visibility info for the leaf can =
then be=20
cleared and re used for the next leaf and so on.Oh well, I suppose we =
had better=20
dig in and start looking at the code. <BR><BR>
<CENTER><STRONG><FONT color=3Dgreen size=3D5><U>The 'CalculatePVS'=20
Function</U></FONT></STRONG></CENTER><BR><BR>Just so we get an overall =
order of=20
things up to this point lets just take a peek back at our 'InitPolygons' =

function. Remember that this is the function that calls all the other =
setup=20
functions.It calls 'BuildBSP' , it calls 'BuildPortals' and now we will =
see it=20
in its complete form where it also sets up a few things in preperation =
to the=20
call to 'CalculatePVS'. Here it is in its complete form to give you and =
idea of=20
how all the various subjects we have discussed up to now fit into the =
overall=20
picture.You can see the new bits have been highlighted in=20
blue.<BR><BR><CODE><FONT size=3D2>void=20
InitPolygons(void)<BR>{<BR>ReserveInitialMemoryForArrays();<BR>PolygonLis=
t=3DNULL;<BR>PolygonList=3DLoadMWM("demolevel.mwm");<BR>LoadTextures();<B=
R><BR>BuildBspTree(0,PolygonList);<BR>BuildPortals();<BR><BR><FONT=20
color=3Dblue>BytesPerSet=3D(NumberOfLeafs+7)&gt;&gt;3;<BR>PVSData=3D(BYTE=
 *)malloc=20
(NumberOfLeafs*BytesPerSet);<BR>ZeroMemory(PVSData,NumberOfLeafs*BytesPer=
Set);=20
<BR>PVSCompressedSize=3DCalculatePVS(); <BR>PVSData=3D(BYTE *)=20
realloc(PVSData,PVSCompressedSize);<BR></FONT>} // END=20
FUNTION<BR><BR></FONT></CODE>The first thing we do is calculate the =
initial=20
space needed to hold the PVS Data for the tree.At this point we have no =
idea how=20
much the PVS data will be compressed so we have to allocate enough space =
for a=20
worst case senario or no compression.Once we have the PVS we will also =
have the=20
total size of it as well so we can then Re Size this array to the actual =
amount=20
needed. We need to allocate enough memory initially so that there is =
enough=20
memory for every leaf to have 1 bit for every other leaf in the=20
tree.<BR>'BytesPerSet' is a global variable that holds the number of =
bytes EACH=20
leaf will need to hold its own PVS data.The reason we add 7 and then =
divide by 8=20
(&gt;&gt;3) is to allow for the truncation from 'float' to 'long'.For =
example,=20
if we have 9 leafs and we know that each byte holds 8 Bits then we know =
we need=20
2 Bytes to hold all the bits because the Bit for the first eight leafs =
would be=20
in byte[0] and the 9th Bit would be in Byte[1]. However if we simply do=20
BytesPerSet=3D9/8 we get 1.However 9+7=3D16/8=3D2. In other words this =
just assures=20
that we allocate the correct number of Bytes.<BR><BR>Next we multiply =
this by=20
the Number of Leaves in the tree because each leaf will need its own PVS =
byte=20
set.We then allocate the memory and clear it to zero. Then we call the=20
'CalculatePVS' function which is the function that does all the =
work.When this=20
function returns the PVS set for every leaf will be stored together in =
the=20
Global 'PVSData' array and the function will return the actual size of =
the=20
array.We can then use this to resize the PVSData array to the correct =
size=20
freeing up any uneeded memory.<BR><BR>At this point everything is =
done,we have a=20
SolidLeafBSPTree and a PVSData array that each leaf uses to see what =
other leafs=20
are visible from that leaf.You are then ready to render.<BR><BR>Lets now =
take a=20
look at the 'CalculatePVS' function a few lines at a time and we will =
then=20
discuss the helper functions it uses.<BR><BR><CODE>long=20
CalculatePVS()<BR>{<BR>BYTE * LeafPVS=3Dnew BYTE[BytesPerSet];<BR>long=20
PVSMasterWritePointer=3D0;<BR></CODE>First we allocate a temporary =
buffer=20
'LeafPVS' that will be used to hold the uncompressed PVS information for =
each=20
Leaf.Remember that we calculated the value of the global variable =
'BytesPerSet'=20
prior to the function call.Once this function has calculated the PVS =
information=20
for a Leaf into this buffer,the buffer is copied into the master PVSData =
array=20
being compressed as it is copied. The variable PVSMasterWritePointer =
will be=20
used to hold the current write position in the 'PVSData' array. This is =
a little=20
like a File pointer when reading or writing to a file.The variable holds =
the=20
offset into the master PVSData array that this Leafs visibility =
information will=20
be copied to.This starts at zero obviously for the first leaf.As each =
Leafs PVS=20
Information is added to the master 'PVSData' array the =
PVSMasterWritePointer=20
will keep track of the position that the Next Leafs information will be =
written=20
to. This is also the Offset we will store in the LEAF structures =
'PVSIndex'=20
array that we used earlier in our 'DrawTree' function to offset into the =
PVSData=20
array at the correct position for the current leaf the camera was=20
in.<BR><BR>Next we have to loop through each leaf (to calculate the PVS =
for it).=20
<BR><BR><CODE>for (long=20
Leaf=3D0;Leaf&lt;NumberOfLeafs;Leaf++)<BR>{<BR>LeafArray[Leaf].PVSIndex=3D=
PVSMasterWritePointer;<BR>ZeroMemory(LeafPVS,BytesPerSet);<BR>SetPVSBit(L=
eafPVS,Leaf);<BR><BR></CODE>Above=20
we set up a for next loop that will loop through each leaf in the =
LeafArray and=20
calculate the Visibilty information for that leaf.We start by storing =
the value=20
of 'PVSMasterWritePointer' into the leaf structure so that we can offset =
in the=20
array during Rendering and get to any Leafs Visibility =
information.<BR><BR>One=20
of the first things we do is call 'SetPVSBit' and pass in the Current =
Leaf and=20
the Visibilty Buffer.This will find the current bit in the buffer and =
set it to=20
one. This is because it is obvious that each leaf can see itself.In =
other words,=20
if the current leaf we were working on was Leaf 10 (Leaf=3D10) then this =
function=20
would find the correct bit to set (the 10th bit) in the buffer to =
indicate that=20
Leaf 10 can see Leaf 10 which is obvious.In other words it would set Bit =
3 in=20
the second Byte of the 'LeafPVS' buffer.<BR><BR>Now for each leaf (which =
is the=20
Source Leaf) we also have to loop through each Portal in that leaf.These =
portals=20
are the Source Portals (refer back to the diagrams if you have forgotten =
about=20
Source ,Destination and Generator portals) and for each Source portal we =
need to=20
find the Leaf on the Opposite side of the portal.This will be the =
Destination=20
Leaf.(SPI stands for Source Portal Index)<BR><PR><CODE>for (long=20
SPI=3D0;SPI&lt;LeafArray[Leaf].NumberOfPortals;SPI++)<BR>{<BR>PORTAL *=20
SourcePortal=3DPortalArray[LeafArray[Leaf].PortalIndexList[SPI]];<BR>long=
=20
TargetLeaf=3DSourcePortal-&gt;LeafOwnerArray[0];<BR>if =
(TargetLeaf=3D=3DLeaf)=20
<BR>{<BR>TargetLeaf=3DSourcePortal-&gt;LeafOwnerArray[1];<BR>}<BR>SetPVSB=
it(LeafPVS,TargetLeaf);<BR></CODE><BR>Remember=20
that Each Portal Contains a List of leafs it exists in and each Leaf =
contains=20
the a list of portals that exist in it.Above we get each source portals =
index=20
(in the PortalIndex Array) by stepping through the current Leafs=20
'PortalIndexList' array which is an array of Portal Index's into the =
master=20
Portal Array. Once we have the current Source Portal we then need to get =
the=20
Destination Leaf.This is easy because the source portal will exist in =
two leafs=20
and one of those leafs will be the current Leaf (the Source Leaf). So we =
step=20
through the Portals 'LeafOwnerArray' (of which there are only two =
elements)=20
until we find a Leaf that is NOT the Source Leaf. This will be the Leaf =
on the=20
Other side of the portal (The Destination Leaf a.k.a the Target =
Leaf).<BR><BR>As=20
I said earlier, because of the convex nature of BSP Trees every Leaf =
Sharing a=20
Source portal with the Source Leaf (in other words each Destination =
Leaf) will=20
always be visible from the source (refer back to earlier diagrams for a =
refresh)=20
so we once again call 'SetPVSBit' and pass in the TargetLeaf =
(Destination leaf)=20
index so this Leafs bit gets set in the 'LeafPVS' buffer.This will =
happen for=20
each Source Portal in the Source Leaf so every Leaf on the opposing side =
of a=20
Source Portal will be a Destination Leaf and have its bit set in the =
buffer=20
during its iterartion of the loop.<BR><BR>So now we have the Source =
Leaf, the=20
Source Portal and the Destination Leaf which is the Leaf over the other =
side of=20
the Source portal.Our next job now is to loop through every portal in =
the=20
Destination Leaf and see whether it is visible.This is easy, if any =
portal in=20
the Destination Leaf (Destination Portal) is on the same plane as the =
Source=20
portal then the source portal can not SEE the Destination portal and so =
should=20
be ignored.Any other Destination Portals however will be visible from =
the Source=20
Portal because remember the Source Portal is also a Portal in the =
Destination=20
Leaf.So first have to check 1) whether the Source portal is on the same =
Plane as=20
the Destination portal and 2) we have to check that the Source Portal is =
NOT the=20
Destination portal because the source Portal is ALSO in the Destination =
Leaf.If=20
we don't check for this the Source Portal will get treated as a =
Destination=20
Portal also and the recursive loop will just go on looping forever =
between the=20
Source Leaf and the destination Leaf.Believe me I know what I am talking =
about,i=20
had to reset my machine about 50 times in one day because I overlooked =
this=20
small and obvious fact. <BR><BR><FONT size=3D3><CODE>for (long=20
DPI=3D0;DPI&lt;LeafArray[TargetLeaf].NumberOfPortals;DPI++)<BR>{<BR>PORTA=
L *=20
TargetPortal=3DPortalArray[LeafArray[TargetLeaf].PortalIndexList[DPI]];<B=
R>if=20
(SourcePortal!=3DTargetPortal &amp;&amp;=20
ClassifyPoly(&amp;GetPortalPlane(SourcePortal),(POLYGON=20
*)TargetPortal)!=3DCP_ONPLANE)<BR>{<BR><BR>RecursePVS(Leaf,SourcePortal,T=
argetPortal,TargetLeaf,LeafPVS);=20
<BR>} // End for If Source !=3D Dest<BR>} // End for DPI<BR>} // End for =

SPI<BR></CODE><BR><BR></FONT>As you can see above we loop through each=20
Destination portal in the Destination Leaf and providing that the portal =
is not=20
the source portal or the portal is not on the same Plane as the Source =
Portal we=20
call the 'RecursePVS' function that is responsible for traversing the =
Leafs of=20
our tree.We pass in the 'Leaf' we are currenly building the Visibility =
array=20
for, the Source and the Destination Portal and the Destination leaf.We =
also pass=20
the temporary Visibility buffer 'LeafPVS' because the function will need =
access=20
to it to set the bits to all the leafs it finds that are visible.The =
RecursePVS=20
function will get the Leaf on the Opposing side of the TargetPortal =
which is=20
called the Generator Leaf.It will then Build a set set of clip planes =
(the=20
Anti-penumbra) between the Source and Target portal and see if any of =
the=20
Portals in the Generator Leaf are with in the Anti penumbra.If so the =
RecursePVS=20
will call itself recursively but this time the Generator Portal will be =
passed=20
in as the Target portal.This will go on recurring until it finds a =
Generator=20
Leaf where none its Portals are within the Anti-Penumbra. Everytime a =
new=20
Generator Leaf is found its bit is Set in the Visibility Buffer =
'LeafPVS'.We=20
will look at this in a moment.<BR><BR>When this function finally stops =
recurring=20
and program flow returns it means we have now calculated all the leafs =
visible=20
from the Source Leaf through that source portal and the destination =
portal=20
(Target portal).We have to do this for each Target portal in the Target =
Leaf=20
however. After the 'DPI' loop had finished we will have precalulated ALL =
the=20
leafs visible through THAT Source Portal.We then do this for every =
Portal in the=20
Source leaf (every source portal) and eventually when the 'SPI' loop =
comes to an=20
end we have calculated this Leafs entire Visibility =
information.<BR><BR>With=20
this Leafs PVS information calculated (all the relevant bits set) it is =
now time=20
to copy this buffer into the Master PVSData array compressing it using =
Zero Run=20
Length Encoding as we do so. To do this we call the 'CompressLeafSet' =
function=20
and pass in the buffer to be copied that contains this Leafs Visibility=20
information (which is LeafPVS) and we also pass in the =
'PVSMasterWritePointer'.=20
The function will compress the buffer and copy it into the PVSData array =
and=20
willl return how many Bytes got written after the compression took =
place.We can=20
simply add this onto our 'PVSMasterWritePointer' and we now have the =
offset into=20
the array to start writing the PVS for the Next=20
Leaf.<BR><BR><CODE>PVSMasterWritePointer+=3DCompressLeafSet(LeafPVS,PVSMa=
sterWritePointer);<BR>}=20
// End for Leaf<BR><BR>delete [] LeafPVS;<BR>return =
PVSMasterWritePointer;<BR>}=20
// End Function<BR><BR></CODE><BR><BR>When the function comes to an end =
(because=20
we have calculated the visibility information for each leaf) the =
'PVSData' array=20
will hold a complete PVS , also the PVSMasterWritePointer will also hold =
the=20
total number of bytes that was written to the PVS array.In other =
words,it will=20
hold the size of the PVS array in Bytes.We return this from the function =
so that=20
we can use this to resize the PVSData array to the correct size as we =
saw=20
earlier in the 'InitPolygons' function. <BR><BR>Without my interruptions =
here is=20
the complete code for 'CalculatePVS' in in entirety:-<BR><BR><CODE><FONT =

size=3D2>long CalculatePVS()<BR>{<BR>BYTE * LeafPVS=3Dnew =
BYTE[BytesPerSet];<BR>long=20
PVSMasterWritePointer=3D0;<BR>for (long=20
Leaf=3D0;Leaf&lt;NumberOfLeafs;Leaf++)<BR>{<BR>LeafArray[Leaf].PVSIndex=3D=
PVSMasterWritePointer;<BR>ZeroMemory(LeafPVS,BytesPerSet);<BR>SetPVSBit(L=
eafPVS,Leaf);<BR><BR>for=20
(long =
SPI=3D0;SPI&lt;LeafArray[Leaf].NumberOfPortals;SPI++)<BR>{<BR>PORTAL *=20
SourcePortal=3DPortalArray[LeafArray[Leaf].PortalIndexList[SPI]];<BR>long=
=20
TargetLeaf=3DSourcePortal-&gt;LeafOwnerArray[0];<BR>if =
(TargetLeaf=3D=3DLeaf)=20
<BR>{<BR>TargetLeaf=3DSourcePortal-&gt;LeafOwnerArray[1];<BR>}<BR>SetPVSB=
it(LeafPVS,TargetLeaf);<BR>for=20
(long =
DPI=3D0;DPI&lt;LeafArray[TargetLeaf].NumberOfPortals;DPI++)<BR>{<BR>PORTA=
L *=20
TargetPortal=3DPortalArray[LeafArray[TargetLeaf].PortalIndexList[DPI]];<B=
R>if=20
(SourcePortal!=3DTargetPortal &amp;&amp;=20
ClassifyPoly(&amp;GetPortalPlane(SourcePortal),(POLYGON=20
*)TargetPortal)!=3DCP_ONPLANE)<BR>{<BR><BR>RecursePVS(Leaf,SourcePortal,T=
argetPortal,TargetLeaf,LeafPVS);=20
<BR>} // End for If Source !=3D Dest<BR>} // End for DPI<BR>} // End for =

SPI<BR>PVSMasterWritePointer+=3DCompressLeafSet(LeafPVS,PVSMasterWritePoi=
nter);<BR>}=20
// End for Leaf<BR><BR>delete [] LeafPVS;<BR>return =
PVSMasterWritePointer;<BR>}=20
// End Function<BR><BR></FONT></CODE><BR><BR>Before we continue with the =
rest of=20
the support functions used by 'CalculatePVS' I would just like to show =
you the=20
code to the 'SetPVSBit' as it is called above and will be called by the=20
following functions also.It is a very small function which simply sets =
the=20
correct Bit in the Visibility Buffer that we pass in as a parameter.It =
looks=20
like so:-<BR><BR><CODE>void SetPVSBit (BYTE *VisArray,long=20
DestLeaf)<BR>{<BR>long ByteToSet=3DDestLeaf&gt;&gt;3;<BR>BYTE=20
BitToSet=3D(BYTE)(DestLeaf-(ByteToSet&lt;&lt;3));<BR>VisArray[ByteToSet]|=
=3D1&lt;&lt;BitToSet;=20
<BR>}<BR><BR></CODE>As you can see it is very small.To find the Correct =
BYTE to=20
set in the temporary Visibility Buffer we divide by 8 (&gt;&gt;3). So =
for=20
example, if we called this function to mark Leaf 19 as being visible =
(remember=20
''VisArray' is a temporary Visibility Buffer for the current Leaf having =
its PVS=20
calculated) then 19/8=3D2 (truncated to 2 because of rounding) which is =
correct.We=20
know that Bit 19 is in the 3rd Byte (VisArray[2] because its zero =
based).To find=20
the Bit we wish to set in that Byte we then Multiply the Byte it is in =
(2) by 8=20
(&lt;&lt;3) which gives us 2*8=3D16. We then take this away from the =
index of the=20
Leaf we wish to set (DestLeaf) like so 19-16=3D3.This tells us we need =
to set the=20
4th (zero basd again) bit in the third Byte. We do this by shifting '1' =
into the=20
fourth position in the Byte (shifting it by three puts it in position =
four=20
because the '1' is already in position 1 before any shifting is done).We =
then=20
'OR' this Bit with the Visibility array so that if the Bit is not =
already set it=20
is Set, and if the Bit is already set then then the Bit still remains =
Set.=20
<BR><BR>
<CENTER><U><STRONG><FONT color=3Dgreen size=3D5>The 'RecursePVS'=20
function</FONT></STRONG></U></CENTER><BR><BR>This function is the =
Recursive=20
engine behind the PVS code.It steps through the Leafs setting the Bits =
in the=20
Visibility buffer and keeps on recurring until no more generator portals =
fall=20
within the Penumbra planes.Lets take a look at it. <BR><BR><CODE>void=20
RecursePVS(long SourceLeaf,PORTAL *SrcPortal,PORTAL *TargetPortal,long=20
TargetLeaf,BYTE *LeafPVS)<BR>{<BR>long=20
GeneratorLeaf=3DTargetPortal-&gt;LeafOwnerArray[0];<BR>if=20
(GeneratorLeaf=3D=3DTargetLeaf)=20
GeneratorLeaf=3DTargetPortal-&gt;LeafOwnerArray[1];<BR>SetPVSBit(LeafPVS,=
GeneratorLeaf);<BR></CODE><BR>As=20
we have passed in the Target portal and the Target leaf as parameters =
our first=20
task is to get the Leaf on the Opposing side of the Target Portal.This =
is=20
similar to how we got the Target Leaf from the Source portal. This Leaf =
is the=20
Generator Leaf. As we find Generator Leafs we mark them as being =
visible.This is=20
because any Target portal passed into this function must be visible =
therefore=20
the Leaf on the Other side of the Portal must also be visible.Once we =
have the=20
Generator leaf, we set the relevant Bit in the Visibility =
buffer.<BR><BR>Our=20
next job is to find which side of the Source portal the Source Leaf is =
on and=20
which side of the Target portal the Target Leaf is on.We will use this=20
information in a minute to remove Generator Portals from consideration =
in=20
trivial cases.To find whether the Source Leaf is to the Back or Front of =
the=20
source portal we simply get the Center of the Leafs Bounding Box and =
Classify=20
that center point against the Portals Plane.We also do the same for the =
Target=20
Leaf to see which side (CP_BACK,CP_FRONT etc) of the Target Portal it is =
on.We=20
will look at why we need this information =
shortly.<BR><BR><CODE>D3DXVECTOR3=20
SourceLeafCenter=3D(LeafArray[SourceLeaf].BoundingBox.BoxMax+LeafArray[So=
urceLeaf].BoundingBox.BoxMin)/2;<BR>D3DXVECTOR3=20
TargetLeafCenter=3D(LeafArray[TargetLeaf].BoundingBox.BoxMax+LeafArray[Ta=
rgetLeaf].BoundingBox.BoxMin)/2;<BR>int=20
SourceLeafLocation=3DClassifyPoint(&amp;SourceLeafCenter,&amp;GetPortalPl=
ane(SrcPortal));<BR>int=20
TargetLeafLocation=3DClassifyPoint(&amp;TargetLeafCenter,&amp;GetPortalPl=
ane(TargetPortal));<BR></CODE><BR><BR>We=20
will now loop through EACH 'Generator' Portal in the Generator leaf and =
first of=20
all do some quick and simple tests to see whether it could be visible. =
First we=20
make a backup copy of the Source portal and the current Generation =
portal.This=20
is because we will need to continually clip these portals to the =
Anti-Penumbra=20
planes later on until nothing is left of them, we can't use the Actual =
Portals=20
in the master portal array because we will need these to create the =
Visibility=20
Information for all the other leafs in the tree, therefore we make =
Copies of=20
them that we can clip.<BR><BR><CODE>for (long=20
GPI=3D0;GPI&lt;LeafArray[GeneratorLeaf].NumberOfPortals;GPI++)<BR>{<BR>if=
=20
(PortalArray[LeafArray[GeneratorLeaf].PortalIndexList[GPI]]=3D=3DTargetPo=
rtal){delete=20
GeneratorPortal;delete SourcePortal;continue;}<BR>PORTAL =
*SourcePortal=3Dnew=20
PORTAL;<BR>*SourcePortal=3D*SrcPortal;<BR>PORTAL *GeneratorPortal=3Dnew=20
PORTAL;<BR>*GeneratorPortal=3D*PortalArray[LeafArray[GeneratorLeaf].Porta=
lIndexList[GPI]];<BR><BR></CODE><BR><BR>The=20
first thing we have to do is check the Generator Portal is NOT the =
Target Portal=20
otherwise we will recurse forever.We discussed this before when talking =
about=20
finding the the Target portal.If the Generator Portal IS the Target =
Portal then=20
we move on to the next iteration of the loop to process the next =
Generator=20
Portal if one exists.<BR>We also make a copy of the Source portal and =
the=20
current Generator portal for this iteration of the loop as discussd =
above.=20
<BR><BR>Now we will see why we needed to calculate which side of the =
Source=20
portal the Source Leaf lay on.If the Generator Portal is on the Same =
side of the=20
Source Portal as the Source Leaf then the Generator Portal can not =
possibly be=20
seen.Look below at the diagram.<BR><BR>
<CENTER><IMG height=3D289=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsx.gif"=20
width=3D366></CENTER>Can you see that the Generator Portal is on the =
same side of=20
the Source portal as the Source leaf.It would be a waste of time =
building a set=20
uf Anti-Penumbra planes and clipping testing the Generator portal =
against them=20
when we can see that the Portal could not possible be seen.So all we =
have to do=20
is findout what side of the Source portal the Generator Leaf is on and =
if it is=20
on the same side as the Source leaf we can skip on to the next Generator =

Portal.<BR><BR><CODE>int=20
GeneratorLocation=3DClassifyPoly(&amp;GetPortalPlane(SourcePortal),(POLYG=
ON*)=20
GeneratorPortal);<BR>if (GeneratorLocation=3D=3DCP_ONPLANE ||=20
GeneratorLocation=3D=3DSourceLeafLocation) {delete =
GeneratorPortal;delete=20
SourcePortal;continue;}<BR></CODE><BR><BR>You can see above that if the=20
Generator is on the same side as the Source Leaf or On the same Plane as =
the=20
Source portal then there is no need to test this portal.We simply delete =
the=20
copies we made of the Source and Generator Portals and move on to the =
Next=20
Generator portal if there is one.<BR><BR>Although I have not done a =
diagram of=20
it, the same is also true if the Generator Portal is on the Same side of =
the=20
Target Portal as the Target Leaf is. You will have to draw your own =
diagram if=20
you do not believe me.So the following code checks for this=20
also<BR><BR><CODE>GeneratorLocation=3DClassifyPoly(&amp;GetPortalPlane(Ta=
rgetPortal),(POLYGON*)=20
GeneratorPortal);<BR>if (GeneratorLocation=3D=3DCP_ONPLANE ||=20
GeneratorLocation=3D=3DTargetLeafLocation) {delete =
GeneratorPortal;delete=20
SourcePortal;continue;}<BR><BR></CODE>If we have made it here then we =
have a=20
Generator portal that could Possibly be seen so we have to test it =
against the=20
Anti-Penumbra planes to find out.<BR><BR>Testing it against the =
Anti-Penumbra is=20
done via a call to the 'ClipToAntiPenumbra' function shown=20
below<BR><BR><CODE>GeneratorPortal=3DClipToAntiPenumbra(SourcePortal,Targ=
etPortal,GeneratorPortal);<BR><BR>if=20
(GeneratorPortal=3D=3DNULL)<BR>{<BR>if (SourcePortal) delete=20
SourcePortal;continue;<BR>continue;<BR>}<BR><BR></CODE>Above we send =
into the=20
'ClipToAntiPenumbra' function the Source,Target and current Generator =
portal=20
being tested.This function Creates the Clip Planes for the Penumbra and =
Clips=20
the Generator portal to them returning the result.If the function =
returns 'NULL'=20
then the Generator Portal was completely clipped away which means it was =
outside=20
the Anti-Penumbra and therefore we dont have to recurse any further for =
this=20
Portal because it is not visible.In this case we simply delete the copy =
of the=20
Source Portal that we made and move onto the next iteration of the loop =
where we=20
will test the next Generator portal.<BR><BR>Now something I have not =
mentioned=20
up until now is that I will now do the same in reverse.In other words I =
will now=20
call the 'ClipToAntiPenumbra' function but send in the SourcePortal as =
the=20
Generator portal and send in the Generator Portal as the Source =
portal.This will=20
create a List of Clip Planes between the Generator Portal and the Target =
Portal=20
which may allows us to Clip the Source Portal down a bit.This allows us =
to shave=20
that little more off each time because I said before that the =
Anti-Penumbra gets=20
narrower with each recur because the Generator portals Get clipped.By =
clipping=20
the Source portal as well to the Anti-Penumbra we are getting the =
Anti-Penumbra=20
to narrow more quickly therefore raising the chances of completely =
clipping out=20
the next Generator Portal and therefore getting a smaller and more =
accurate PVS.=20
Many PVS implementations do not do this but I wanted to shave off as =
much as=20
possible even if it was at the expense of compile=20
time.<BR><BR><CODE>SourcePortal=3D=20
ClipToAntiPenumbra(GeneratorPortal,TargetPortal,SourcePortal);<BR><BR>if =

(SourcePortal=3D=3DNULL)<BR>{<BR>if (GeneratorPortal) delete=20
GeneratorPortal;continue;<BR>} <BR><BR></CODE>If a the Generator portal =
and the=20
Source Portal still exist (have not been completely clipped away) then =
we will=20
make this function call itself BUT this time passing in the Current =
Generator=20
Portal and Generator Leaf as theTarget Portal and Target Leaf =
respectively.This=20
means the next time round in the recur a New Generator Leaf on the =
opposing side=20
of the old Generator Portal (the new target portal) will be added to the =

visibility buffer and the Anti-Penumbra will be built between the source =
Portal=20
and the new Target portal (old Generator=20
portal).<BR><BR><CODE>RecursePVS(SourceLeaf,SourcePortal,GeneratorPortal,=
GeneratorLeaf,LeafPVS);<BR>delete=20
GeneratorPortal;<BR>delete =
SourcePortal;<BR>}<BR>}<BR><BR><BR><BR></CODE>That=20
was not as bad as it could have been.Read through again until you =
understand the=20
recursive process involved.The key to understanding it is in =
understanding how=20
the next time the function calls itself it uses the Old Generator portal =
as the=20
new target portal to find a new Generator Leaf on the opposing side of =
this new=20
Target Portal.Remember that each new Generator Leaf found is considered =
to be=20
visible and has its Bit set in the Visibility buffer.<BR><BR>Here is the =
code in=20
its complete form:-<BR><BR><CODE><FONT size=3D2>void RecursePVS(long=20
SourceLeaf,PORTAL *SrcPortal,PORTAL *TargetPortal,long TargetLeaf,BYTE=20
*LeafPVS)<BR><BR>{<BR><BR>long=20
GeneratorLeaf=3DTargetPortal-&gt;LeafOwnerArray[0];<BR>if=20
(GeneratorLeaf=3D=3DTargetLeaf)=20
GeneratorLeaf=3DTargetPortal-&gt;LeafOwnerArray[1];<BR>SetPVSBit(LeafPVS,=
GeneratorLeaf);<BR><BR>D3DXVECTOR3=20
SourceLeafCenter=3D(LeafArray[SourceLeaf].BoundingBox.BoxMax+LeafArray[So=
urceLeaf].BoundingBox.BoxMin)/2;<BR><BR>D3DXVECTOR3=20
TargetLeafCenter=3D(LeafArray[TargetLeaf].BoundingBox.BoxMax+LeafArray[Ta=
rgetLeaf].BoundingBox.BoxMin)/2;<BR><BR>int=20
SourceLeafLocation=3DClassifyPoint(&amp;SourceLeafCenter,&amp;GetPortalPl=
ane(SrcPortal));<BR>int=20
TargetLeafLocation=3DClassifyPoint(&amp;TargetLeafCenter,&amp;GetPortalPl=
ane(TargetPortal));<BR><BR><BR>for=20
(long=20
GPI=3D0;GPI&lt;LeafArray[GeneratorLeaf].NumberOfPortals;GPI++)<BR>{<BR><B=
R>if=20
(PortalArray[LeafArray[GeneratorLeaf].PortalIndexList[GPI]]=3D=3DTargetPo=
rtal){continue;}<BR>PORTAL=20
*SourcePortal=3Dnew PORTAL;<BR>*SourcePortal=3D*SrcPortal;<BR>PORTAL=20
*GeneratorPortal=3Dnew=20
PORTAL;<BR>*GeneratorPortal=3D*PortalArray[LeafArray[GeneratorLeaf].Porta=
lIndexList[GPI]];<BR><BR><BR>int=20
GeneratorLocation=3DClassifyPoly(&amp;GetPortalPlane(SourcePortal),(POLYG=
ON*)=20
GeneratorPortal);<BR>if (GeneratorLocation=3D=3DCP_ONPLANE ||=20
GeneratorLocation=3D=3DSourceLeafLocation) {delete =
GeneratorPortal;delete=20
SourcePortal;continue;}<BR><BR>GeneratorLocation=3DClassifyPoly(&amp;GetP=
ortalPlane(TargetPortal),(POLYGON*)=20
GeneratorPortal);<BR>if (GeneratorLocation=3D=3DCP_ONPLANE ||=20
GeneratorLocation=3D=3DTargetLeafLocation) {delete =
GeneratorPortal;delete=20
SourcePortal;continue;}<BR><BR><BR>GeneratorPortal=3DClipToAntiPenumbra(S=
ourcePortal,TargetPortal,GeneratorPortal);<BR><BR>if=20
(GeneratorPortal=3D=3DNULL)<BR>{<BR>if (SourcePortal) delete=20
SourcePortal;continue;<BR>continue;<BR>}<BR><BR>SourcePortal=3D=20
ClipToAntiPenumbra(GeneratorPortal,TargetPortal,SourcePortal);<BR><BR>if =

(SourcePortal=3D=3DNULL)<BR>{<BR>if (GeneratorPortal) delete=20
GeneratorPortal;continue;<BR>}=20
<BR><BR>RecursePVS(SourceLeaf,SourcePortal,GeneratorPortal,GeneratorLeaf,=
LeafPVS);<BR>delete=20
GeneratorPortal;<BR>delete=20
SourcePortal;<BR>}<BR>}<BR><BR></FONT></CODE><BR><BR><U>
<CENTER><STRONG><FONT color=3Dgreen size=3D5>The 'ClipToAntiPenumbra'=20
Function</FONT></STRONG></CENTER></U><BR><BR>The Next function we have =
to look=20
at is 'ClipToAntiPenumbra'. This function is rsponsible for Building the =
list of=20
Clip Planes (from the Source and Target portals) and also tests the =
Generator=20
Portal against these Planes clipping it and even deleting it if=20
nessacary.<BR><BR>Before we start I would just like to cover something =
that we=20
looked at earlier and expand on it.You may remember I said that the Clip =
Planes=20
were created by taking Each point in the Source portal with EVERY edge =
in the=20
destination portal. We then check that the Plane divides the Two planes =
an=20
accept it if it does. There is something that I have not mentioned =
earlier.Once=20
we have done this and have our List of Clip Planes we will then do the =
Same=20
thing again but the other way round. In other words we will then loop =
through=20
Each vertex in the TARGET leaf and build a Plane with EVERY edge on the =
Source=20
Leaf and once again add any planes that divide the portals to our Clip=20
List.<BR>The Reason why we do this has not been that clear up until now =
because=20
every diargram has used two square Portals.This means that Building =
Planes from=20
Source to Target will generate the Same set of planes as going from =
Target to=20
Source.In this case it has no advantage BUT lets consider to portals of=20
different shapes. A Square Source Portal and a Triangle Target Portal.By =
also=20
Creating Planes from Target to Source we may find a plane that more =
tightly hugs=20
what the source portal could see through the destination portal.The =
Planes=20
generated would be quite different as shown below.<BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsy.gif"=20
width=3D512><BR><BR></CENTER>You can see by the above picture that the =
Target to=20
Source method would generate different Clip Planes that the Source to =
Target=20
Planes. This may allow us to find a Plane that narrows the Anti-Penumbra =
just=20
that little but more allowing us to clip that little bit more of the =
Generator=20
Portal and therefore increase the Accuracy of this Leafs PVS.<BR><BR>I =
will now=20
introduce you to a new structure used by the following function to hold =
the=20
Anti-Penumbra Clip Planes.It is defined as follows:-<BR><BR><CODE>struct =

CLIPPLANES <BR>{<BR>WORD NumberOfPlanes;<BR>PLANE=20
*Planes;<BR>};<BR><BR></CODE>No real surprises here then. The CLIPPLANES =

structure contains a pointer to an array of Clip Planes and also a Count =
of how=20
many planes are in the array. <BR><BR>Lets now step through the code of =
the=20
'ClipToAntiPenumbra' function a bit at a time.<BR><BR><CODE><FONT =
size=3D2>PORTAL=20
* ClipToAntiPenumbra(PORTAL *SourcePortal,PORTAL *TargetPortal,PORTAL=20
*GeneratorPortal)<BR>{<BR>D3DXVECTOR3 =
EdgeVector1,EdgeVector2,Normal;<BR>int=20
PortalLocation;<BR>PORTAL=20
*FrontSplit,*BackSplit,*TempSource,*TempTarget;<BR>CLIPPLANES =
ClipPlanes; //=20
Create a ClipPlane=20
set<BR><BR>ClipPlanes.NumberOfPlanes=3D0;<BR>ClipPlanes.Planes=3Dnew =
PLANE=20
[SourcePortal-&gt;NumberOfVertices*TargetPortal-&gt;NumberOfVertices*2];<=
BR>PLANE=20
TempPlane;<BR>int NextVertex=3D0;<BR><BR></FONT></CODE>We start of by =
delaring=20
some local variables that we will be using shortly including a CLIPPLANE =

structure called 'ClipPlanes'.We set its count to zero because we have =
not added=20
any Planes to the list yet and also allocate enough memory in the =
CLIPPLANE=20
structure to hold the maximum number of Clip Planes thats could possibly =
be=20
created.In practice much fewer Clip Planes will be added to this list =
because=20
remember that we are only going to accept clip planes that divide the =
Source and=20
Target portals and many will not so will never be added. But to be on =
the safe=20
side we reserve enough memory so that it could contain EVERY plane that =
was=20
creates from the Source to Target and from the Target to Source.We =
multiply this=20
by two because remember that we are also going to generate a set of clip =
planes=20
from the Target to the Source Portal as well as from the Source to the =
Target=20
Portal.<BR><BR>Our first task is to set up a simple for next loop that =
will loop=20
twice.The first time through the Loop we will build Planes from the =
Source=20
Portal to the Target portal and the Second time through the Loop we will =
swap it=20
around and build the planes from, the Target portal to the Source =
Portal.Instead=20
of having to have two copies of the code that is very similar we simply =
loop=20
twice and use some temporary Pointers to point to the Source and Target=20
portals.This means that the rest of the function code will just Build =
the Planes=20
from the Temporary Source to the Temporary Portal.All we have to do in =
our outer=20
loop is swap it around the second time through the loop so that the =
Temporary=20
Source Portal points at the Target portal and the Temporary Target =
points at the=20
Source portal like so. <CODE>for (int =
loop=3D0;loop&lt;2;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>TempSource=3DSourcePortal;<BR>TempTarget=3DTargetPo=
rtal;<BR>}<BR>else<BR>{<BR>TempSource=3DTargetPortal;<BR>TempTarget=3DSou=
rcePortal;<BR>}<BR><BR></CODE>We=20
now how our Temporary Source and Target portal pointers set up to point =
to the=20
correct Portal depending on the current iterartion of the loop.Now its =
time to=20
create the planes from each vertex in the Source portal to each Edge in =
the=20
Destination portal.First we set up a for next loop to loop through each =
vertex=20
in the Source (temporary Source that is).This will be the First point =
needed to=20
construct the plane.What we do have to check for though is that the =
Source=20
Portals Vertex is not ON the Target Portals planes .This can happen if =
say for=20
example 2 portals meet in an 'L' shaped configuration.In this situation =
the Clip=20
Plane can not be built so we simply skip the vertex and move on to the =
next one.=20
<BR><BR><CODE>for (int=20
SV=3D0;SV&lt;TempSource-&gt;NumberOfVertices;SV++)<BR>{<BR>PortalLocation=
=3DClassifyPoint((D3DXVECTOR3=20
*)&amp;TempSource-&gt;VertexList[SV],&amp;GetPortalPlane(TempTarget));<BR=
>if=20
(PortalLocation=3D=3DCP_ONPLANE) continue; // Skip It. Because it;s 'L'=20
shaped<BR><BR></CODE>Providing that the Source Vertex is not ON_PLANE =
with the=20
Target Portal we now have to loop through each edge in the Target =
portal.Once=20
again we have to do a little bit of conditional logic at the top of this =
inner=20
loop because if we just loop through each vertex in the Target Portal =
and use=20
''Vertex' and ''Vertex+1' as our edge we will get to the point where we =
are at=20
the Last vertex in the Target Portal so ''Vertex+1' does not exist.All =
we have=20
to do is check if we are at the last vertex in the edge and if so wrap =
back=20
around so that the last edge uses ''Vertex' and 'FirstVertex' like=20
so:-<BR><BR><CODE>for (int=20
TP=3D0;TP&lt;TempTarget-&gt;NumberOfVertices;TP++)<BR>{<BR>if=20
(TP=3D=3DTempTarget-&gt;NumberOfVertices-1)<BR>{<BR>NextVertex=3D0;<BR>}<=
BR>else<BR>{<BR>NextVertex=3DTP+1=20
;<BR>}<BR><BR></CODE>You can see that TP will hold the Current Vertex =
(which=20
will be used as the first vertex in each edge) and 'NextVertex' will =
hold the=20
secondVertex in the edge.This will just be set to 'TP+1' unless 'TP' is =
the Last=20
vertex in the Target portal in which case we will set 'NextVertex' to =
Zero( The=20
First Vertex in the Target Portal).<BR>This means we now have the =
SourceVertex=20
index in 'SV' and the two Target Portal Vertex indices in variable 'TP' =
and=20
'NextVertex'.<BR>With this information we can now create the Clip =
Plane.We have=20
to create Two vectors. The first vector from the Source Vertex to the =
First=20
Vertex in the Current Edge of the target portal, and the second Vector =
from the=20
First Vertex in the Target Portals edge to the Second Vertex in the =
Target=20
Portals edge.The reason we do this is because if we feed both these =
vectors into=20
the Cross product we get returned a Vector that is Orthogonal to these =
two=20
vectors.As both these vector lay on the Plane we are trying to create =
this means=20
a Vector Orthogonal to these vectors is the planes Normal which we need =
to=20
define our clip plane.Remember that our PLANE structure requires a =
Normal and a=20
Point ON Plane.Once we have the Normal we have to normalize it and then =
copy it=20
into our Temprary Plane structure 'TempPlane' .We can use ANY of the =
three=20
vertices as the point on the plane to be copied into 'TempPlane'.I have =
just=20
used the SourceVertex ('SV').<BR><BR><CODE>EdgeVector1=3D*((D3DXVECTOR3=20
*)&amp;TempSource-&gt;VertexList[SV])-*((D3DXVECTOR3=20
*)&amp;TempTarget-&gt;VertexList[TP]);<BR>EdgeVector2=3D*((D3DXVECTOR3=20
*)&amp;TempTarget-&gt;VertexList[NextVertex])-*((D3DXVECTOR3=20
*)&amp;TempTarget-&gt;VertexList[TP]);<BR><BR><BR>D3DXVec3Cross(&amp;Norm=
al,&amp;EdgeVector1,&amp;EdgeVector2);//=20
create normal<BR>D3DXVec3Normalize(&amp;TempPlane.Normal,&amp;Normal); =
// make=20
it a unit normal<BR>TempPlane.PointOnPlane=3D*(D3DXVECTOR3=20
*)&amp;TempSource-&gt;VertexList[SV];//Any vertex will=20
do<BR><BR></CODE><BR><BR>Now that we have a Plane stored in 'TestPlane' =
we have=20
to test whether or not it is an Anti-Penumbra plane.Remember that it is =
only a=20
Anti-penumbra plane IF the Plane divides the Source Portal and Target =
portal so=20
that each portal lays on opposing sides of the plane.If it does it is =
added to=20
our Clip Plane List 'ClipPlanes'.<BR>The following code basically just =
says "If=20
the Source Portal is on the FRONT of the Plane and the Target Portal is =
on the=20
BACK of the Plane then accept it and add it to the clip list" else "If =
the=20
Source Portal is on the BACK of the plane and the Target portal is on =
the FRONT=20
of the plane except it also".Planes that do not divide the Portals are =
just=20
ignored.<BR><BR><CODE>if(ClassifyPoly(&amp;TempPlane,(POLYGON*)TempSource=
)=3D=3D=20
CP_FRONT)<BR>{<BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON*)TempTarget)=3D=
=3D=20
CP_BACK)<BR>{<BR>ClipPlanes.Planes[ClipPlanes.NumberOfPlanes] =3D=20
TempPlane;<BR>ClipPlanes.NumberOfPlanes++;<BR>//Save clip=20
plane<BR>}<BR>}<BR><BR>else =
<BR><BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON=20
*)TempSource) =3D=3D=20
CP_BACK)<BR>{<BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON*)TempTarget) =
=3D=3D=20
CP_FRONT)<BR>{<BR>ClipPlanes.Planes[ClipPlanes.NumberOfPlanes] =3D=20
TempPlane;<BR>ClipPlanes.NumberOfPlanes++;<BR>//Save clip =
plane<BR>}<BR>}<BR>}=20
// end for tp<BR>} // end for sp<BR>} // END FOR LOOP<BR><BR></CODE>At =
this=20
point we have exited all the loops we started and 'ClipList' hold the =
Number of=20
Clip Planes in the Anti-Penumbra and also contains a pointer to those =
Clip=20
Planes.At last we have our Anti-penumbra built.All we have to do now is =
see if=20
the Generator portal is Inside the Anti-penumbra or not. We do this by =
looping=20
though each Clip Plane and clip each generator Portal to the Clip =
Plane..Just to=20
jog your memory I will show you Diagram W) again so you can see how the =
clipping=20
works:-<BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsw.gif"=20
width=3D512></CENTER>Remember we said earlier that if anything lays on =
the same=20
side of a clip plane as the Source portal does then it can not possibly =
be=20
visible. In the diagram above you can see that the Source portal is on =
the Back=20
Side of the Green plane. If you then look at the Generator leaf you can =
see that=20
any area behind the green line is colored grey indicating that it can =
not be=20
seen also. This mean that we test the Generator Portal against each clip =
plane=20
and also test the Source portal against the Clip plane and if they both =
lay on=20
the same side of the Clip Plane then the Generator portal can not be =
seen from=20
the Source portal so the Generator portal is deleted, the Anti-Penumbra =
planes=20
are deleted and the function returns 'NULL' back to the 'RecursePVS' =
function=20
ending the Recursive process in that direction.<BR>If the Generator =
Portal is on=20
the opposing side of the portal to the source portal then it passes the =
test for=20
the current Clip Plane and moves on to the next loop to be tested =
against the=20
next plane. If the generator portal survives all the clip planes it is =
reurned=20
to the 'RecursePVS' function where the Leaf on the opposing side of the=20
generator will be come the new Generator leaf and so the recursion=20
continues.<BR>If the Generator Portal is spanning the Clip Plane then it =
means=20
only some of the portal is visible (the bit on the opposing side of the =
plane=20
from the source portal) so the portal is Split to the plane (using our=20
'SplitPortal' function) and the original generator portal is deleted and =
so is=20
the fragment that is on the same side of the plane as the source =
portal.The=20
Fragment that is on the Opposing side of the plane to the Source portal =
becomes=20
the new Generator Portal for the Rest of the clipping operations. Here =
is the=20
last bit of the function that performs the clipping of the generator =
portal to=20
the anti-penumbra. <BR><BR><BR><BR><CODE><FONT size=3D2>for(int I =3D 0; =
I &lt;=20
ClipPlanes.NumberOfPlanes; i++)<BR>{<BR>PortalLocation=3D=20
ClassifyPoly(&amp;ClipPlanes.Planes[i],(POLYGON =
*)GeneratorPortal);<BR>int=20
SourcePortalLocation=3DClassifyPoly(&amp;ClipPlanes.Planes[i],(POLYGON=20
*)SourcePortal);<BR><BR>if(PortalLocation =3D=3D SourcePortalLocation || =

PortalLocation=3D=3DCP_ONPLANE)// its entirley out side the anitpenumbra =
so loose=20
it<BR>{<BR>delete Generator portal;<BR>delete =
ClipPlanes.Planes;<BR>return=20
NULL;<BR>}<BR><BR>if((PortalLocation =3D=3D CP_BACK &amp;&amp;=20
SourcePortalLocation=3D=3DCP_FRONT) || (PortalLocation =3D=3D CP_FRONT =
&amp;&amp;=20
SourcePortalLocation=3D=3DCP_BACK))// inside Anti =
Penumbra<BR>{<BR>//keep=20
it<BR>continue;<BR>}<BR><BR>if(PortalLocation =3D=3D =
CP_SPANNING)<BR>{<BR>//Clip the=20
portal<BR>FrontSplit=3Dnew PORTAL;<BR>BackSplit=3Dnew=20
PORTAL;<BR>ZeroMemory(FrontSplit,sizeof(PORTAL));<BR>ZeroMemory(BackSplit=
,sizeof(PORTAL));<BR>SplitPortal(GeneratorPortal,&amp;ClipPlanes.Planes[i=
],FrontSplit,BackSplit);<BR><BR>if=20
(SourcePortalLocation=3D=3DCP_FRONT)<BR>{<BR>delete =
FrontSplit;<BR>delete=20
GeneratorPortal;<BR>GeneratorPortal=3DBackSplit;<BR>}<BR<BR> =
else<BR><BR>if=20
(SourcePortalLocation=3D=3DCP_BACK)<BR>{<BR>delete BackSplit;<BR>delete=20
GeneratorPortal;<BR>GeneratorPortal=3DFrontSplit;<BR>}<BR>}<BR>}<BR>delet=
e=20
ClipPlanes.Planes;<BR>return GeneratorPortal;<BR>} // end=20
function<BR><BR><BR><BR></FONT></CODE>WOW, we are nearly all done with =
this PVS=20
stuff. We have certainly done all the hard bits all that left to do now =
is=20
compress each Visibility Buffer and add it to the Master PVSData =
array.Before we=20
do that however lets see the 'ClipToAntiPenumbra' function in its=20
entirety<BR><BR><CODE><FONT size=3D2>PORTAL * ClipToAntiPenumbra(PORTAL=20
*SourcePortal,PORTAL *TargetPortal,PORTAL =
*GeneratorPortal)<BR>{<BR>D3DXVECTOR3=20
EdgeVector1,EdgeVector2,Normal;<BR>int PortalLocation;<BR>PORTAL=20
*FrontSplit,*BackSplit,*TempSource,*TempTarget;<BR>CLIPPLANES =
ClipPlanes; //=20
Create a ClipPlane=20
set<BR><BR>ClipPlanes.NumberOfPlanes=3D0;<BR>ClipPlanes.Planes=3Dnew =
PLANE=20
[SourcePortal-&gt;NumberOfVertices*TargetPortal-&gt;NumberOfVertices*2];<=
BR>PLANE=20
TempPlane;<BR>int NextVertex=3D0;<BR><BR>for (int=20
loop=3D0;loop&lt;2;loop++)<BR>{<BR>if=20
(loop=3D=3D0)<BR>{<BR>TempSource=3DSourcePortal;<BR>TempTarget=3DTargetPo=
rtal;<BR>}<BR>else<BR>{<BR>TempSource=3DTargetPortal;<BR>TempTarget=3DSou=
rcePortal;<BR>}<BR><BR>for=20
(int=20
SV=3D0;SV&lt;TempSource-&gt;NumberOfVertices;SV++)<BR>{<BR>PortalLocation=
=3DClassifyPoint((D3DXVECTOR3=20
*)&amp;TempSource-&gt;VertexList[SV],&amp;GetPortalPlane(TempTarget));<BR=
>if=20
(PortalLocation=3D=3DCP_ONPLANE) continue;<BR><BR>for (int=20
TP=3D0;TP&lt;TempTarget-&gt;NumberOfVertices;TP++)<BR>{<BR>if=20
(TP=3D=3DTempTarget-&gt;NumberOfVertices-1)<BR>{<BR>NextVertex=3D0;<BR>}<=
BR>else<BR>{<BR>NextVertex=3DTP+1=20
;<BR>}<BR><BR>EdgeVector1=3D*((D3DXVECTOR3=20
*)&amp;TempSource-&gt;VertexList[SV])-*((D3DXVECTOR3=20
*)&amp;TempTarget-&gt;VertexList[TP]);<BR>EdgeVector2=3D*((D3DXVECTOR3=20
*)&amp;TempTarget-&gt;VertexList[NextVertex])-*((D3DXVECTOR3=20
*)&amp;TempTarget-&gt;VertexList[TP]);<BR><BR><BR>D3DXVec3Cross(&amp;Norm=
al,&amp;EdgeVector1,&amp;EdgeVector2);//=20
create normal<BR>D3DXVec3Normalize(&amp;TempPlane.Normal,&amp;Normal); =
// make=20
it a unit normal<BR>TempPlane.PointOnPlane=3D*(D3DXVECTOR3=20
*)&amp;TempSource-&gt;VertexList[SV];//Any vertex will=20
do<BR><BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON*)TempSource)=3D=3D=20
CP_FRONT)<BR>{<BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON*)TempTarget)=3D=
=3D=20
CP_BACK)<BR>{<BR>ClipPlanes.Planes[ClipPlanes.NumberOfPlanes] =3D=20
TempPlane;<BR>ClipPlanes.NumberOfPlanes++;<BR>//Save clip=20
plane<BR>}<BR>}<BR><BR>else =
<BR><BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON=20
*)TempSource) =3D=3D=20
CP_BACK)<BR>{<BR>if(ClassifyPoly(&amp;TempPlane,(POLYGON*)TempTarget) =
=3D=3D=20
CP_FRONT)<BR>{<BR>ClipPlanes.Planes[ClipPlanes.NumberOfPlanes] =3D=20
TempPlane;<BR>ClipPlanes.NumberOfPlanes++;<BR>//Save clip =
plane<BR>}<BR>}<BR>}=20
// end for tp<BR>} // end for sp<BR>} // END FOR LOOP<BR><BR>// We now =
have our=20
PLane List so lets clip the Generator Portal against each one. =
<BR><BR>for(int I=20
=3D 0; I &lt; ClipPlanes.NumberOfPlanes; i++)<BR>{<BR>PortalLocation=3D=20
ClassifyPoly(&amp;ClipPlanes.Planes[i],(POLYGON =
*)GeneratorPortal);<BR>int=20
SourcePortalLocation=3DClassifyPoly(&amp;ClipPlanes.Planes[i],(POLYGON=20
*)SourcePortal);<BR><BR>if(PortalLocation =3D=3D SourcePortalLocation || =

PortalLocation=3D=3DCP_ONPLANE)// its entirley out side the anitpenumbra =
so loose=20
it<BR>{<BR>delete Generator portal;<BR>delete =
ClipPlanes.Planes;<BR>return=20
NULL;<BR>}<BR><BR>if((PortalLocation =3D=3D CP_BACK &amp;&amp;=20
SourcePortalLocation=3D=3DCP_FRONT) || (PortalLocation =3D=3D CP_FRONT =
&amp;&amp;=20
SourcePortalLocation=3D=3DCP_BACK))// inside Anti =
Penumbra<BR>{<BR>//keep=20
it<BR>continue;<BR>}<BR><BR>if(PortalLocation =3D=3D =
CP_SPANNING)<BR>{<BR>//Clip the=20
portal<BR>FrontSplit=3Dnew PORTAL;<BR>BackSplit=3Dnew=20
PORTAL;<BR>ZeroMemory(FrontSplit,sizeof(PORTAL));<BR>ZeroMemory(BackSplit=
,sizeof(PORTAL));<BR>SplitPortal(GeneratorPortal,&amp;ClipPlanes.Planes[i=
],FrontSplit,BackSplit);<BR><BR>if=20
(SourcePortalLocation=3D=3DCP_FRONT)<BR>{<BR>delete =
FrontSplit;<BR>delete=20
GeneratorPortal;<BR>GeneratorPortal=3DBackSplit;<BR>}<BR<BR> =
else<BR><BR>if=20
(SourcePortalLocation=3D=3DCP_BACK)<BR>{<BR>delete BackSplit;<BR>delete=20
GeneratorPortal;<BR>GeneratorPortal=3DFrontSplit;<BR>}<BR>}<BR>}<BR>delet=
e=20
ClipPlanes.Planes;<BR>return GeneratorPortal;<BR>} // end=20
function<BR><BR></FONT></CODE>Ummm, there is no doubt about it, that =
function=20
can look like one ugly son of a bitch on first viewing, but if you break =
it down=20
into its two parts 'Creating The Planes' and 'Clipping the Generator =
portal to=20
the Planes' it starts looking a bit more friendly.<BR><BR>If you have =
stayed=20
with me up to this point then you should give youself a big pat on the =
back=20
because our work is nearly done, certainly the actual PVS calculations =
are all=20
done.If you are not with me at all but carried on reading down to this =
point=20
then do not worry , this stuff will probably have to be read a few times =
over=20
(in parts anyway) before it really starts to click, after all we have =
covered a=20
load of stuff. If however you have not carried on reading down to this =
point=20
then there is little point in me offering any encouragement because you =
are not=20
reading it anyway.<BR><BR>You know something? I'm starting to feel like =
I might=20
actually finish this tutorial and get my social life back.<BR><BR><FONT=20
color=3Dgreen size=3D5><U>
<CENTER>Compressing the PVS using 'Zero Run Length=20
Encoding'</CENTER></U></FONT><BR><BR>If you remember back (or if not =
refer back=20
now) to the 'CalculatePVS' function you will remember that we calculated =
each=20
Leafs Visibility Buffer one at a time and while that leafs Visibility=20
information was being calculated we stored the information in a =
Temporary=20
Visibility Buffer called 'LeafPVS'. You may also remember that once we =
had=20
finished calculating that leafs Visibility Buffer the Buffer was then =
passed in=20
a function called 'CompressLeafSet'.This function (which we will look at =
in a=20
moment) is responsible for taking the information out of the temporary=20
Visibility Buffer , Compressing it using Zero Run Length Encoding and =
adding it=20
to the Master PVSData Array.Lets just take a look again at how we called =
this=20
function from the 'CalculatePVS'=20
function.<BR><BR><CODE>PVSMasterWritePointer+=3DCompressLeafSet(LeafPVS,P=
VSMasterWritePointer);</CODE>=20
<BR><BR>The function is passed in the Visibility Buffer and the Position =
to=20
start writing into the Master PVSData array.Remember that=20
'PVSMasterWritePointer' will be equal to zero the first time this =
function is=20
called (for leaf 0's visibility set) so we will be telling the function =
to start=20
writing the compressed information a Byte Zero in the PVSData array.This =

function then returns how many Compressed Bytes were written to the =
PVSData=20
array so we simply add this on to the Write pointer so we can skip past =
all the=20
data that has just been written to the master PVSData array so that the =
Write=20
pointer now points to the offset in the array that we should start =
writing the=20
Next Leafs compressed data the next time this function is =
called.<BR><BR>The=20
code is very small and simply<BR><BR><CODE>long CompressLeafSet (BYTE *=20
VisArray, long WritePos)<BR>{<BR>int j;<BR>int rep;<BR>BYTE=20
*dest=3D&amp;PVSData[WritePos];<BR>BYTE *dest_p;<BR>dest_p =3D =
dest;<BR><BR>for (j=3D0=20
; j&lt;BytesPerSet ; j++)<BR>{<BR>*dest_p++ =3D VisArray[j];<BR>if=20
(VisArray[j])<BR>continue;<BR><BR>rep =3D 1;<BR>for ( j++; =
j&lt;BytesPerSet ;=20
j++)<BR>if (VisArray[j] || rep =3D=3D =
255)<BR>break;<BR>else<BR>rep++;<BR>*dest_p++=20
=3D rep;<BR>j--;<BR>}<BR><BR><BR>return dest_p - =
dest;<BR>}<BR><BR></CODE>It is=20
sometimes hard to believe that such a small function could save so much=20
memory.<BR><BR>First we set two pointers up ('dest' and 'dest_p') so =
that they=20
point at the correct byte in the 'PVSData' array to start writing the =
new=20
information.The 'Dest' pointer is not altered after that because it is =
simply=20
there to store where we started writing from. Next we set up a the outer =
loop to=20
loop through every byte in the Visibility buffer.We use 'dest_p' to =
write to the=20
'PVSData' array . If the current Byte in ''VisArray' is NOT zero then we =
simply=20
copy it over into the 'PVSData' array unaltered because we can only =
compress=20
Zero's remember, and we skip round to the next iteration of the loop. If =
however=20
there is a zero then this is the Start of a Zero Run and we know that =
the next=20
byte that has to be written into the master array is 'How Many Zeros =
Follow it'=20
.We set 'rep' to 1 because we know there is at least one zero in the run =
and we=20
keep looping through the rest of the bits (in the internal loop) until =
we hit a=20
byte which is no longer zero OR until we have counted a run of '255' =
because we=20
can store no more than 255 in a single byte.Each time we hit another =
zero though=20
we add one onto 'rep' which is used to count the current length in bytes =
of the=20
run. <BR><BR>Once we hit a non zero byte in the middle loop though the =
current=20
run length is recorded and we pass pass control back to the outer=20
loop.<BR>Notice also how we have to back up ''j' when we leave the inner =
loop=20
''j--'. This is because ''j' is the non zero byte that will be needed to =
be=20
copied into the PVS array on the next iteration of the outer loop, BUT, =
as the=20
outer loop iterates it adds '1' onto ''j' so would skip past the byte we =
need to=20
write. Thats why we do that. <BR><BR><FONT color=3Dgreen size=3D5>
<CENTER><U>WOW ! We Have Finished Our PVS=20
Calculator</U></CENTER></FONT><BR><BR>We now have our PVS calculated and =
things=20
are looking good but there is still more we can do to further refine how =
many=20
polygons have to be Processed each frame. As mentioned earlier the PVS=20
PreCalculates everything leaf that can be seen from a Leaf. This means =
that=20
however large your level may be, possibly only five or six leafs may be=20
'Possibly' visible and so none of the other polygons in the level have =
to be=20
processed in any way.<BR>Having said that a PVS is not perfect because =
it does=20
not take into account the direction the camera will be facing during any =
given=20
frame. This is obviously impossible for the PVS to do because =
calculating the=20
PVS is a compile time process not a run time one.The PVS does however =
allow us=20
to scale down the number of polygons and leafs that have to be processed =
each=20
frame down to a Fraction of the number that we would normally need to=20
process.This is very very cool.<BR><BR>However, during the run time =
rendering=20
process there is yet more we can do to refine the PVS =
further.<BR><BR>During the=20
rendering of a Leafs PVS (refer back to 'DrawTree' function) once a leaf =
has=20
passed the test of being visible from the current leaf (its pvs bit is =
set to=20
one) we can then check if the Bounding Box of the Leaf is within the =
cameras=20
FOV. If not then we reject the Leaf (and all the polygons in it) and =
move on to=20
the Next one. This is why we calculated the Bounding Boxes for each Leaf =
during=20
the BSP Tree Compile process and stored the Bounding Box dimensions in =
each=20
leaf.<BR><BR>To better see what I mean lets take a look at Fig E) again =
(shown=20
Below).<BR><BR>
<CENTER><IMG height=3D250=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvse.gif"=20
width=3D324></CENTER><BR><BR>As you can probably see if we were in Leaf =
1 in the=20
above diagram the PVS set for Leaf 1 would have leafs 1,2,3,5 &amp; 6. =
However=20
if we were in leaf 1 facing the south wall (Camera is the Red Arrow in =
the=20
diagram) you can see that leafs 2,3,5 &amp; 6 would not be visible at =
all in any=20
way because they are out side the cameras Field of View (the Red Cone=20
Shape).This means that not only has the PVS data cut down the number of =
Leafs=20
needed to be processed by an amazing amount but, we can also minimize =
the PVS=20
data by checking each Potentially Visible Leafs Bounding Box against the =
View=20
frustum and reject any Leaf whose Bounding Box is completely outside the =

Frustum.<BR><BR>If you cast your mind back to the 'DrawTree' function =
you may=20
have remembered seeing the following line which we did not discuss in =
much=20
detail at the time.<BR><BR><CODE>if (pvs&amp;mask)<BR>{<BR>if=20
(LeafInFrustum(currentleaf)=3D=3Dtrue)<BR>{ <BR>...<BR>Draw the=20
Leaf<BR>...<BR></CODE>During the RenderTree function we loop through =
each Bit in=20
the Camera Leafs PVS (the Leaf the Camera is in) and if it has its bit =
set to=20
'1' (if pvs&amp;mask) then the Leaf is in the PVS set and is potentially =
visible=20
from the Camera Leaf. HOWEVER, instead of just rendering the Leaf we do =
a second=20
check by calling the 'LeafInFrustum' function.This function takes a Leaf =
index=20
as a parameter and returns TRUE if any part of the Leafs Bounding Box is =
within=20
the View Frustum(Cameras View). Therefore we don't have to render any =
leafs=20
which make this Function return false. In the above diagram, this =
function would=20
return false for all leave except Leaf 1 as this is the only Leaf that =
can be=20
partially seen from the Camera.These tests are actually remarkably Quick =
because=20
our Leafs Bounding Boxes are whats known as being 'Axis Aligned Bounding =
Boxes'=20
which means they are aligned to the Major Axis of the 3D world.In other =
Words=20
the Bounding Box Z Maximum reaches in the same direction as the Worlds =
Positive=20
Z Axis and the Box's X Maximum is in the direction of the Worlds =
Positive X axis=20
etc etc.This provides advantages because Culling Axis Aligned Bounding =
Boxes=20
(AABB's) from the frustum can be done very quickly <BR><BR>Our next task =
will be=20
to write the Functions that Test the Leafs Bounding Box against the View =
Frustum=20
to see if it is within the camera FOV.<BR><BR><BR><FONT color=3Dgreen =
size=3D5>
<CENTER><U>Frustum Culling Axis Aligned Bounding=20
Boxes</U></CENTER></FONT><BR><BR>When you set up your Projection Matrix =
in a 3D=20
application using something like:- =
<CODE>D3DXMatrixPerspectiveFovLH(&amp;proj_m,=20
1.0f,0.77777f,0.3f, 500.0f );</CODE><BR><BR>you are infact describing to =
D3D the=20
shape of the View Frustum you wish it to use.D3D Internally Creates 6 =
Clipping=20
Planes which totally define what is in the Camera's FOV.Below you can =
see a=20
picture of a View Frustum<BR><BR>
<CENTER><IMG height=3D190=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsb1.gif"=20
width=3D392><BR></CENTER>The Six Planes (Near,Far,Left,Right,Top and =
Bottom) are=20
used internally by D3D to reject any polygons Outside the Frustum =
(because they=20
can not be seen) and to Clip any polygons to the Frustum (because they =
me be=20
partially inside the Frustum).<BR><BR>We can use the same method to =
easily check=20
whether an Axis Aligned Bounding Box (AABB) is inside or outside the =
Frustum.The=20
Problem is though we do not at this moment have access to the 6 clipping =
planes=20
that make up the View Frustum and even if we did we would need to =
translate them=20
into World Space so that they are at the Cameras current Position and=20
Orientation.There are several techniques available for Creating the Clip =
Planes=20
for the Frustum but the one we are going to use is by far the easiest =
and=20
quickest.<BR><BR>Because the Projection Matrix contains the 6 frustum =
Planes and=20
the View Matrix contains the Location and Orientation of the camera we =
can=20
Extract the 6 Frustum planes from the combined View/Projection Matrix.In =
other=20
words, if we concentrate the View Matrix and the Projection Matrix this =
combined=20
Matrix actually holds the 6 Frustum planes in WORLD space which is =
exactly what=20
we need.This method is also very fast.<BR><BR><U>
<CENTER><FONT color=3Dgreen size=3D4>Extracting the Frustum=20
Planes</FONT></CENTER></U><BR><BR>We are now going to see the code to =
the the=20
'ExtractFrustumPlanes' function which does exactly that.It combines the =
View and=20
Projection matrix and extracts the WORLD space frustum planes and stores =
them in=20
the Plane Array passed into the function.<BR>There are many ways that a =
plane=20
can be represented and the way we have stored planes up until now has =
been to=20
store a Plane Normal and a Point on the Plane.Another way to store the =
same=20
Plane is to store the Normal to the Plane and the Distance to the Plane =
from the=20
origin of the Coordinate system.You can think of the Distance parameter =
as How=20
close the plane would come to the Origin (0,0,0) in your 3D world if you =
traced=20
it back to the origin. The Combined View projection matrix holds the =
Frustum=20
planes defined in such a way so i have created (for ease more than =
anything=20
else) a second Plane structure that looks like so and is called=20
'PLANE2.'<BR><BR><CODE>struct PLANE2<BR>{<BR>float =
Distance;<BR>D3DXVECTOR3=20
Normal;<BR>};<BR><BR></CODE>We also define at the start of our program =
an Global=20
array of six PLANE2 structures that will be used to hold the frustum =
Planes each=20
frame. <BR><BR><CODE>PLANE2 FrustumPlanes[6];</CODE><BR><BR>You may have =
noticed=20
that I used the words 'Each Frame' above. That is correct, we must =
extract the=20
Frustum Planes every frame because obviously the Camera will be =
constantly=20
moving and therefore so will the WORLD Space position of the Frustum =
Planes. In=20
your application the 'ExtractFrustumPlanes' function should be called =
each frame=20
after you have moved the Camera and updated the View Matrix but before =
the Tree=20
has been rendered.So your main render function should look something =
like=20
this.<BR><BR><CODE>void=20
renderframe(void)<BR>{<BR>UpdateViewPos();<BR>ExtractFrustumPlanes(Frustu=
mPlanes);<BR>lpDevice-&gt;Clear(0,NULL,D3DCLEAR_TARGET=20
|=20
D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,0),1.0f,0);<BR>lpDevice-&gt;BeginScene=
();<BR>RenderTree(CameraPosition);<BR>lpDevice-&gt;EndScene();<BR>}<BR><B=
R></CODE>This=20
all makes sense but before I get a load of emails telling me how my Demo =
does=20
not do it this way round let me just say that this is because of some =
trickery I=20
had to pull off for the Top Down View mode so that when you look down =
from above=20
the Frustum Planes are NOT where the camera is (because it is up in the =
air=20
looking down) but instead the Frustum Planes remain in the same position =
as they=20
were when you were in First Person View.This allows you to View the =
Clipping=20
process from above.In case you are interested , i did this by using two =
view=20
matrices.The First one is where the Person is on the ground (or the =
camera if=20
you are in First Person Mode) and the second is the acutal camera =
position.In=20
the Demo i Build the Player location View Matrix First and use THIS (not =
the=20
camera) matrix to extract the planes and clip the tree.Then after the =
tree has=20
been culled i set the View matrix to the actual Camera Position for =
rendering.=20
Any way all of this is besides the point, in a first person game you =
will use a=20
render loop like the one i have used above.You can view the source code =
to see=20
the changes i had to make to the Top Down mode.<BR><BR>There is one more =
thing I=20
should mention before we look at the code to this function.The Planes =
extracted=20
from the View/Projection matrix are NOT Normalized meaning that the =
Normals may=20
not be a length of 1.0 and that the distance parameter is scaled =
accordingly.The=20
interesting thing though is that the Normals do not actually have to be=20
Normalized for our AABB culling to work because no matter how =
UnNormalized (for=20
lack of a better word) the Planes may be they will still describe the =
same=20
Plane.<BR><BR>You are probably thinking "Why Do People Normalize Planes =
then?",=20
well if we needed to know the distance from a Point to a Plane (which is =
often=20
the case) UnNormalized planes would give the wrong result.However, we =
only need=20
to know whether a point is Behind or In Front of a Plane and this will =
remain=20
true however UnNormalized our Planes may be.<BR><BR>Having said that =
though i DO=20
Normalize the Planes after extraction in the following code. The reason =
i do=20
this is for completeness really. You will probably at some point in your =
game=20
want to test other objects against the Frustum Planes (Monsters etc) and =
usually=20
Bounding Spheres are used for this purpose.With a Bounding sphere =
however we=20
need the Distance to the Plane accurately calculated because there is =
only an=20
intersection if the Distance to the Plane to the Sphere center is =
shorter than=20
the Sphere Radius.For this reason I do Normalize the Planes.Anyway lets =
have a=20
look at the code .<BR><BR>
<TABLE bgColor=3D#cc0000>
  <TBODY>
  <TR>
    <TD><FONT color=3Dwhite size=3D2><U>A Word Of Thanks:-</U><BR>I =
would like to=20
      say a very big thankyou to Klaus Hartmann for bringing the =
following code=20
      to my attention. Klaus is keen to point out that he did not invent =
this=20
      and it is a guy called 'Gil Gribb' who deserves the =
credit.However, it was=20
      Klaus that was good enough to explain Not Only the following code =
but also=20
      the technique to Cull AABB's to the View Frustum and the code to =
the=20
      following two functions is based very tightly on code that he gave =
to=20
      me.Thanks again Klaus. </FONT></TD></TR></TBODY></TABLE><BR><BR>It =
should be=20
noted that in the following code the Frustum Planes Extracted all have =
their=20
Normals Facing Outward. This means if an Object is Behind (or Partially =
Behind)=20
all of the Six Frustum Planes then it is inside the Frustum.If any =
Object is=20
Completely Infront of ANY of the Six Frustum Planes then it can not =
possibly be=20
within the Fustum. <BR><BR><BR><CODE><FONT size=3D2>void=20
ExtractFrustumPlanes(PLANE2 *Planes)<BR>{<BR><BR>D3DXMATRIX=20
ViewMatrix,ProjMatrix,ViewProj;<BR><BR>lpDevice-&gt;GetTransform(D3DTS_PR=
OJECTION,&amp;ProjMatrix);<BR>lpDevice-&gt;GetTransform(D3DTS_VIEW,&amp;V=
iewMatrix);<BR><BR>D3DXMatrixMultiply(&amp;ViewProj,&amp;ViewMatrix,&amp;=
ProjMatrix);=20
//Combine Them<BR><BR>// Left clipping plane<BR>Planes[0].Normal.x =3D=20
-(ViewProj._14 + ViewProj._11);<BR>Planes[0].Normal.y =3D -(ViewProj._24 =
+=20
ViewProj._21);<BR>Planes[0].Normal.z =3D -(ViewProj._34 +=20
ViewProj._31);<BR>Planes[0].Distance =3D -(ViewProj._44 + =
ViewProj._41);<BR><BR>//=20
Right clipping plane<BR>Planes[1].Normal.x =3D -(ViewProj._14 -=20
ViewProj._11);<BR>Planes[1].Normal.y =3D -(ViewProj._24 -=20
ViewProj._21);<BR>Planes[1].Normal.z =3D -(ViewProj._34 -=20
ViewProj._31);<BR>Planes[1].Distance =3D -(ViewProj._44 - =
ViewProj._41);<BR><BR>//=20
Top clipping plane<BR>Planes[2].Normal.x =3D -(ViewProj._14 -=20
ViewProj._12);<BR>Planes[2].Normal.y =3D -(ViewProj._24 -=20
ViewProj._22);<BR>Planes[2].Normal.z =3D -(ViewProj._34 -=20
ViewProj._32);<BR>Planes[2].Distance =3D -(ViewProj._44 - =
ViewProj._42);<BR><BR>//=20
Bottom clipping plane<BR>Planes[3].Normal.x =3D -(ViewProj._14 +=20
ViewProj._12);<BR>Planes[3].Normal.y =3D -(ViewProj._24 +=20
ViewProj._22);<BR>Planes[3].Normal.z =3D -(ViewProj._34 +=20
ViewProj._32);<BR>Planes[3].Distance =3D -(ViewProj._44 + =
ViewProj._42);<BR><BR>//=20
Near clipping plane<BR>Planes[4].Normal.x =3D -(ViewProj._14 +=20
ViewProj._13);<BR>Planes[4].Normal.y =3D -(ViewProj._24 +=20
ViewProj._23);<BR>Planes[4].Normal.z =3D -(ViewProj._34 +=20
ViewProj._33);<BR>Planes[4].Distance =3D -(ViewProj._44 + =
ViewProj._43);<BR><BR>//=20
Far clipping plane<BR>Planes[5].Normal.x =3D -(ViewProj._14 -=20
ViewProj._13);<BR>Planes[5].Normal.y =3D -(ViewProj._24 -=20
ViewProj._23);<BR>Planes[5].Normal.z =3D -(ViewProj._34 -=20
ViewProj._33);<BR>Planes[5].Distance =3D -(ViewProj._44 -=20
ViewProj._43);<BR><BR><BR>// NORMALIZE THE PLANES (Not Really Needed in =
Our=20
Demo) <BR><BR>for (int i=3D0;i&lt;6;i++)<BR>{<BR>float denom =3D 1.0f /=20
D3DXVec3Length(&amp;Planes[i].Normal);// Get magnitude of=20
Vector<BR>Planes[i].Normal.x *=3D denom;<BR>Planes[i].Normal.y *=3D=20
denom;<BR>Planes[i].Normal.z *=3D denom;<BR>Planes[i].Distance *=3D=20
denom;<BR>}<BR>}// End Function Extract Clip=20
Planes<BR><BR></FONT></CODE><BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D4>Culling the AABB's From the=20
Frustum</FONT></U></CENTER><BR><BR>In order to test whether or not a =
AABB is=20
within the Frustum we have to check it against each of the six planes =
against=20
the Bounding Box.Now you are probably thinking that in order to to test =
whether=20
or not ANY of the AABB is within the frustum all we have to do is check =
the Four=20
corner points of the box. This is definately NOT the way as the =
following=20
diagram will clearly demonstrate.<BR><BR>
<CENTER><IMG height=3D244=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsc1.gif"=20
width=3D383></CENTER>Above you can see that although the four corner =
points of the=20
Bounding Box out Outside the View Frustum , the Bounding Box would be =
partially=20
visible as one of its edges intersects the Frustum.<BR><BR>In order to =
get=20
around this problem we have to test Each Plane one at a time against =
just a=20
single point on the Bounding Box.This Point will be one of the Corners =
of our=20
Bounding Box but which Corner Point we use is completely dependant on =
the=20
Orientation of the Current Frustum Plane being Tested.If you imagine =
that the=20
AABB is completely outside the frustum and just about to intersect the =
current=20
Plane being tested, the point we wish to find would be the FIRST point =
(corner)=20
on the Box that would inersect it. This Point is Called the 'Negative' =
or 'Near'=20
Point and is the Corner of the Bounding Box that would be first to =
intersect the=20
current plane if the Box was Infront of it.What we will do is look at =
EACH=20
component of the Plane Normal and find which Corner Point of the AABB we =
have to=20
use .We do this for EACH Plane we test because each plane will have a =
different=20
Orientation so the Corner of the AABB that we use 'The Near Point' will =
be=20
different for each Plane.The basic Principle is this:- <BR><BR>1) For =
Each=20
Frustum Plane we Test the Plane Normal<BR><BR>2) If the 'X' Component of =
the=20
Plane Normal is Negative then we use the Bounding Box's X Maximum Point =
as our=20
Test Point's X Component otherwise we use the Bounding Box's X Minimum=20
Component.<BR><BR>3) If the 'Y' Component of the Plane Normal is =
Negative then=20
we use the Bounding Box's Y Maximum Point as our Test Point's Y =
Component=20
otherwise we use the Bounding Box's Y Minimum Component.<BR><BR>4) If =
the 'Z'=20
Component of the Plane Normal is Negative then we use the Bounding Box's =
Z=20
Maximum Point as our Test Point's Z Component otherwise we use the =
Bounding=20
Box's Z Minimum Component.<BR><BR>At this Point we have now constructed =
a Point=20
(Vector) to test against the Clip Plane.If this point is In Front of the =
Current=20
Plane(Remember Frustum Planes Point Outwards) then we can bail out of =
the=20
function immediately and do not have to check the other Planes because =
if this=20
'Near' point is outside (In Front) of the Planes then the entire AABB =
must be=20
outside the Frustum. If however the 'Near' point is Behind the Plane =
then we=20
must test the other planes. For every plane that we test we have to =
build a new=20
'Near' point to test depending on the orientation of the Plane Normal.If =
at any=20
Point the current 'Near' point is Infront of the Current Plane being =
tested then=20
we can bail because the AABB is completely outside the frustum. If =
however we=20
test all Six Planes and do not find a 'Near' point that is In front of =
one of=20
the planes , this means the AABB is at least partially inside the =
Frustum and so=20
the function should return 'TRUE'.<BR><BR>In case you are having trouble =

Visualizing this look at the following diagram that shows TWO AABB's (A =
and B)=20
and a Set of Six Frustum Planes.<BR><BR>
<TABLE width=3D"100%">
  <TBODY>
  <TR>
    <TD align=3Dmiddle width=3D430><IMG height=3D435=20
      =
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsa1.gif"=20
      width=3D419> </TD>
    <TD>Lets imagine that first of all we want to check the Left (L) =
Clip=20
      plane of the Frustum and the Camera is facing due North.In this =
case the=20
      Left Clip planes Normal would be facing in the Negative X =
Direction which=20
      means that we will use the AABB X Maximum Point as our Near Point =
X=20
      Component.The same is true for the the Z component of the Plane=20
      Normal.This too would be a Negative component meaning we would use =
the=20
      AABB Maximum Z Component as the Near points Z Component (Forget =
about Y=20
      for now because we are looking top down and the plane has no Y=20
      orientation).<BR>In this case then the Near Point (corner point of =
the=20
      AABB) used will be the Top Right of the Box as indicated by the =
Green=20
      square.Look at this Corner Point on 'BOX A' and remembering that =
Planes=20
      are Infinite you should be able to see that if this 'Near Point' =
is In=20
      Front of the Left Plane the the WHOLE AABB must be =
also.<BR><BR>When=20
      testing the Right Plane a Different 'Near' Point is Used because =
the Plane=20
      Normals X Component now faces Positive which means we use the =
AABB's X=20
      Minimum component and the Near Point X Component.Z is still facing =
the=20
      same way however (Negative) so we still use the AABB's Max Z=20
      component.This gives us the Corner indicated by the RED box's in =
the=20
      Diagram.<BR><BR>Look at 'Box B' you should also be able to see =
that in=20
      this case if the RED corner is Infront of the Right Plane then the =
entire=20
      AABB must be also. </TD>
  <TR></TR></TBODY></TABLE><BR><BR>OK so lets do a Dry run on both these =
Bounding=20
Boxes Starting with Box A.First of all we test the Left Frustum Planes =
which=20
creates the Green 'Near' Point as shown above. For Box 'A' the Near =
Point is In=20
Front of the Left Plane so the Box is Not within the Frustum and the =
Funtion=20
returns False.<BR>Next we test Box 'B'. Once again we test the Left =
Plane=20
against the 'Near' point (green corner) and discover that this Point is =
BEHIND=20
the Left plane so could possibly be within the Frustum.In this case =
instead of=20
returning from the function we move on the test the next Plane which in =
this=20
case is the Right Plane.Because we are Testing the Right Plane now a =
different=20
'Near' point is created (the Red Corner) and tested against the right =
plane.In=20
this case however the Near Point (red corner) is In Front of the Right =
Plane so=20
the entire AABB must be in front also and so can not possibly be within =
the=20
frustum which makes the function return true.We do this for all SIX =
planes=20
unless we find the Current 'Near' Point that is Infront of the current =
Plane=20
being tested , in which case the function can return false because the =
AABB=20
isNOT within the Frustum.<BR><BR>If a AABB is within the frustum then =
the 'Near'=20
Points will be behind all of the Six Planes.<BR><BR>Lets now have a look =
at the=20
function called 'LeafInFrustum'. This is called while we are rendering =
to see=20
whether a Leaf about to be drawn can actually be seen from the camera.We =
pass in=20
the index of the leaf to test and the function returns True if the Leafs =

Bounding Box is partially (or totally) within the frustum. In other =
words if the=20
function returns 'FALSE' then we do NOT want to draw the leaf. Here is =
the code=20
and is basicallly just an ugly bunch of 'If' statements that are used to =
Build=20
the Current 'Near' point for the Current Plane being tested. Once the =
Near point=20
is found we simply use the DotProduct on the Near Point and the Plane =
Normal to=20
determine if the Point is In Front or Behind the =
Plane.:-<BR><BR><CODE><FONT=20
size=3D2>bool LeafInFrustum (long Leaf)<BR>{<BR>D3DXVECTOR3=20
bMax=3DLeafArray[Leaf].BoundingBox.BoxMax;<BR>D3DXVECTOR3=20
bMin=3DLeafArray[Leaf].BoundingBox.BoxMin;<BR>D3DXVECTOR3=20
NearPoint,FarPoint;<BR><BR>PLANE2 *Plane=3DFrustumPlanes;<BR><BR>for =
(int=20
i=3D0;i&lt;6;i++)<BR>{<BR><BR>if (Plane-&gt;Normal.x &gt; =
0.0f)<BR>{<BR>&nbsp;if=20
(Plane-&gt;Normal.y &gt; 0.0f)<BR>{<BR>&nbsp;&nbsp;if =
(Plane-&gt;Normal.z &gt;=20
0.0f)<BR>{<BR>&nbsp;&nbsp;&nbsp;NearPoint.x =3D bMin.x; NearPoint.y =3D =
bMin.y;=20
NearPoint.z =3D bMin.z;<BR>} =
<BR>else<BR>{<BR>&nbsp;&nbsp;&nbsp;NearPoint.x =3D=20
bMin.x; NearPoint.y =3D bMin.y; NearPoint.z =3D bMax.z;=20
}<BR>}<BR>else<BR>{<BR>&nbsp;if&nbsp; (Plane-&gt;Normal.z &gt;=20
0.0f)<BR>{<BR>&nbsp;&nbsp;&nbsp;NearPoint.x =3D bMin.x; NearPoint.y =3D =
bMax.y;=20
NearPoint.z =3D =
bMin.z;<BR>}<BR>else<BR>{<BR>&nbsp;&nbsp;&nbsp;NearPoint.x =3D=20
bMin.x; NearPoint.y =3D bMax.y; NearPoint.z =3D=20
bMax.z;<BR>}<BR>}<BR>}<BR>else<BR>{<BR>&nbsp;if (Plane-&gt;Normal.y &gt; =

0.0f)<BR>{<BR>&nbsp; (Plane-&gt;Normal.z &gt;=20
0.0f)<BR>{<BR>&nbsp;&nbsp;NearPoint.x =3D bMax.x; NearPoint.y =3D =
bMin.y;=20
NearPoint.z =3D bMin.z;<BR>}<BR>else<BR>{<BR>&nbsp;&nbsp;NearPoint.x =3D =
bMax.x;=20
NearPoint.y =3D bMin.y; NearPoint.z =3D =
bMax.z;<BR>}<BR>}<BR>else<BR>{<BR>&nbsp;if=20
(Plane-&gt;Normal.z &gt; 0.0f)<BR>{<BR>&nbsp;&nbsp;NearPoint.x =3D =
bMax.x;=20
NearPoint.y =3D bMax.y; NearPoint.z =3D=20
bMin.z;<BR>}<BR>else<BR>{<BR>&nbsp;&nbsp;NearPoint.x =3D bMax.x; =
NearPoint.y =3D=20
bMax.y; NearPoint.z =3D bMax.z;<BR>}<BR>}<BR>}<BR><BR>// near extreme =
point is=20
outside, and thus<BR>// the AABB is Totally outside the =
polyhedron<BR><BR>if=20
(D3DXVec3Dot(&amp;Plane-&gt;Normal,&amp;NearPoint)+Plane-&gt;Distance&gt;=
0)=20
return false;<BR>Plane++; }<BR><BR>return =
true;<BR>}<BR><BR></FONT></CODE>Thats=20
it!!!. Although we have used the above function to test the Leafs of our =

Bounding Box against the Frustum , the above technique works with any =
AABB and=20
so can readily be used in any other applications that need to perform =
Frustum=20
Culling of AABB's. Although Frustum Culling and Extracting the Frustum =
Planes=20
are NOT really BSP exclusive subjects and are generic to all 3D =
Applications i=20
felt by including it in this tutoria it would make the Tutorial more =
complete=20
and you well on your way to writing a lightning fast 3D =
engine.<BR><BR>Believe=20
it or not you have actually made it to the end of this monster tutorial =
(and so=20
have I) and we have covered all the code used in the Demo. I really =
suggest you=20
download the demo and run it so you can see exactly what the PVS does =
and what=20
Frustum Culling does.<BR><BR>Although we have fininshed the tutorial now =
I will=20
end up by addressing some of your common concerns not covered in the =
tutorial=20
such as 'Saving the BSP Tree to Disk' and 'How to make PVS work WITHOUT =
the Z=20
Buffer so that the BSP still renders back to front'. <BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>Saving and Loading the Compiled =
BSP=20
Tree</U></FONT></CENTER><BR><BR>Because we now have our BSP tree stored =
in=20
arrays, saving and loading the BSP has now become incredibly easy to =
do.You=20
could just write the 5 Arrays out to disk in their entirety=20
(Node,Plane,Leaf,Polygon &amp; Portal arrays).The the problem with this =
though=20
is that the structures we have used to compile and BSP Tree and =
calculate the=20
PVS have many fields that you will probably not need for simply =
rendering the=20
level in your application.For example, the Portal Array may not be =
needed at all=20
at Render Time in which case references to portals in the Leaf Structure =
will=20
not be be needed also.The Nodes Bounding Boxes are not needed also as =
this was=20
only used to calculate the initial portal.<BR><BR>What we need to do is =
save=20
each array of to disk and exclude the information we no longer need.Then =
when we=20
create our game engine we will create streamlined versions of the =
Node,Leaf=20
&amp; Polygon structures without this information.<BR>In the =
downloadable Zip=20
file I have included two projects.The First project 'BSP_PVS_Compiler' =
is the=20
actual compiler and PVS calculator itself.This Project contains a =
'SaveBSPTree'=20
function that by defualt is Commented out so you will have to remove the =
two=20
backslashes. After you do this the compiler will automatically save the =
BSP to=20
Disk after it is completed (in the current working directory).The second =
Project=20
is called 'Bsp_Loader_and_renderer' and is a framework for a BSP 3d =
renderer.It=20
simply loads the BSP in and renders it and is a good starting point to =
start=20
building your 3d engine.<BR><BR>Because we will not be saving certain =
fields of=20
the Compiler structures (because they are not needed to render) we will =
need a=20
new set of structures in our Loader and Rendering application which do =
not have=20
the fields we have decided not to save.<BR><BR>Below we will see the =
difference=20
in the Structures used by the 'Compiler' and the Structures used by the =
'Loader=20
and Renderer'.<BR><BR>
<TABLE width=3D"100%" border=3D1>
  <TBODY>
  <TR>
    <TD>BSP Compiler Structures</TD>
    <TD>Loader and Renderer Structures</TD></TR>
  <TR>
    <TD>struct NODE <BR>{<BR>unsigned char IsLeaf;<BR>unsigned long=20
      Plane;<BR>unsigned long Front;<BR>signed long Back;<BR>BOUNDINGBOX =

      BoundingBox;<BR>};<BR></TD>
    <TD>struct NODE <BR>{<BR>unsigned char IsLeaf;<BR>unsigned long=20
      Plane;<BR>unsigned long Front;<BR>signed long =
Back;<BR>};<BR></TD></TR>
  <TR>
    <TD colSpan=3D2>You can see that when the Compiler saves the Node =
Array it=20
      does not save the Bounding Box.This means our loader and renderer=20
      application can leave this field out of its Node =
Structure</TD></TR>
  <TR>
    <TD>struct LEAF{<BR>long StartPolygon;<BR>long EndPolygon; <BR>long=20
      PortalIndexList[50]; <BR>long NumberOfPortals;<BR>long PVSIndex;=20
      <BR>BOUNDINGBOX BoundingBox;<BR>};<BR></TD>
    <TD>struct LEAF{<BR>long StartPolygon;<BR>long EndPolygon; <BR>long=20
      PVSIndex; <BR>BOUNDINGBOX BoundingBox;<BR>};<BR></TD>
  <TR>
    <TD colSpan=3D2>When we save the Leaf array from the compiler we do =
not=20
      bother to save the Portal Information because this will not be =
used by the=20
      Loader and Renderer.The portals were only needed to calculate the =
PVS.We=20
      will not save the Portal Array at all. </TD></TR></TR>
  <TR>
    <TD>struct POLYGON<BR>{<BR>D3DLVERTEX *VertexList;<BR>D3DXVECTOR3=20
      Normal;<BR>WORD NumberOfVertices;<BR>WORD NumberOfIndices;<BR>WORD =

      *Indices;<BR>POLYGON * Next;<BR>bool BeenUsedAsSplitter;<BR>long=20
      TextureIndex;<BR>};<BR><BR></TD>
    <TD>struct POLYGON<BR>{<BR>D3DLVERTEX *VertexList;<BR>D3DXVECTOR3=20
      Normal;<BR>WORD NumberOfVertices;<BR>WORD NumberOfIndices;<BR>WORD =

      *Indices;<BR>POLYGON * Next;<BR>long =
TextureIndex;<BR>};<BR><BR></TD>
  <TR>
    <TD colSpan=3D2>Not so much of a saving here.We obviously do not =
need the=20
      'BeenUsedAsSplitter' variable any more as this was only used for=20
      compilation.Obviously we also do not save off the 'Next' pointer =
as this=20
      would be meaningless when loaded back in (because it points to an =
actual=20
      memory address) BUT our but we still have to have this field in =
out=20
      'Loader and Renderer' application because if you remember, the =
'Next'=20
      pointer was also used for Texture Batching during rendering.We =
will still=20
      want this functionailty when in our Loader and Renderer =
Application.=20
  </TD></TR></TR><BR><BR></TBODY></TABLE><BR>Those are the Only =
differences to the=20
structure we will be saving.The 'BOUNDINGBOX' and 'PLANE' structures =
remain the=20
same. <BR><BR>Without any further delay, lets have a look at the =
'SaveBSPTree'=20
function that the Compiler uses to save the BSP Tree to disk.This can be =
found=20
in 'main.cpp'.<BR><BR><CODE><FONT size=3D2>void SaveBSPTree(char=20
*filename)<BR>{<BR>FILE *stream;<BR>long a;<BR>stream =3D =
fopen(filename,=20
"w+b");<BR><BR>NumberOfNodes++;<BR>fwrite(&amp;NumberOfNodes,sizeof(long)=
,1,stream);<BR>NODE=20
*n=3DNodeArray;<BR>for=20
(a=3D0;a&lt;NumberOfNodes;a++)<BR>{<BR>fwrite(&amp;n-&gt;IsLeaf,sizeof =
(unsigned=20
char),1,stream);<BR>fwrite(&amp;n-&gt;Plane, sizeof (unsigned=20
long),1,stream);<BR>fwrite(&amp;n-&gt;Front, sizeof (unsigned=20
long),1,stream);<BR>fwrite(&amp;n-&gt;Back , sizeof (signed=20
long),1,stream);<BR>n++;<BR>}<BR><BR>// Write the Plane=20
Array<BR>fwrite(&amp;NumberOfPlanes,sizeof(long),1,stream);=20
<BR>fwrite(PlaneArray,sizeof(PLANE),NumberOfPlanes,stream);<BR><BR>// =
Write Leaf=20
Array.This also has some reduntant Run Time fields so we shall =
remove<BR>//=20
these when writing.<BR>fwrite(&amp;NumberOfLeafs,sizeof(long),1,stream); =
LEAF=20
*l=3DLeafArray;<BR>for=20
(a=3D0;a&amp;lyNumberOfLeafs;a++)<BR>{<BR>fwrite(&amp;l-&gt;StartPolygon,=
sizeof(long),1,stream);<BR>fwrite(&amp;l-&gt;EndPolygon,sizeof(long),1,st=
ream);<BR>fwrite(&amp;l-&gt;PVSIndex,sizeof(long),1,stream);<BR>fwrite(&a=
mp;l-&gt;BoundingBox,sizeof(BOUNDINGBOX),1,stream);<BR>l++;<BR>}<BR><BR>/=
/=20
WritePolygonArray.There are fields in this structure that were used for=20
sompiling and are<BR>// not needed at runtime."BeenUsedAsSplitter' is =
not needed=20
and neither is the 'Next'=20
Pointer.<BR>fwrite(&amp;NumberOfPolygons,sizeof(long),1,stream);<BR>POLYG=
ON=20
*p=3DPolygonArray;<BR>for=20
(a=3D0;a&lt;NumberOfPolygons;a++)<BR>{<BR>fwrite(&amp;p-&gt;NumberOfVerti=
ces,sizeof(WORD),1,stream);<BR>fwrite(p-&gt;VertexList,sizeof(D3DLVERTEX)=
,p-&gt;NumberOfVertices,stream);<BR>fwrite(&amp;p-&gt;NumberOfIndices,siz=
eof(WORD),1,stream);<BR>fwrite(p-&gt;Indices,sizeof(WORD),p-&gt;NumberOfI=
ndices,stream);<BR>fwrite(&amp;p-&gt;Normal,sizeof(D3DXVECTOR3),1,stream)=
;<BR>fwrite(&amp;p-&gt;TextureIndex,sizeof(long),1,stream);<BR>p++;<BR>}<=
BR><BR>//=20
Now all we have to do is write the PVS Data=20
itself<BR>fwrite(&amp;PVSCompressedSize,sizeof(long),1,stream);<BR>fwrite=
(PVSData,sizeof(BYTE),PVSCompressedSize,stream);<BR><BR>//=20
All done<BR>fclose (stream);<BR>}<BR><BR></FONT></CODE>As you can see we =
just=20
write the Arrays out in the following Order .1)NodeArray 2)PlaneArray =
3)Leaf=20
Array 4)PolygonArray 5)PVSData. It is a shame actually that we have to =
miss out=20
certain fields or other wise we could have written this function in just =
a few=20
lines of code.Look at how the PLANE's array is written.We just throw the =
Whole=20
array into the file in one go because we need it all.<BR><BR>One thing =
that may=20
be confusing is how we Nudge the 'NumberOfNodes' variable up by one =
before we=20
write it out.This is because the way that the BSP compiler works means =
that once=20
the level has been compiled 'NumberOfNodes' is the Index of the last =
element in=20
the NodeArray. In other words, if there are 10 Nodes (0-9) then =
NumberOfNodes=20
will equal 9 instead of 10.This is why we nudge it up.<BR><BR>Everything =
else=20
above should be fairly straight forward as it is simple file access =
stuff.As you=20
can see saving the BSP now has become a hell of a lot easier.All we have =
to do=20
is load it back in , in that order into the master arrays and the BSP =
Tree=20
remains in tact. <BR><BR>The 'LoadBSPfunction' is in the =
'Loader_and_Renderer'=20
application/project.This project is a framework to get you up and =
running once=20
you have compiled and saved your BSP level.The 'Loader_and_renderer' =
project is=20
quite small because it only contains the code you need to Load and =
Render the=20
Tree.The code to load the BSP is shown below and is like you would =
expect.It is=20
basically just the 'SaveBSPTree' function in reverse.The only difference =
is that=20
the memory for the arrays is now allocated at load time as shown=20
below.<BR><BR><CODE><FONT size=3D2>void LoadBSPTree(char =
*filename)<BR>{<BR>FILE=20
*stream;<BR>long a;<BR>stream =3D fopen(filename,=20
"rb");<BR><BR>fread(&amp;NumberOfNodes,sizeof(long),1,stream);<BR>NodeArr=
ay=3D=20
(NODE *) malloc (NumberOfNodes*sizeof(NODE));<BR>NODE =
*n=3DNodeArray;<BR>for=20
(a=3D0;a&lt;NumberOfNodes;a++)<BR>{<BR>fread(&amp;n-&gt;IsLeaf,sizeof =
(unsigned=20
char),1,stream);<BR>fread(&amp;n&gt;Plane, sizeof (unsigned=20
long),1,stream);<BR>fread(&amp;n&gt;Front, sizeof (unsigned=20
long),1,stream);<BR>fread(&amp;n&gt;Back , sizeof (signed=20
long),1,stream);<BR>n++;<BR>}<BR><BR>// Write the Plane=20
Array<BR>fread(&amp;NumberOfPlanes,sizeof(long),1,stream);<BR>PlaneArray =
=3D(PLANE=20
*) malloc=20
(NumberOfPlanes*sizeof(PLANE));<BR>fread(PlaneArray,sizeof(PLANE),NumberO=
fPlanes,stream);<BR><BR>//=20
Write Leaf Array.This also has some reduntant Run Time fields so we =
shall=20
remove<BR>// these when=20
writing.<BR>fread(&amp;NumberOfLeafs,sizeof(long),1,stream);<BR>LeafArray=
 =3D(LEAF=20
*)malloc (NumberOfLeafs*sizeof(LEAF));<BR>fread=20
(LeafArray,sizeof(LEAF),NumberOfLeafs,stream);<BR><BR>//=20
WritePolygonArray.<BR>fread(&amp;NumberOfPolygons,sizeof(long),1,stream);=
<BR>PolygonArray=3D(POLYGON=20
*)malloc (NumberOfPolygons*sizeof(POLYGON));<BR>POLYGON =
*p=3DPolygonArray;<BR>for=20
(a=3D0;a&lt;NumberOfPolygons;a++)<BR>{<BR>fread(&amp;p&gt;NumberOfVertice=
s,sizeof(WORD),1,stream);<BR>p&gt;VertexList=3Dnew=20
D3DLVERTEX[p&gt;NumberOfVertices];<BR>fread(p&gt;VertexList,sizeof(D3DLVE=
RTEX),p&gt;NumberOfVertices,stream);<BR>fread(&amp;p&gt;NumberOfIndices,s=
izeof(WORD),1,stream);<BR>p&gt;Indices=3Dnew=20
WORD=20
[p&gt;NumberOfIndices];<BR>fread(p&gt;Indices,sizeof(WORD),p&gt;NumberOfI=
ndices,stream);<BR>fread(&amp;p&gt;Normal,sizeof(D3DXVECTOR3),1,stream);<=
BR>fread(&amp;p&gt;TextureIndex,sizeof(DWORD),1,stream);<BR>p++;<BR>}<BR>=
<BR>//=20
Now all we have to do is write the PVS Data=20
itself<BR>fread(&amp;PVSCompressedSize,sizeof(long),1,stream);<BR>PVSData=
 =3D(BYTE=20
*)malloc=20
(PVSCompressedSize*sizeof(BYTE));<BR>fread(PVSData,sizeof(BYTE),PVSCompre=
ssedSize,stream);<BR><BR>//=20
All done<BR>fclose (stream);<BR>}<BR><BR></FONT></CODE>Piece of cake=20
hey?<BR><BR>
<CENTER><FONT color=3Dgreen size=3D5><U>I do not want to use a Zuffer.I =
want to use=20
the BSP Tree for Back to Front Sorting </U></FONT></CENTER><BR><BR>One =
of the=20
problems we now have is that because we are using the Z buffer we will =
have to=20
do our own sorting of transparent objects.This is not a major problem as =
we are=20
batching the textures before we render them anyway, so you could give =
each=20
polygon an 'IsAlpha' flag so that when it is collected from the PVS =
during=20
rendering it is stored in a special Alpha Linked list.You can then sort =
these=20
before you render them based on distance from the camera.<BR><BR>If for =
some=20
reason you do not wish to use the Z Buffer then you will have to =
implement=20
things a little differently.This will probably be slower than the Z =
Buffer=20
version (in Hardware) because you will have to traverse the ENTIRE tree =
each=20
frame, although there are things you can do to speed this up. =
<BR><BR>Instead of=20
just traversing the tree to find the Leaf that the Camera is currently =
in and=20
using that leafs PVS to render the polygon, you will have to traverse =
the tree=20
much in the same way you did in the Solid Node tree from part one.First =
you will=20
find the Camera the leaf is in first so you can get the Current Leafs =
PVS=20
set.Then you will traverse the tree and at each Node you will have to =
classify=20
its location with regards to the camera and go down the tree on the =
opposite=20
side to the camera first.Then when you hit a leaf you check that leafs =
'BIT' in=20
the Current Cameras leafs PVS and only render it if its bit is set to =
one.This=20
can also be speeded up furthur by changing the code so that not only do =
Leafs=20
have a PVS but also Nodes to too.After all, if none of a Nodes leafs are =
visible=20
then the node itself is not visible.This will lead to a much larger PVS =
set but=20
will save time as you no longer have to traverse the entire tree each =
frame.Once=20
you find a node that is not visible from the leaf you no longer have to =
traverse=20
any further down that Nodes trees. <BR><BR>With 3D Hardware becoming =
faster and=20
faster there is little sense in denying the advantages the Z Buffers =
offers us.=20
Like I said I have not tried to implement a 'Z Bufferless' (is that a =
word?)=20
version myself but if you understand the code we have discussed =
throughout this=20
tutorial you should have very little trouble writing a version that does =
not use=20
the Z Buffer. <BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D5>Illegal=20
Geometry</FONT></U></CENTER><BR><BR>Although we discussed illegal =
Geometry in=20
the previous tutorial I will touch on it again here as the Solid Leaf =
Tree is=20
very fussy about such things.Infact in most cases the Compiler will Fail =
and=20
crash if it is fed illegal Geometry.An important thing to remember is:- =
<BR><BR>
<CENTER><STRONG><FONT size=3D4>A FRONT FACE CAN NEVER EXIST IN SOLID=20
SPACE</FONT></STRONG></CENTER><BR><BR>This is very important.Solid Space =
must=20
NEVER be allowed to leak out in to Empty space.Think of a piece of Brick =
wall=20
for a moment.The wall has six faces.Front,Back,Left.Right,Top and =
Bottom. These=20
are ALL FRONT faces.In other words you can see them.Behind them they =
have=20
bounded in Solid space.Because these faces are Front Facing we know that =
in=20
front of them is empty space.<BR><BR>Consider the case where you may =
have a=20
solid Cube with all front faces facing outwards.Imagine now that you =
made the=20
top face just slightly larger so that it overhanged.See below.<BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsill1.gif"=20
width=3D256></CENTER><BR><BR>Here you have illegal geometry.The Back of =
the Top=20
face is a back face and is spilling out into empty space.This now makes =
the=20
space ambigious to the compiler.It must be Solid space because it can =
see a Back=20
face BUT then again it must be empty space because it can see a front =
face.If=20
ANY space can see both Front faces and Back faces at the same time then =
you have=20
illegal geometry and the compiler will crash. <BR><BR>If you do want an =
Overhang=20
on a cube you would have to do it like so:- <BR><BR>
<CENTER><IMG height=3D256=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/pvsill2.gif"=20
width=3D256></CENTER><BR><BR>This is exactly as it would be in Real life =
and this=20
is actually one of the main reasons that World Editing Packages work =
with Cubes=20
and carving tools so that the risk of this happening is minimized.Using=20
Constructive Solid Geometry and Carving Tools makes this kind of illegal =

geometry very hard to do by accident.Also these packages then remove any =
illegal=20
geometry before the level is saved to file.If however you are building =
your=20
Level either on graph paper or using some kind of PolyBuilder program =
(this is=20
what I used) you must be extremely careful. When I designed my level (I=20
basically did my level on a simply Poly Builder program that I wrote in =
one=20
night.It was basically just interactive Graph paper so had no geometry=20
checking), my level would not compile at first.I would have bet my life =
that=20
there was nothing illegal about the geometry but closer inspection =
revealed=20
otherwise.As shown above a simple overhang can cause a major headache.=20
<BR><BR>The best way to think of it is like this,if the geometry can not =
exist=20
in real life,then it will not compile.For instance you can not ever see =
a Back=20
Face in real life.Take a wall for example, if you walk around the back =
of the=20
wall you can see the Front of the back face of the wall.You should NEVER =
be able=20
to see into solid space or see the back of a face from any point within =
empty=20
space.<BR><BR><BR>
<CENTER><U><FONT color=3Dgreen size=3D5>WorldGen LE (World Editor =
Package) Exclusive=20
to Mr-Gamemaker</FONT></U></CENTER><BR>
<CENTER><FONT size=3D2>Programmed by Adam =
Hoult</FONT></CENTER><BR><BR>Luckily all=20
of these Illegal Geometry headaches will be a thing of the past as I can =
bring=20
you news of a great new World Editing Package called 'WorldGen LE'.This =
is Due=20
for Release Very soon and has been written by Adam Hoult who has been =
the=20
Co-Worker with me on the code to this tutorial.You will be able to =
download=20
'WorldGen LE' from this website as soon as it is released at and at NO =
CHARGE.=20
The world files Exported by 'WorldGen LE' will be able to be loaded =
straight=20
into our Loading and Rendering Application and has the BSP/PVS compiler =
built=20
in.<BR><BR><U>WorldGen (tm) in action below:-</U> <BR><BR>
<CENTER><IMG height=3D510=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/worldgen.jpe"=20
width=3D640></CENTER><BR><BR>WorldGen LE (tm) is a complete world =
editing package=20
which allows you to quickly put together even the most complex indoor or =
outdor=20
scenes. Listed below are just a few of it's many features :<BR><BR><BR>* =

Realtime Preview of compiled level at all times, with no need to rebuild =
after=20
modifications. <BR><BR>* Dynamic CSG Brushes allow carving of geometry =
with any=20
other brush, <BR><BR>* Hidden surface removal ensures 100% legal =
geometry for=20
BSP Compilation <BR><BR>* Texturing made easy with the ability to World =
Align=20
textures for easy tiling. <BR><BR>* Optionally generates Lightmaps, PVS =
and BSP=20
Tree information on final compilation. <BR><BR>* Imports / Exports from =
and to=20
several formats, including Mr-Gamemaker specific formats =3D) <BR><BR>* =
Prefab=20
support allows you to store objects you have created (such as desk =
lamps) for=20
use in other levels. <BR><BR>* Supports Brush, Face or Specific Vertex =
Editing.=20
<BR><BR>* MDI Interface allows you to easily copy and paste geometry =
from one=20
scene to another <BR><BR>Well I am sure you will agree that this is =
something to=20
really look forward to.If you are on the <A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/mailinglist.html">Mr-Game=
Maker.Com=20
Mailing List</A> you will be informed the moment it is released. =
<BR><BR>
<HR>

<CENTER><U><FONT color=3Dgreen size=3D5>Downloading the Source=20
Code</FONT></U></CENTER><BR><BR>The Zip file below contains all the =
Source code=20
to both the 'BSP/PVS Compiler and Renderer' as well as the 'Loading and=20
Rendering Framework' source code.Both the project files for Visual C++ =
are also=20
included for easy building.Also contained are the textures and geometry =
files=20
used by the demos. I have also included the compiled 'EXE' files of both =
the=20
'PVS/BSP Compiler and Renderer' and the 'Loading and Rendering =
Framework' so you=20
can run the demos as soon as you download them to see what it is all =
about.=20
<BR><BR>Please make sure that when you unzip the files that you tell =
WinZip to=20
retain the directory structure.Thats it and have fun.<BR><BR>
<CENTER><A=20
href=3D"http://www.tasteofhoney.freeserve.co.uk/vsd/pvs/pvs_bsp.zip">Down=
load=20
Bsp_PVS.zip</A></CENTER><BR><BR>
<HR>
<BR><BR>I hope you have enjoyed this tutorial and found it to be of =
help.If you=20
have any question please feel free to post them on the Mr-GameMaker <A=20
href=3D"http://pub21.ezboard.com/fmrgamemakerfrm0">Message Board</A> or =
try and=20
catch me in the <A=20
href=3D"http://pub15.bravenet.com/chat/show.php?usernum=3D1250190949&amp;=
cpv=3D1">Mr-GameMaker=20
Chat Room</A> for a live discussion.<BR><BR>Before I go I would like to =
say=20
thanks to some people who made this tutorial possible.<BR><BR><FONT=20
size=3D4><U>Adam Hoult:</U></FONT><BR>Adam has been my Co-Worker on this =
tutorial=20
as well as being a good friend .I could not have done it without him. =
Adam was=20
always in the Chat Room when I had things I wanted to discuss and =
together we=20
got this code working.This tutorial could never have been done if I had =
not had=20
Adam working along side me.Although Adam is very busy himself he always =
dropped=20
what he was doing and helped me when I had a problem . Either Adam or I =
can=20
often be found in the Mr-Gamemaker Chat room to answer any questions you =
may=20
have. <BR><BR><FONT size=3D4><U>Matthias Liertzer</U></FONT><BR>Matt was =
always=20
there to answer any questions I had on the GameDev forums. Matt =
explained Portal=20
Generation to me and also helped me to understand the Anti-Penumbra=20
clipping.Matt goes under the name of 'Matt2000' on the GameDev =
forums.Thankyou=20
again so much Matt for all your help.I am sure that I would still be =
struggling=20
away at this now if you had not been so helpful.<BR><BR><FONT =
size=3D4><U>Klaus=20
Hartmann</U></FONT><BR>Klaus helped me to understand Culling AABB's to =
the=20
Frustum as already mentioned elsewhere in this tutorial.<BR><BR><FONT=20
size=3D4><U><A=20
href=3D"http://www.graphtallica.com/">http://www.graphtallica.com/</A></U=
></FONT><BR>This=20
superb website is an excellent resource for textures.All the textures in =
the=20
demo were taken from graphtallica and there many to choose from and the =
site is=20
constantly updated with new professional looking textures.Pay this site =
a visit=20
NOW. <BR><BR><BR>Thats it, I am off. Having spent three months working =
on the=20
code and text for this tutorial I feel like I never want to look at =
another BSP=20
again as long as I live.It has been a very long road and most people =
thought I=20
had given up on the site because of the lack of updates due to working =
so hard=20
on this.Hope you find it to be of use. <BR><BR>Thats it then, until Part =
3=20
ofcourse when we will look at using a BSP tree to perform 'Constructive =
Solid=20
Geometry'. No emails please... Part 3 will be ready when its ready. =
<BR><BR>
<CENTER><A =
href=3D"http://www.tasteofhoney.freeserve.co.uk/index.html"><IMG=20
height=3D60=20
src=3D"file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20f=
or%20Mr-GameMaker_files/gamemaker.gif"=20
width=3D468></A></CENTER><BR>
<CENTER><A =
href=3D"http://www.tasteofhoney.freeserve.co.uk/index.html">Home=20
Page</A></CENTER></BODY></HTML>

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/bookshelf.gif

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
gGsEQQAAOw==

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsdemolevel.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsa.gif

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
NAiAKSiBPwiCt9eDJICBh6SBQGiEOAiESph/JmB/U0hTR2h8y4eCV9gBTNiEy/eBV5WF5MeFQmhr
HZgEX9h6/JSFSDKEP2eCR7CGbIg+L0glcBgDbogDdFiHFrCHRpKHMACINtCHfkgBhEgkgvgCiUgD
hniIEtCIQrKID0Z2GyCJHady//WIkIiJQEKJ/leHZb3miWcmihzAiYdIir+nArzGAar4YJm4Aajo
h68YghogenI3Z0t3AVmIi6EYd702i3VYizN4i0UGeJcYApEnXBkgjGxIjKhnjKWIjBpwhJboYs0I
iScAjTkCe3B2Z3T3h2iUdMi4idpoAtwIfS10jHZWjThXjuGYbedIAul4I6m3jP9ljey4RBrgjK1X
jzbijUg3es+yi+KojAOZi6R3ivNIj69HBABpAv6oUxFJI6DIAqeHfA3Je1hykSuQkSkwkTEFkhtZ
kiZ5kiiZkiq5kizZki75kjAZkzI5kzRZkzZ5kziZkzq5kzzZkz75k0AZlEI5lERZlEZ5lEiZ/pRK
uZRM2ZRO+ZRQGZVSOZVUWZVWeZVYmZVauZVc2ZVe+ZVgGZZiOZZkWZZmeZZomZZquZZs2ZZu+ZZw
GZdyOZd0WZd2eZd4mZd6uZd82ZeYJGleI1dx2XPZBHQcQ5h2aHEwaZiFaTKMaYdvaTeKuT0SuJaH
M5kscpmW2XYgx5liKTmYeSKgeZaPCTeh+T+geZrayHPpwppl2TWU1mhb1pkXEJuVZlif2Yzx9neq
CSJgc5v/Npth+Zu7KZx1hwHACZymBpbEGWq8SZu1WZx8xZXEGZtqxnS6aZ3G+ZXNuWjPKXi66Zzb
6ZXdqW/jWSnlGZzTuZXpqZwvhyjt+Z25/omc0ombxxmd4rme7Emf2mmf2Bmd/QlrY+ma0Gl1n5ma
rYmgZjma7cKgpOmZ1dI4vdmQmpkwFaqWpTk+E2oiGdqYGFpz1Vd144I0HTo/JJqWToOYEWVzGxoi
KfqYiNmiddg1grln/1mYd/ie1FlZrbI5MkpQovOjgJZZ3Cl2Z2ekO6p2sLN3Vok7QmpseHeVvfOk
5CZyWFk8VPoOWCqlBldIXSqV1JOloxCmU6k9YsoIZhqVRSRa4faUa5pKbdqU53OmhzCncupvwoSn
RtlTOcKnNKk/dAoIgHqUjxSofVCoRXlXhqoHijqUpbWod/CoQdlakEoHlPqT5lWpcZCp/j2pmJqK
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
ulCGNtSYEQAAOw==

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsc.gif

R0lGODlhgALgAbMAAAAAAABj3gB7AACEAACMAACUAFpjlGNjpZSUlK0AAL29vdbW1ucAAP8AAP//
/////ywAAAAAgALgAQAE/tDJSau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuHxOr9vv+Lx+z+/7/4CBgoOEhYaH
iImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/A
wcLDxMXGx8jJystvAM7PzsyBDdTVDQ7UINkS29J4zxjg3nvdE+Uc5ecXDOzsG+4O8BTyE/Qj9O35
DOMf0Rv+/O6oC2HN3DUN8uxVgKew4b4SCiVEDBgOBACKdtR1s3awQkFu/h0xJHwokuQ6kxJRhpg4
ESOFiyFguozD8eC2myHNcTP4TmXKkSnr5bMQcahQhu1Ozksaj+lPn8FkxpxJMyc2m1gt4ATJwWnQ
pl+Rfl1K9KFYsGjLLjXLNixUX1JFxKWqRmPWq1rvDjxJ8qzftgtV6jNplCXhvvqetuQFcERjumns
csXrkeNkD3/dag6sVu3ZzmMdJpsrFzIbyZTPpbu2V6hrtJlhC57d+TPn12lxGyPt4IDv3wcy8DY9
BvXVapUpZGsdGnBs22NfP4eKD/HmxbqG+6awvSJxPMyVWy3r1ajsow4TN63O1DBZ9GvfMs7QXUJ9
C8O/r9naIbx+LNoF/jfBfRXk919kyPU33oFbBAicgN4xKCFGAXIHIX4TZhhQhQNeWKCGIErDoX0e
vhTiiaPRdyGBJqLoYjG8PcjiBAa+aCMuNXKQ4408yvJYTDv2KKQrQV5Q5JBIqnIkjUk2iWNpTkZJ
y48aUCnllanAZOVLWmLppZJc8iaOBEt+aaYkYkIz5odnttlJmUa6KScmcEY4552P1CkcnpwskKSe
VfIJBgIISECoBYfu4OeQgP4jqBeJJkqBpDks2mOjOj7KBaWIFqqokJh2EKqmMRBKqameOhBpqqim
WumlOIxKagurGupprareqisPlr4oqwe/zpoCp7naamyxyBJrQ68o/gYLrLBFoDoBrtTuuoMCNjrb
D7RGVHustyAUoAK2vvqgLbchgKuutR6IKy4K5DYLxLnofiDttKbie2yu+X7gbgrxhkivRfWu8S+8
8g4xcMFFvOuAwyUEnOHCUDJMhsMQkyCxhBQ7ZvEYBYQscsYibHxgxySg/LEOGZMcgsn6qZzyyl64
7PIHMBMncwk70yyDzSbkDFnPPPuch9BUEW2C0kYrgbRLTC/dtAYjV2311VhnrebWXHft9dddn2xF
1E1jGirZWXJdRdhT12C2CmiXsmaYT8xN45Ztp/C23jPhTWbc/9Tod95Fo3A21AQrUSTgj+5tOIUV
G7Ek43w2arfH/hvOLLnmhMPN9+fj6Em56J17rjA/g1cJeOrCUS4n465rMtwAtA/gqBCWl/746aFj
QLsEv++J+wYCCHC77oUP7w1vwQN/vLkcFJ8p8pwHETudvtu+7bzEF298oNRjrryI2Sf+g4Hefy98
+FPxTv4FzYtqPfESqG8n+8+6zwzz2ud/vgbSc0AA74e/6Y1vf+WbQP8IuIP8BHCAcSrg9g64jNlp
L34R/F8G0gdBDEnQf/NbngZqt0AG6mA4EOxgiz5owBCK8ASrw0AK7bdCFj6Pe72Dof6qZ8P1uVBE
oltdEHvYQhzmkIdGFB8RfZjEF0ZuhxNcIhM1aIAqWnEGuJqU/qukKCjYScAAFQBjqdilr0yw7m9J
OKMD1GhDLzpAjBOA4wuUVcZLaElwXdrcGvFIJi6CjwdxgYkc3ziCe9lKUllsFfbuliapjI5uRmrM
9dqkNLZZ8YoiWNe3rEXHPIVDbRlsIiPVZEIuMi2QXwxjJreYLE660hKHEyUS/ejGQQ7SA4bUZCsr
Iauo9dKPbFKeLU2gS3ChyQWVRCYwmcS7YabrlbuMZicVoa2eVXOZaySCIC95S1z265CsYpciI0Ev
mZVzmW5ExsJQtk5gpnM3NqBYxybppHfCSgYqo+eftNkksmWxjjdkoT2J8c99gY4HBUWW/Ig40GEk
dJpK1ME0/iEaTIHyExkTZaUOXWBIfoVzX+ME4QcbOouO5lKcHTXdCooJTYpWVIIkjQVLN2nQFciK
WDNVaBQLGFNY4LSl0FTmSr+ZU5d6EKYXxcVJaSpNjap0qEzV5RPD19OSAjWqTn1qCYoa1Kkir6qu
4CpTY4ApkxIVpd+M6FeTeguzIhKtRpVag/AHVhGI7Dv6bB/16hquCdwMcnPdK1tR0DK8ciGvExvs
Cf5qGsTu1GIBiKxkmUnBxWrIsf0AJbQCUMoGsoCxdGHbFC63R8wmg7OhlGUJQEshK5E2jXwkFWqP
+kPCVoC1FYxtExYnW8nONptQtKwEcKsM3jJhcpr6bQ1V/muCuybNq4oV6ZyUS9na9nOWlTXfnajb
x+AySq5FYGOBTCsM7gJXCAoAm3rXy16vZe298H0vmoYY3t1tt7M6eJpak2eL3NV3o9BCZQ/0C939
+si+2Z2AbyeL3zmJNr8vGBV57+Cg3wQUehmIrHQb99IcEFivCJ6Sijr0R+tSQMMLFRbjPqxdANdi
RL0pUXWZ6wAUF1FTK0ameBvMChjPqLsJlsCCzQvkWeVYqAcVMQbu8+PzmljBRO4wh4fAYs/ewscy
LjKNbXzhLhKhyid80pJXlGUnbznKy8Xxl5cwYTtgeYoavACX4Txl9LI5FzGCUJNdN5w58/h1a1Yc
nscM/pwS446+UnooK4+cRjwjOrqPbZKiaQsEMOegzRQGrx4LjKSMUvoHlo7VLuCkT+TayK0fVWhI
ZwzqO4+a04e2CKZNIdZopplWWbVAqG8wawovrtRoDJyWQfRTrI6V1bjGmQzi+udW3FFHeTyCI10r
yRcttanHHjY48dWqt/ar21rU9bJzneIrQxI/1d70eLfWbP3UmlikefeuTsVKk5202+H89qqN2us5
NJKUqaVxiyck75qaGZwFtzUFNpbwQ9F7w7GI5ZOxeyBUl9Hb8L5AsbHNcWUxfJwNJ/etYfFLgRv4
TvFmZa09ioGPd8rYHRc5sl8RLF/CoN/ASDnMpZrS/gm4vAIr77mhSX7zHpxTzRo/K1bT+tYM/Dzh
LGciztlw9EvTYOrzUQFFO2lvpTeV6an+JLs7ZGEnxvPsXtY6uae5a6CLHKICtg93jnh1UVcOqhmA
aNvDrQFmF9lDZQbFpF182LtTWe19lzltAZ+KwRMeCI4f+pkYjQSpMB4Vnk7yDyIv+S9RXtpzDz0m
LD7WVT++B5m/sZk+r+7LXyLkNqUB6W1t+s5jifX/lbvoLbHxnGo12TGHOcSvhHu2rmgT1/b97/HO
d+WX2/OBbjTZm8z7q3KcBedKvvX9fnDiR7/ypIA9kmEA9YFLqfje7cTsEyl0zaNA/LD+7uEFnVhc
/tO76apu//OjhP4gG/YLWEck3wd6W0VGBvdqAHh77jcCe2d75mcvBqhTcAEGAbgKlrNj4hZhGDhy
3pR4w1CBHMgjjnMCDUhnIMZtrqJ9KKh4/UWB/LeAJUNWmgd/wgCCD3YjIxg0MhhiEhh8CpdzmhUF
pPValwWDL7ODp6eCPvgLQ7iBDaRbLpKDEYOEJhB45ccYUEh/wzchBtBeXviF0JBeYDiGZAgAJUKD
CLiF/tduptFNA7YEMrZ+cMWCNBd/GGaH3+GGPFCCMhB4oUVxcXZyB6KHJZAAU3gCCZCIhugCftg3
mhZrPAOCmUCII5CIh1iIFLCILNCIrbU0j3R6/gxCiSFgiJqYWQCHiIzIIP6VfqARgvohihqgiBVQ
ivnDLB0gixZAiynAiRSRI+bhilbXAb8IjG2IiRJQiro4Pba4AZqoi8l4AryIOsIIGFIGSCAwEZJ4
CbCIAc2YiVCyjLE4AbT4jNAoNl1BjcSIdoFhD9gYItt4AYpoieIoF2PHAfGIjDAQjXT3FErxaUZX
G4fBhi7xjrnIjd84ivAYA/podufxHv5ojetYHlCRjZZAkLM4jxiZOOCYAd3oAOS4i+aIHtVhgmF2
G62YjnRhkbMojxm5PRvJkfJ4jx9JAgv5Prpxk9VoZQ5pkjn5iiH0kkFQkwi0k9ERcP94GyNp/pSD
aD31WARCWUFIiY5KCZHxwZMzt5RDAJRA8JRQWZWKoRKf+IhcSARa+QNcWVw8eD6PliEqKQNl6QNn
ORprOXH7N5bDEoEU9ZaFhJciF5cpwl+QJiVtmXQGl5djVJh9OSGkpoWRxpaIl3cip5er5IEb4Jdo
eYKS82svQolyCFL6NwGSuW0oeHH5RlGWKZeyRn+D4w8UiQmEiIYXEJqwaQGneQzPJmzd90NN6Ego
8poqt30RaAGy+Zs7F5wVUJswcm7rhpK8Jnan2JM+mXj453yxuUrTCZwcgJwf6JzQIJD4tHxYyQFX
WJ0kMJ60GZKgWJLgGZ0YMJsVMJzFKXz0/vEfJXeHseeY0pmCXodxkWmd+nmdK5idMTN+6tkCrRkJ
gwkDoakD2jmBEUaVDyohCfoCfKiQOvOdwYih4RkEFZqPgNacboNNdKWOISqiZsJ5eFgDKOqdJnoi
K4qZCMWXjdmiQ5J6YrkDNqp6NMognZl/aXWjand/qcafD7ij7oad15eeJ+CeJGmkkNF7SGqEBfhy
Psh9B+qkj6CEUiWl5bmfUVqkWGoa5gmkdxmfPzijYYoRTAqYS4qkxpSiacoMPUqkBNqmQkqaAcqm
cfox2Xile1qDCfinPtOngjqogVqofHqoiMowhLqoFuOnjvodJDSplFqplnqpmJqpmkpC/iOwqZ76
qaAaqiUUqa4wqlRgqhyAqlKgqqSaCqwKBa/qO1oQq61aCrTaBLdaAbm6BLtaq6DQq0kArA4grEdA
rL66CcZaBMKarETArMd6Cc4qBMs6q8/aCtEaBNOaBddarZKwrT+QrVjgrdz6COLaA+B6BeU6royQ
rjtwrpHInU44QurqqnpzOU3JAu6aMmnCJS/ArvOKCM7KmnMBEPEqqyIQsPY6bf36r6fArOnGr3fj
AvlKj1QiSc7irwxbCA5rIBYrsZ26O6QRhPiasbYKQxyrsC0wsam5R+gGsSlLsqSwsbgZbCN7sCZL
sxGbsy8Ls6Igs6rjsiugsqZoNx3r/rE8Gwo+O2xFW7MhkKwdK7BAG7RHi7SGc5tQi7NSa7PvGrEC
+5xMO7WdEK3dGWz3mrVNq2M6gLFg2wfpWrBnq7XhuraeoLY3ILRRQLdymwd4WwN2C6t5ywl7SwN9
+wSB+7d0ULgyMLhOgLiGGweMCwOKi6uNmwmPu7Bw6xhl2zpfO7mUULlG+7b6SrGy4rmcqwZqO7Yx
ELmfFLpmW7qTgLFXC7kfu7Wt8xhuq0CuWwmwe5uye7mi+yOxy7Ktm7uQsK2oG7U7C7qYqzrHe7vO
Q7zdCje8i7WfCwJOmx/UtrnQ2wjX2pTOmwGqG0k/K77Du73rKr3kOwPh27LjRbYo/qsCpGu+YtC9
A9sx69u++FtagTS68kuu6Cu83yuvvlu17dq/jmC8Y5K55dsB8bvABmwIDQy/sxu3D7wIEZwC94sE
F1zB2kqtA3yqHKwIG3wCGVysIZwII2wCJWwEKXzCU9DCJLDCyurChwDDE2y9HkzDhGDDH5yqOazD
gsDDyvsBQozDQDwIRUzEN2wFSXzEJtzBPbyqThzEP6zEUDzFf9DEDLzEVaDFWCytVewBXrwBY/zF
3xrGW3zFZrwHZQy+XAzCa8wHojrHdDzHnVrHeJzHlxrHfNzHfvzHgBzIgjzIhFzIhnzIiJzIirzI
jNzIjvzIkBzJkjzJlFzJlnzJ/picyZq8yZzcyZ4sKoCSOqwDvNhbgQHsibRbN5D6qHO5uqDMvhB7
yuYSN04oyzNgy61ayzsyyvXLvrj8hJDIulDwy5FasWsytsicsMecwDLhtd35nMcbJs3MzOJQtMmM
vNcMwHekWdC8m9u8v8tMsBdhzahbzs3rzaM0bUT4t6Tsvu6szb5stfJMvVdbz73MsvaMRk87z8Ib
y+PMz/kMzwLtz/QM0M+2z+8c0MGb0Aa9vaR8zgHtygrNzwStzdHczwyd0forzsaMvxOt0XgT0Tn7
0QJN0iLtnCC9yox6z+0buxdd0g2N0Sk9viMd0wuts/k70zBNsy990jv90yZN/tEvjc82rdIF084e
Pb0FrdM3TdKuXNPvrL84PUrpy9Qxjc0UDdU/LdVWvdRJrdPEi9RB7dVjLdNArdTw7NQYrdbuXNZl
XdFifdXm3NUDrdVsXbqgBNEunbA8zczpLL57TW0cPc04a7vV/L5U3c8AN9Hh/G9TvdHSjNOGTc2E
rdjeLNRD/cmB8MsYmL2aPWrlVCaGTb2f/WKhTY+RRMylvdqs3dqu/dqwnQeqrU0KnAXxOttA0si4
fUIsTcCV18rzYtQ0utuX1ts3+9uonJmGPNd/Y7HG3LXTTNnNrc7U/ddc/dgbbc6Hfc7oNtjVndjX
jbzhnczQjdLTfd6pHd3i/rzWwk1XRR3VjGTV733WBc3cY720dJ3PTX3Pbs3f2wzfXY3fa5zNcQ3L
YxfRB16/BI7WHU3fW/3YwZvN6Wzc2R3ZdW3e3u3fdM3H0RDYlY3UZo3gIevXXx3iI57faH3de33h
IU3hRN3X2bvimuvgN43FPn3jlQ3XOU6+BW7iPD7f4f3jYE3aEK7hPl7i6z3jTp3ZTtzfXk3jHz7f
OC7kDh7kKN7WV23XQK7lWq3jUc3kTS7hel3V2p3k6H3mKs67k73g7rvM2H3m3SzdcP7N203dan7Z
hY3OGk3krE3cN5eFM1sIfj7Ig462NA0s7W2giZ6xha7oh47ohtDosT3p/pRe6ZZ+6ZhOBeIlsvh0
JAI+40CyzvvNlJn+ymYNbTa1y5Nj5oEO6Xx+4afO26WO6rH+6MlN67JW41Xt6rXe65L+yBJu0erd
3eqt4P/c2LvO1WX+zcSO5s6O3oMtzcNu63MO489d7BY+5w1u5XEMtQht0fEM4FBO7F274Vxe4vza
4VKe4so57kfu5C/+7uz+xQne5odN5aMO0xcN4m997s3e0v8s3+vc3Oc+5eiu7OBMtPPe7UYO4l4u
7+KO1QXP4FnNtf4N77nt7tfe5eqOtS0O3n688U/+8D2u60/e73ve5TWN8TML7x/v7m8+8hw+veRM
2neN8kcO8/6u8jB+/uU57/INv+6w7tMMP9rZLthRDth3vu2STeKsXu3kDsuW7dzRbvNj/uU9Tdl2
Dt5ZD/KzDoRffymLHvaQ8Otkf/Zon/Zqj1er7rWmvrKZJd7JvvZyYPKg3utzT+2Bs+N6T/fNsPBP
jfdS//ZD++py7/cNovXNHucnrrNXv9/lvW4j7uHS7vWIvzZZbu7T7fTz3PFIbuTpHvAaP/axffMG
ve+IHezcTvRW3vH9DeaXv1uZX+VkTtgL3YQR7/n+zPKxfwWmn/JSz9ZdP/QUD+1b3vtjM/s4X/M7
rfs7L+4c7fNmj/yYm+QdTfnkTvXTDvl8v/nBP+3eD/XUP/7kX/7m/n/+6J/+6r/+7N/+7v/+8B//
8j//9F//9n//+J//+r///N///g8BTk5a7cVZb979B0NxJEvzRFN1ZVv3hWN5pmv7xnN953v/BwaF
Q2LReEQmlUtm0/mERqVTatV6xWa1W27X+wWHxWNy2XxGp9Vrdtv9hsflc3rdfsfn9Xt+3/8HDBQc
JCw0PERMVFxkbHR8hIyUnKSstLzEzNTc5Oz0/AQNFR0lLTU9RU1VXWVtdX2FjZWdpa21vcXN1d3l
7fX9BQ4WHiYuNj5GTlZeZm52foaOlp6mrra+xs7W3ubu9v4GDxcfJy83P0dPV19nb3d/h4+Xn6ev
t7/Hz9ff5+/3cP8HGFDgQIIFDR5EmFDhQoYNHT6EGFHiRIoVLV7EmFHjRo4dPX4EGVLkSJIlTZ5E
mVLlSpYtXb6EGVPmTJo1bd7EmVPnTp49ff4EGlToUKJFjR5FmlTpUqZNnT6FGlXqVKpVrV7FmlXr
Vq5dvX5FGAEAOw==

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsd.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvse.gif

R0lGODlhRAH6ALMAAAAAAFJSlFpjlGtra3t7e/8AAP///wBkAP//////////////////////////
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
cJm8+ZvAGZzCOZzEWZzEGQEAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsf.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsg.gif

R0lGODlhgALgAbMAAAAAAABCtQCEAACMAACUABAQEK2trecAAP8AAP//////////////////////
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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsh.gif

R0lGODlhoQGXAbMAAAAAAACMAACUABAQEK2trf8AAP//////////////////////////////////
/////ywAAAAAoQGXAQAE/tDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuHxOr9vv+Lx+z+/7/4CBgoM6AAAn
hheJhHeGjosYkDWScJQhlhKYjJWHE5oGny+haqMbmI+bdZKfpSuocqeOFK+vs7KZsrS3q52pVry4
kInAoLXGtRXHw7vMtleWi9Gd0oqZntLT2cXOvr+929Tg38u45dvnp9bB6+iHxFXQj+PNydrn98H2
rd1K8uH/+gKaC8eNICVd5rxZiNVuocCE4gZ+4yeFYcOLACVC1HgPWMZn/hPxcYyHMKHBWxSpWDwp
7OFHWyU72iu2b0m8kTMhkjM5E1nKKCt7ovz4Uqe7Xi151uznLx9MgkZlPp33E15Ip1GnXksq0iPS
eShFVr02ltRVsTyWMlJbFsvBnD3YDpLb1qqisHHP1t3Lt6/fv4ADCx5MuLDhw4gTK17MuLHjx5Aj
S578hYDly5gza97MubPnz6BDix5NGjO/0qhTq17NuvUHAoJhdyNQoLbt27hz697Nu7fv38CDCx9e
W3YH43+Rb6JNvLnz59CjP1eugfoZ3DisD2Iuvbv37+B9a78wfkztCecNpO+w/vXp8PDjy5/ufs36
9O035D8+v79/6dz9/ifggOCVV4GBYex3mwQLMqhbCAj6ESCBFFZIXIQSYPiFbRXgV4CDDn6onogg
aLjHhBamqKJuGpq44X0kjughejF64GIeKK6oo4otxjEjiD+OKMKNeOS445EE9mgfiT82yWSNx72H
5JQVKqkGjCAKqSWWEEpJ5Zf/WXllg1lip2WW9fliJJhseifmEQPEOcAWRN6xJpVyDtAmdG8WEacE
f2ZRpx13IhlnbYfu2VyfRAQaKBaD1lHokYkmquhwjA7h6JyCerlnpXpeimmacHL66BWR0jHpjqCK
OqqNSmyqRapzrKpjq64Gl6kQsnY6m6i45vrbrkH0qsKD7EHZ5a+X/gYrbG/EAmFsCvslewKtcti6
orPP7hattHK2UC0H45K6nKt5djusudcpa2aI5cLKrLr0ssiuGbnRWKaI8UY5b70AF3dvGdU6iSYJ
AQ93g7YJt/ktGAXzK/HBI2CbhLIwMNwwmA+/eIHBZ5JgMRIYv6DxxlR27EXE+1I8pBglu3Ayykiq
3AWyQb4rMswL00yvzafxbMPMPusI9GxC10B00TwOXNfIR8TcwtJMW9hia1hnrfXWoiVNA9dghy02
a063BbURUrNAddUUHq2m1zOszfaAbqdydhFpryD33GGWTUYAgAO+MNwy7M13f3VnIbgEiy/egePy
Qtzz4YomjoXj/o0H8AHk/ko+NOWV+y0G5wYErnnpgU9guukgrO7667DHLnvs4k4OOpuWX8555oyf
njrqywpx+gp5q2D47eHlrjjmw6POe+/BB9E8tbYjn7LoZjwPvPakb3C3CdOjUHwKx1vvJvZgMA89
8OyrXyIR4Z8wPgrlmw8g+l+4/zz38VcHf+2fs9+UlEeDU7FgdRTI3O8g170MfK8E/SvB/K6VK0vR
jIAxyBMXHkiCCCKsem1KV9EwKAMDoup/LJigCeonHwuijIQZ5NSsUEg8EH4qVD6DIQxMaAUOjsCD
I1BhCVgYHxduTIcv4GEVfCgCIIpAiCKrIA4viL8eKPEEr/NA/gMjJz0AKk2KTEOiC64IPideYIud
62IKbRjCKb6wijwgIwTNaAE0coCJIaDjB6BYMTCOEI47kGMH44dA1bFuiDQ8FhvZZMSGidEJrjPk
+rRXsURSL4ACPNIjm9C9/flOj+SxpPgWmckqAXILnfzkJEFpATy2zotfK6UmT6mFVK5yfSKbnS4j
CT5Yxk2WO9okE2zZPlUicgWsrKMvCwdMo9FyeYXk3+92hkwsLjMGRGwmcIRZpANac42Y1KYpuegX
qCWzAufUAB+HJM4UcdNO3uwlOL/YznGmsZzxhOA1M1ZPe95xbAANqEAzk88O7tNkA02oQrn2TEaY
85s1DGc//vtGzr48VJ4RpedEBfROQhX0hweV2Ubp1lBCXFSf84zlSCl6T4t+tIkhndpKWXrH2Lw0
jzFV20z901FJ3fSVKf3lTufTU1X9dHM51dtQiVrS7RxVi0k13lLlU9RaPfVxUSXfVONT1WxdlQPp
zMA6IbRV+HQ1Dic1aFCZWdYCNXUGGpxhNTGqSIm2sZEBOysIptXDr24grBgYa4mAFSq81kuvH+Dr
Ev2qAcB+jJRT4lbCECsCQTohrSBdKzafZdifvbWAMoQUYzPgWAsI9jXC6qxnK2oEyz4BszDVLD/R
5cYjfjaGXYAtTmVrMtpWjbIdcC0UdAvUjKpUUaoFGHA5/iDc144WA6XtEGQNVds3slZTeQptX+eK
UuMKFbnZzeFt/0BcpPJWpG39znLXUF6onlem6T3fdZ/23DNmlX7xlW9L+dJerL5Xp/m933zNVl9l
/lepAY7OetXQX7Del4IJ5tN4JVRgdD54hRGW8IDL0uC/XniIGabPhsfS4cZ+OIohXtSE+1Bi0p64
jym+0GsWSuMap6bCCXzxkGzM4x57ZsV8aDF0dQyhXRr5yEhOspKXzGTXLTgNQrbvgY3X5Cpb+cpY
tvKT0RBlA3u3cFkOs5jHLOYtn6HLFp4y+cjM5ja7WZdmNgOac6xm+r35znh2c5zLMGfVEblEeQ60
oK+8/mcy9Jlxf37NoBfN6CMXegyHLl2ibdToSlvayUA+EY79XOdrXfrTln60GCIdXQqcltKgTvWg
RR0GUk/6OKqOdZ5ZDQZXd3qFss61njO9grj6SgWOLTWNkqTr1eWp2ExmtWKpYOspEADZgItTtAcA
7STTegLNVUKzpfDsagdO2t428rUBpd3Fcletzg73tNW9y2uHS67Ahii3wy0ndreb1y3IdhJIbW8n
sxvc/YbduA2gbyREuof/pnbABY5vFhT8CAdfYsIXzvAR+2DZzt40pKoNboBT3HS09rVozw1lbx/7
45i2+E8izmyUo3zgG9Q4qlz+cZjTSeYIp/nCbQ7v/hQIe946DzjPf+3zNnQ76PYe+sjjzYajI13d
Sj8hybn89KQ3HJ5TP3PV2R317TKdvVuH+tU9mnU5hz3cV/Ox2teO8yWu/e09HrtPy87ns3u76+b+
OoPtXm28M7vtLec7sv2ecbobWvCDl7tRDQ9pxBeb8NwGfLodn2vIR4Hlk6d8rC0/XMkDXfOq5rxz
GT9q0G9e8VYlfatNH3rUe1X1tWZ9qsdNF4h7/vKyB/W18eL1ojdd3YZ4Oq190nsU/Bz33naE8F0v
AuLn3fdgr/Yjlq/ytBzl5rCvTPKVj3RW74Toxje69AEQgOB3n/kfgIrU9V5yaAff/EEXdVN6Hv7f
/iPb/PDXOe31Evnse8HpueYP1LdfRlB7RoB5nzd+A1hTgYGAyLd9C+g9NuV/uZV7nyZ6l3V7w2WB
l4aBTeCAG8iBleaBTACCryWCI4h+b2CCl4WCjUaCS8CCH+iCjAaD2qaBJ0iDq6aCbiCDJaiDO1h9
FOGDMQiEgmaD+4aDLWiEszZjcPeEC6WEHwiFVDhQPGh0UviDTIhnSGhwWViEW3hnXWh7FLhBYSiG
V9h0X6htZ/hmY3iAa7hvbbhrQhg0ZUgnc9hmb1gERMiGeUhme0gEfSiHfzhmgTgEg2hwhWiIache
caiIixhmhygEiQhxkSiJjZgB8wd+8tZ+xSaA/udXhzhggEl4h7PifuQXdvLHf89Xf9H3iam4datY
GY9oifcXi1W3irxXfJ1IdbfIfaFIgEGgfrxIV56oa/iHizS3f9jHfr4IgcHIgDbBip1nioICfMro
crOIFn9njRt3i4CTf8uYiZq4i63Yi1qHiuI4jqL4Nt44c5eIZZMYBJV4gPEoj+TIZbVoj/eoZfl4
ZvvIh/3oj+1oNwEpiANZZfMIBPUokAmZbP8oZweJiA8JkQW5HBNJiRW5ZAv5Aw2JkBtpbRHJZxlJ
jyEpkhfpUCXJkCeJZGlXhTAZNivpkTFZkwyVkiY1kz4AgC0pOx25kzrZAzzZkxUnjAT2jjlH/pSz
85NCGZQ8MJRKuTpM+ZROuQNQGZWBM5VWWZU6cJVYGQBa2ZVcmQNeiZVhSZZjmR1fGTtnmR1puTBr
WZTSmBxvOTRx+Tq6SI2XV5dKo47ZyI5G6QPEWIzdtXewGI5/+XIjuRHNCH2GiYyJqX+LyY1L55jH
KGvrGI0SeATykFt8+TW/mJnaOJmDeY7G+IwBmIqiWXOkCRfrZ5moiZmqGZkU92il2Y3OmI6QiZi5
2JqMSZjo9pipyZsR6D9I4HzAmVmvCJmryZo46VRIKXF3KZWTOWqfGTfTSZ3PKQgfSZHZmZXV2WrX
CWbfCThtOTjRGXjleZ5DM57YVJ7mGZ61/uaeGQOfYCmftJiemfed7Kk09Gky9tmfX/OfMhOg+Pl/
BDo1BrqdgdCdGgmfL2mTEroaCao2E3qhqnGgnqmf/QcYAho3Fao3ExiYJBaixjOic4lPHLqXDaih
eXB81eihLtqYrshgKLqZMrqiMUqXDAoIDkqPN2qcOZqbEtmiPUpeLcCBrjR3JFoVS2poQepABdiZ
G+qORLCJNCqknKmXLGqlW4qgR9oCpOiFSHOcXNqlKXqlZ7qjGGmm+dmkOzCmZOqlajqfYeoKa8qm
Kvmlb5qmQiCnZEinQwCocHinKUCohSqow5ineiqlUyqeZVoEiMqHizmpgmiHksqoowen/inxpJAW
pRjgqa+nqHvxoYWDqTzKqUOIqiqqqqy6p0Pqp6X6qvw1o/QHq6kqq/QVqbmKo72Kq62qq0dJqrvq
qrzaprHqPRi6rKRxGsz6rKBhq5yYk0ZqrMTaoKAaStVqkNvqq8GKrL/qqMkKrC5lqJp2rOVqrdx6
rRwmrZUJrt+qpfFKreMqruEKnfUaqtmKrd0qr+m6rveqrfnKnft6IAWLpP1qr/OKrwHbSgdLYQmr
rxFLsBPrsBXrow+bIRkbZBsrqhxQFK8Jr0AAsslpsHV6EdPKsIvKESkrsA2LsRdLAR4LBzPbpwvr
sjfLrwNrsTsLsz0rsxt7rj87ATXb/oO0OqvmqgdFW6UvC7QxC7FDq7FPy2IdG7RKW7VTy7FZC61c
2xnO2rVgexmUMbZkW7Zme7Zom7Zqu7Zs27Zu+7ZwG7dyO7d0W7d2e7d4m7d6u7d827d++7eAG7iC
O7iEW7iGe7iIm7iK8SD9oi/60i/Iskcx07j6USOUeyxk0gMKki/W0iHFc7mEsbke0B5B8jHrFC+g
a7qmdWrk8iQuI1anJrpPBCWXm7qCYbuea2oTA7smgLqnS7usW7mOC7q4G1jAG0TH27mQIbsywrxb
MrkYk7kNojOO67mkyyHNa73Xu73Ri725q73wMmzUm73wEiPjGzHe27zJqzPvMr3m/hu8fcC5IKO7
8gu9ZAIy51G6LoO/u6u7LfO8+9u/9Pu9TiLA/8u/q3u/u6u/ANzACBwyfiG7DHy9r1u9CWzAEwy8
0ou9Evy+DHzBsOu64osm4+K+B5y8BLzA66vC+6LAxesLHRzA/gvB37u6DTy8KGzBj2vAN5y/T1LC
HwK5/evDJOwuQczCN6zDJyzDDozENjwYMUzDFEzDM5zCFJPBTzzDWNzEWYzDWfzAXKLFSLzFVpzE
S8zFIHy7K8zE/2u8qsvFZOzFaCzGZxzFVQzGIkzHaOy8crzFeHzGgMG85/u+FVy+MOK9JizF9cu9
PJwzLty96Su+hKy+B7O5HDzE/plryE48yG3cvpdcxY6Rui+suHf7wbxLyoqbycKLyqzcyq78yrAc
y7Lcu/BLxZU7vqBMA6M8yzcDvaPLw62by8IsA7vMy+3yy4V8yoVczCCgysacBh5yydGswUecvs48
xQocMtP8w9wMydxMvomczM9MMmPsxH1szpV8xC1DwX9MxfwybCGyzpM8zk/QzlG8zdT8yXtczoB8
zjqcyMxMzzlgz2tsxjWsxwTdz4DMzugs0EuQ0GVsyq87v9m8zwEczlxyyLXs0MTMzwbdzsNM0Yjs
0frL0NXryGHM0VGzyRIDxD0cyRVc0Vf8yHJswUScztY8zyrdFi4dBAG903+QUx8SjQM/DdTxa8RF
TctGvdRM3dRO/dRQHdVSPdVUXdVWfdVYndVavdVc3dVe/dVgHdZiPdZkXdZmfdZondZqvdZs3dZu
/dZwHddyPdd0Xdd0EAEAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsi.gif

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
wQ0f8db+8BRf8RZ/8Rif8Rq/8cAQAQAAOw==

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsj.gif

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
ADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsk.gif

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
hBsBAAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsl.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsm.gif

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
Uj7lVF7lVn7lWJ7lWu5ZEQAAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsn.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvso.gif

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
AAAAOw==

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsp.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsq.gif

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
PGACF9jAB44AAAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsr.gif

R0lGODlhwQH0AbMAAAAAAAAA/wBCtQBj3gCE7wCMAACUABAQEDExKc4AAP8AAP//////////////
/////ywAAAAAwQH0AQAE/nDJSau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987/8ixUUoXBQr
R6NiyUlSnMCodEqtWmfQSVb75Gq226t4TC6becRlUU2UqN1duHI9XzON57x+z++D2nCAgHhJR4Np
coZ4foyNjoxskZKTlJWWd4Rcgm5vhW+LmXJ1oI+lpqdSl6qrrIqui4ekTq+Jmqi3uLm6TaBtdHay
SLa1SqS7x8jJNgcssYjAg8ZzondM0crY2domzNve3+De3eHk5eal4+fq6+xX6e3w8fLL8/X29yrv
+Pv8/RX6/gIKlAdwoMGD5AoiXMgwmcKGECOaeiixokU9FC9q3FglI8eP/iB3eAxJsqQGAhRQLiDA
ksNIkzBjtpSAUuXKDS9j6gxZk+ZNnzuDCu3Q86ZNm0OTKgXa8+jSp0lVNp2AFKpVk0eL/rzKlSRS
qTO7ih1LtqzZs/UKqF3Ltq3bt3Djyp1Lt67du3jVVhjAt6/fv4ADCx4cmELew4gTK16s2F8Bk48p
DJAyeUJkkpf3ZQa5uTIQzws2fxRtj/TGzpQNQ3a8WnJqy635mdaIOgro2Rdxx9NdsfZn1SV5txMe
0feP27E1J18A2gfy4Kyhu7YNHHN069N/w5Yue3nzEQAAoHiOvTt3Cd9FhB9fPSTxde8bGiex/gR5
99fxZy9R38R9zvkB/rgffeLZ156A5pWHHgr9lfDfaAFCOCB4Bfp3oIQJ6jdBeiE0SMKDHMV3jogL
zUche9spiA+J6lQYgonqufjhhSbIuFuE+Hj4QWetVBJej5SAyJ+Nw+HISHhIJqnkkkw26eSTUIo3
AJCT/EhlJJNFqeWWXEKJCovkgHkFkS/o6AGMHZIJgpAEuqBmH2KCE2cVb7ZQZwZogmBmCGyCV+aX
RvpxJxB5frDnmjTSCWg/c1Ix6A+F4tCnFI+e0eg2l1JqRqQ3TBpFpZsG2geoPHBqg6dAkEpGptmw
mmqoE/KA6g+qjuGqMrf6UGsOnRHm66/A/pWoo4tm+MiuOOTKoQm5/rpZrHKnIHuDsi40a+ezK6Ii
rQ3UtmAtC9tS8a0u4+YQLg2iMaauXhWUm8K5Urh7i7wbJGCvvR4kcAG8MqQLqQX01ojtPQFnoO8E
B9e7L6zDcguwGfwSKqoNCS9w8L0I42uxBBVHDIO/PoBMhoz3avxBxTsUXIrKF5SMb8L6wrwxyh6/
IHKpD5dBcgko68CyIz9XUPHFGKNs8gQ1V5tzDzeLsTMFMXOscckWH+3zxDUMvTHHWyPctQRJe/vW
B0DuOLbOQmNcNddcy9wzr1jToDXRXUdNsx/vlX2moEL3zfbMXr+dbNwzuJzx1mpfTEHYMwSd4h5P
e/131G3/y6i2/nhbzkfkkwfueciEn8F4v5pD7rfkUivetuAOXx5t5qCPOnBpmMNZuh6jw+26Kbl/
THaPO/J9iuOw8158E8DvLfvwoUN8fMrCm0K87a9Tz3T0KzePtvU4Ly+99iM/f7X32e9eSu82354H
+q0be8VXNIW1APve/t5K8FHAD1QF9KMLvg5h0YpN+reCvCWvA9OjilNWUhWwzS4tZihKVQYoPt0B
QYJGWRjzzCcGDKYEaRUcXP5+skD+QYpdytsOcTKzGdIkMDQoRGC7HoenA7lwBVLZig4JqILpvZCE
W2ng/GIXGvwtbQMslKHm3jMb4SSRA6zKYQkdyD3ojTCD+1vc/vUAxq7HsEUCXoxMGFG4Fst40YZg
1EsZt9iuLsLQjXBc4xvNWEQailGNMTRBVrJIRT74UAp75GMfx1edMNbRkEVE5BnBeMgnwuYyi2Rj
igwpRhgy8oyYfGQa0QjJOqYAfiwJ5SMMeL8U/kB/OoyCyBZZyU4q8o1qfFwLN8lIIk7ykJfUZCbb
4klH1pKM7suA3pTIwV7iMpG6bOUMa8nMZlbSlsxkZS5zuctlevKa13xmtqDpnGB5ky/pmyYycQlH
S45znDGcpSslJk5pJlKZ1ZxmOme4ThV885tT+ONrWLCsE8hxjc/EZCsDSsZIwpKVXUzgP91ITnPG
c6HZ/OId/u9oTxf004Ldo04LLqrK/+WAoyIAafsyqh1+MgxaZBApouK1LsZMQaUfgClJt5lSDxxq
L6dAwC1EetNYVeGHhGppXDpl00fJdAw6RQVPjTotocIFV6Q7VVE9cFQxJPUUS6XqtKKKjHEFLKsd
qGoP84hEa15VA77EZjOJ2oGebmirMQBqXLlKA7ByQKwo6KQpK3DWGtIQAz+z6wbwKgKvQnWuUm0r
UwlpmDjG8ZILhaRBZzlHObKVA25d0EiVlgzDJhazi8VoNC05UGoOMZII5aQmdSBYDRD2RXTdhVfv
SVthKVarjB1tQI15RvGMMZbOXCYwWTvVsNa2tmplgVx9/ifMS0DxshvILHOsWMhjohaZvsWmXtf6
xMAW965w/YJz/dpV8VriuZ+NbmgteN3dlvMx2a3nPFVTz49+d7Dhbe55yXsMz9agtRl4LbMKultk
ljO7c9wkCyWaRora97ZhzS9ny4vY/97XtdXD6oUDLOH6dTa2MqjMlSgxXeMptQ4j/oSAjRhOCjM3
A11q0nRSLIkSx3hMY7jxdGkcCc2CLcZLKmuF+wtiE1YUgeu1KY6dFlKbEmfFg7yAf4ms30qgF8Yr
EGkBktzWJXs5pk7G7buEbF4r81e2ZSYxmTHALy1zGbNfVhSfwhxhFdSJN6pA62FfzOYsW1Q9cSbW
nDe6/oI7FxkXU9ZgCqDsUw3wsMtMHrRJ7bzmCVOZz4pG0aT1FOgpqIrRb6W0noeMZlJboM1/7lCn
NSVpP4v6zB52cYv7bM/j+grQjkrSqjFM6FcD9tDzAnaUz2cFJEV6TbYmTKErHetLzzrTJpbzro/E
bOXiyqlnw/ItHg3nY2cYsNh2y55hvextT5tWuGAcb5b7bCnHgNvvvkJfBV27dh+x1KP+k7mtMG9P
p9vU9ybXlZ217yr0m9X1tvSvP1xtX0ebCgf/1L8x7W6G5ztjauPA2+ANA45nIOKvKrjCKy7rhUPt
5BqHNrHTlvF8qQDk6BZ5s03ubJr/DXEmS9zNPU5w/pSPgHUhgHkIDNcB1vH8Whi3WsqtSW5EDzx1
Rfsc4O4m868BrmpEe5nSRyB0EGht6fzT9beBrjCm21zgzP461YzWMbEfy+1Yp1vd5k72D3T9ZCjP
uM6tbmzeid1oOM96zKy27nGffW5SrxzSpCs6DwG+c257OQtcRrmrT13ljuh73KUG+cSvleQ1B/3N
Kfcyz1E94Tefu+Itf4K7u1xya08brRP+eLp7PrlmR/vFoQ4z0k9t5xP3eedWX/nWT/7kkUc+5jMv
fNVbvvifD3guCt/x4KNu9L9fXQpcX3Tlry3yG7d+7ZPP+ujnfvpPB5f1p8B9jVON81lnW8+Orv7r
/n9t7zNDGfVLLvr6o14K7YcD9Fdu9nZ+TtdwY1Z1URCANzCADmdtCPhADXMCDpiABpdj6weBu6d7
TWeB38Z+GKiAPZR+6BeBFJiBCxiC/1dAJHiAG0iAHwiAKhiDLGiC32OD/IGCQMCANlCBDAJwBhhs
OEgfOvgDPFgDPniCFCd9LtiBPyiCRjiDDzdz/VeCL/iAxyJvUrhyBTiBN3iFHjiFMuhtYliDYCiB
fwWDYwJkQFYDRxgjbNgl29OFadiEZwdjcSiHAjgD6POGqiYDBJSHekhMTrhBZ2hk8baHgOiGDciH
5uKIe1WFdiiJy6eGNJA7fdiIi6iIiUiIdziJ/kxYiVi4iZ0oA37IaaTYg5DoiZSIhuYnimF4iato
ippYikg4izbIbiMXiqeGi7KYijFwiobii8Tofy3oheVziFoEjL9oizAgjErGjMVoiYWIe0KojCAk
jdpIjS4AjZDmjNM4iq34iq5ojb24jdWHjivgjd0Gjur4hKzIi4ZYjdnojvYojizAjtEVjvp2j0FY
h9dIj8OGdLWYjjOgj47Gjz1nkMcIkOX4Hpj4iO+4fQXZj6o4keSYkV8okEOEkdz4kflYkQt5ix65
f6Enj8vojyO5ki+AkNqmkgTJkLloeOOYkjLZjDdpkQqphCIZkzNpcRwZkZyIAXm2jzipkEX5/pIX
CZMaqYtUiJL1SJTjlZBDOQRTqZRMGYsWkJSzt5RVpmZYqYxOqYFBuQFc2ZUkmZUC45U6eZRWuV9h
WY1jaYZl6ZH4qJUsmZPGmJZ6WZNzOYJD2JFqiZcgWZh7mZeDiWvx+I/z+ImwCI9siZiHmZh/2JOT
6ZgO2Zg1GZVtuZNr6ZmEeZeSGZqMaY6aCZUDeZmUiYqgCZmdaZd+EomoCTQNiYh9eZukKZqGyZOR
6ZNiSZOzKZSWuZuuCZuK2ZuqiZJ/mQImaZSrmYPGGZt8+ZrPGY2LiYyjVJs2SZ24WZzc6ZvgGZ2s
qZ3LmVfayZmjmZ68WZ2V2Z3hSZymGZ/J/liX7Hmc36mb+Amdw5mfzcmBmGmb9/me+Ukgmieew1iV
6tmUwFma6CmgAfqZ78Z465mg8EmEssmg2RmYwtmDW7JlcTidgBiHHqolEpmV/WmFQSmIWyIGc5mE
GKoDKrqiF4qdtBmYIFCeLFZsJzWfdPmfG+mjI4CjpmQjBYoDLvmUjdAsJwqKL3qjASkjFfJoR6qB
RCqh6sOc55mh2FhYqemiNKcmUsowUNqgV5AZRKIqSxqQQMqlgrk4Xgp6Z8ptU2qGYJoHZnpqaJql
NbqlsNWmDvSmR1SnOjCngOmn22kr2ykeeWqjjJCmzDJsiroHd4qWNkCoWNqlejCpAHqd/pn5o5vJ
pmNqqKuSqGR6kGL6mOJyqKL6k/w3m07qp0qSqW7ad0V6A5ZqnpDqR6q6qHyapHr6qmQCqE06qGKq
a7FqKbvKpr3aqL+KP8eamixKBrfqT0/qdrzKkb7KqDMaQmM4quUYpM3KrZ0Krt/aA9P6qOXap8sq
rhpJrqcJgmUgpJxaAo76rjT6qvaagvGqpoWKrcyqrfOqq0i1o1pKlmu6p/66rVV0gfuarviasAvr
qjlasPxGsAjbo596sRn7sDzKsN6ar/QarhE7rAorsFZlsdmKpPf6r+sasJIqrSjLsga7sTJ7sBxL
sR6LqA47sRLLrvKprJ4KcTHrs+4K/rEma7QAq7Mn27AgSwL1GrQk67KyOrBMC7XUmrQvi7Utq7Ra
WLUde6lbm7VoFW5kpbFC67WjRLZP+7UCMZfnGrIMIa9OKx8wi7YDIbdFexBuO7TFhKJ6W7cfixB4
C7R/S7WBW7it2raAy7WIe5KKa7iMaxCDq66Cu7jRGrcLGhB7a7eP21Vq+7mg61KQy6KhW7qmaxdo
YQ9vm7qsqw2r27qwiwzCGru0O4e1e7v+MLu4u7sIx7u+Ow+6+7vCW6LDW7znELzGm7zuqbzMmwvI
27zQO6HRO71FSL3Wy3zXm700qL3cazrd+73kA77im2NwN77mm2vPe77Xm77qa73s/tu+0/u+8Au9
rzu/9stX95u/O1C/+mu//Nu/8Pu/AKy+AjzA5lvABiy+CJzA37vADMy9DvzA2RvBEmy9FFzB03vB
GEy/G9zBQefBINwBGhzCJFzCJnzCKJzCXfGsm2ootXqOMAyrqKrCHOEiZ6qfdRKsqhrDNBwTNvxj
iroeUTpEQewhQzw/9VHEBUKrpIrERdzDO3GsQ7zEIJTEUTnFVUzFghmpnMnFRAzFUdxHsarFXyzG
s0rGXhylxvbDy9gf8gvG2NuRoYrFZtzFVZyNdBxlbPzGcExtVETHS5zGV4yIgizHXizDedzHJLHH
SRzIZbzFh8rEPzbJhzzGQDzJ/oqcyZq8yZzcyZ78yaAcyqI8yqRcyqZ8yqicyqq8yqzcyq78yrAc
y7I8y7Rcy7Z8y7icy7q8y7zcy778y8AczMI8zMRczMZ8zMiczMq8zMzczM78zNAczdI8zdRczdZ8
zdiczdq8zdzczd78zeAczuI8zuRczuZ8zuiczsosY6vqJkFGpkxioGc8KGRMqcQLrefCxwfBc0Sa
rC3sbzscyaUKo3i6L/osFPysaDfMwwD9z+h5xBIXdgaNwYK6eFy8x0hs0fYM0f58yWHH0VQsxHqs
0aL4xHgMxJb8p0Ys0gbtxk780YZ6yI/80lms0WhM0zbNuxW9xfXsyPW40LbZ/s8wDNInjcdHPMfw
jIc/XceQjMlNndEx7NNPrSMyXcg8nZJW7NQQbaViUdFIXdQjvamhKtBhDdRyjNVg3aVUbWQ3zdQY
TdZpXc8xXcdy3dNsPcgyvLvxzNR/3MZNPM9r/dFw99VBPUhbHdZ4yNFnPdVLndbtTNNv/dB0XdZN
TNR5jbtefddx/c42adaGLdiSXNht+sNqzMJU+dWHzdd13dJ97dhC/ciBLMWVjddjfbuZ7ddx3Y65
CqBszNCj/dl3DK1GidqN/dSLLdm43drIDduYasfGvdp6/ZKEfdyX7dxwDdyODdy9zdzX7drKndq/
Xd2U7d2E3NTTTdiRLdyp/rvTaizG0C2qr73bnY3Xx53ViM3Xf+3S313cvd3eQW3X7h3VaI3f/m3Z
Vx3daLnGOR3TewLUnm3YVN0gCh7eD31TLGzS3y3ELE3hLx2nLL3dEz7fVyzheHrR9N3h3ds/B02V
+2m749m82w2i1euByBvjLP7Yxlu+bum8l/jCOuPjib3i6jzkRF7kRn7kSJ7kSr7kTN7kTv7kUB7l
Uj7lVF7lVn7lWJ7lWr4RC+0k8L3luvDab1LbYI56Nv7XZZ5wZD7UA53m3jvX+yjkbm7UJW7aMj3n
xHbn9Izn6abYe87nZh7Qgg7omyPazknoWVjeuo3ojdDl7GzdjB7pkj7p/pRe6ZZ+6Zie6Zq+6Zze
6Z7+6aBOgTGq46GuKxVa6q156Khu6gO66vXZ5tLbJpTOL6MDL3KezLQuz4PO57l+j7UqdqRO6L3e
lwZO3ZM+7K853cYu6ciel2se2rN+6u0J2KWt3NHe6tOe1Ml97bkJobO97ccu7S8+4KMt18wu7i58
4Sv94Zfe7K6+A+7+7vfs7fI+7/pZ7wSN7fiu7/a87z0+6lzt7wI/8ARf8NkcAAif8Aq/8Azf8AFg
8DXw8Cog8RAvAxSPAhdf8S+Q8SbA8RrPAh5PAiGPAgJwASUPAieP6SMvAitvAgKQ8hMA8x0g85Xe
8iBg8yRQ8jJP8xvA/vOTjvMeAPQioPMVAPMvT/NHvwBG//I/vwJCHwInb/QxP/VUr/Qpf/WS/vQb
oPUfgPUSEPVF//Vhr/Rjj+hcnwFnP/NVD/YUwPZUv/ORnvYXIPc93/ZiT/Z2j/dvf/RJz+h0XwF/
nwFw7/Z3D/d6T+mBPwGJb/JhT/h4b/iGb/ZODwNI7/WHf/WW7/NzvvgLwPlln/dfz/RFz/RLr/mb
P/kfDwOc7/mpTwGr3/obj/qwD/KyP/sTX/u2j/EOv/u8z/q5//vAH/ypawDEX/zGf/zIn/wGIPwn
sPwq4PzMTwLQjwLTH/0hUP0mgP3W7wHaL/3bPwLdD/672K4i20bi/mYF6ZJtlCuJkxsU4S8C7++0
LvRDSjpyTcOzKzuu1Bv/IMD/hQUBZU26iqxZb9499kIOFMuJPDfUXLO2fE15pmv7xnO9Mnaq91Uk
qKHwIrSALkULZXg0MpGjpBOaWp6ymqUySTyuWqSu60p0Ua3Q8jcWhMflc3oH6LvDpVhnXzutavpL
IQwE5CLzM8R4SVxUvFKUdBQUpJQEdPTCrOv0/AQtydMZ9WH0O526tJwsdH09RKtk5UqbTeXs2nrF
zVRRm4UMHSYuJi7FQdbBTZVdZVa1jWq7tdUM2bo+hB1j+w3mLBwLNy43P59RtlHH8drU9caERpUm
r46mV4nXzv3+/iIcF2nbpF1kdqFDmFAhOxoMbbjLV0ueOHz9gAXr1WviPVkDaUU0AgucyI/1FJ5E
GcqhjJU0IAK0tm0ezIExnrnSyAunTpM0QQqTGDSmv5RFjcppKWrOpU2VOsa751RMh6etRhrcKW6q
NKwUo5Jr+nHVUbJlayQVgZZFrCg1w3jF+bZnrkiaBLopaXCPFl1m5PLduKaNXiVsDppFnDiEWg+M
0b35oFjyZMqV8cBxPGwsVY+WPX8GTTnzhtGhqLE4HFr1atYoS2d43Vr2bNq1c8T+YVv3bt69bxgA
Hlz4cOLFcftGnlz5cubNnT+HHl36dOrVrV/Hnl37du7dvX8H/h9e/Hjy5ccrQJ9eAZ31G9rXUK8+
8Xvz9XnTn4BfhH4N/Pmb+O8o+gK0r0DV/JuBwPzcw0HBlAY0MMLZEKQgvQrWi+89+RbsLwMLK1wA
PQ87wFDDDysUsb0SVRTxwhYX/HBDByWkcT4GOQwRRRB35FA//DTUsUMOXsyRRxPzOxJHIJHc8cca
n0QyQymnpHLKHXzksccLsywSSy5VHJLELcd0skgcuxzRTDTHhJLGKt+EU8orM2RTSy6jPPPMMv+T
M08UwSSzTkCbDLTONg8ti8A9BW1x0CwXvTFSPNck9NEoZSz0TkQ3RUnRNCHM01E9Pw2z1FBPVRNU
PjP1k1NX/hHylNUlKxWUVEnTRBXSUdWktFdeXwXWHAVnBTVVUXkl1lQh9STW0WKTpbXVYKcNxcET
jWUxxVZ/JHJVZUO0cEBtU2W02C4bpTbd5WYchl0d3FU3XtDglcNcT+iVVzwAAHgOXzg2BMXffMHb
d2CDD8ahYIQXZjgEhRuGOOIFHpa44oMptjjjeDEeZl+POfaB3w0+FtnhCUrWOGUdQAYF5ZNpcHlk
mSuIWYOYa1Y5Z4dx/qRmnmf24GagORBaZ6NLYLnnoT2meWKSKfgYapuDdhplka9m+uiG45xyX66p
vMFnqV8+uWSrm5546AweNpvstLWG+OsMvZabThuKfnvsjbPdJhvnrNHW2+2f4TY6aU9IptjlqwGn
WeHB/1a877EJp7xsc36OPG/Ns14cab7f7lzzyuE2vBPM1+a7bbQHD3x1wUeH/XKqXZ88c7xpb131
2HcP5fHaAbc6dMbzZrt10XlHfg7W/97ccaaFb5x5fqUXvPTkr5eNdey3X0577r/vzXvwxye/fPPP
RywCAAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvss.gif

R0lGODlhAAIAArMAAAAAAAAAewAAhAAArQAAvQApjAApnGNjpf8AAP//////////////////////
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
N93pRo8AAAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvst.gif

R0lGODlhzwG8AbMAAAAAAAAAewAAhAAArQAAvQApjAApnABrAACUAGNjpf8AAP//////////////
/////ywAAAAAzwG8AQAE/nDJSau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuHxOr9vv+Lx+z+/7/4CBgoOEhYaH
iImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeopQqrqa2oq7CusqOwrLO3nrUKuLybura9
wZO1AQILwMLJi7sBzcUCxrvK04jMztDYyNTbftLOz9jR3ON93tfh2dLk63XmzejYCcfs9HHq3/DQ
Cfva9f5m987BK0CQoLp/CMcEfJevYMF+CSNmOYivocOHByVqrEJRILqL/g7nbRwpJWPFgSAdQiTJ
0ohJj+FSgszYsuaQlwxRylRJ06bPHTRPftw586dRHkFhYiOacuXRpy6S5hzKtCjUqy96Co1ZtWlP
rGBHaFUKrWtKAwachl27YexUrmYdokX7la1dC1+3Lo0rd27aunfv5iUrgG9fv2kDK6ZQV29ZwwQR
z1W7GGpjwpAjS55cWXAGx4Uzb/ZLuXNNwKAzFxiNGLDplqgxi2ZN2vXrjbHf7oVMW3Lp2whdp57d
uzXw0xuG8y7u2/ZxdsJlL2fu+7lG28oNUx/92/o07NL5bqft3Lsw59nFj+de3jwu9OHVr988oL17
WfB1P54+H/GA+vbd/ndKeenF1d9o/wEoYDIExmfggZIl+F+AC4bSoH6h8QchWhJOSGGFnLRXoFkb
+tfhhCDi98GIXZXo14kJdpeiJvaxWJWLc8GYIAEfzjgMCDYyhSOHOg5AAI89+vhIjQ6SOGSRRh7J
o5KgBBgkUUMaAKWUR8pIpSNWNtnik0VyKaWXXyoSJoaqZbmlmWceg+Y/++wThDwX4GkHhVfu5GaZ
cJ5Zi1F6LlAoD4dOkKgcfIp5I5k6BipoLD8tWqcEesqjKaZ2cnqoppl2CqqoouLRKJvEufimpLoc
1Smmihoaa6mwZkpBqbbSmusdH/Yp05+RSorknAjRKuuusN5aZ6HI/h4bq6eb7jmCr2dBCqOwCkgZ
VrTO1vrstxU0yy2ezc7RI7UgAXttoNlq6+qtsnpr6LizgotrvcmSy625JKB7kbonsmsmVMsq+qqd
+17qabjzGkyuwZx2S8e5jgppbcBmtstlmskykqS/h6kK6JmBchyvxyWAXBDAHXKp8cAmg5lyxVhe
3HKXwsbcSJILqKwZjm++DGeKr0bCs8+r2Swhj8IeCe0HD3MQtQuLnozJNwFIcjTNfiodY9NOn1y1
BWPnOUPVZUeCtTFLnoA0y1+DTUDH8So876jH2n3p3gvf/WnDfY+q79RXnySzCW97rUCUYNNNL7KP
4xu54w/nGnW5/pesHc4yKCQO9ImLM960437r+yy9ftct9urfTi4235povnkiPEvgucgShi56zlbv
C6/q4gKPb+/Do465JbKjU03nXP96se67S9rx1JNXH63rzFZefL6+Iw9a2nvUbnvz1X4+4c2Np+7w
+g0bvynCgdsL+N3Tm959JcmHY3cg4vdMfrqQgt5/5Da3JIAPFfnbDUEE0b/bleh8GEsfEg54igTu
pyCA6J//UKWhDdUnWBIUkAUzdJFuqMCBGxLg0uQGohHuhA8a3CA4qKIdHKlwhSG8jwuJoocYorA/
CtDSyEZXoR0yxVQr+OF6gihEEBJxQUY8YjtYoMTtMLGJ68qh/nuiWJWJUfF//4LQFbEYwSeKEGT8
SiIYQ7ZEEzmRd1D0GRxiOD4O1nA+YyTSG6VXxLe5gY4yzAcJ5TOePOoxi2bUYeLaAMgqssaQhywj
HM+4xpXNRQ2ADKRFOtgbSEYSfYncogPTkElH+oY2qwrlFAYlkgkAJiO7yCQauPggxADkBaYkTW9S
OUkqHKQnr6yALNNASydthgyyzCVdisNLPlqBJtJgRTT7oY5oSoBS1XSlHYo5ptEoBJeV/Bl5mNPM
kmEBGbG8ZjqvKUxtziOb1rRmHbj5KNqAYZi59GSEhtjLZ8ZTm61qJzxZmc51zlOZX8BnOJP2yO2U
c2hcKChA/jVgUINO1KJzoKfFmNMFhdqRkK3RJ3346UyOMOad6mwlME+aTXa6dJvK9IsWhqlJndyx
NfN5KMyuQNCUTvMrv1RnUF960IXOZyIx+KFIWaPTjfXRqP15pgxQuFSmktSccYRqVH05Va0u80BN
dVdWP1rLA63yBQhIKwK8WlVUXhWiY50hXEAKISjIUq1qJasx2+rWPWKVknrtZomecFe8rlWuClQP
X/uKyH6aR6M1E1kTNHiAylbWsIcVZJsWy1hJllQGAAitaEdL2tKa9rSoTa1qV8va1rqWtEyAbNdw
twSeWfaymMVrZTWbGc52FpSOfQEAFjHcJcjWeeYbQBIC/nTbAxjWAnhdQFoPsEm++Pa3OFSlcIkb
25iSs0NHcE1znRvdECBgt3M1iwIYirvGfjYGxU1EfJNw3PK1N0FF6ElzMYuC6VL3gl1ZL3sf+Nad
zmC+h0DwEeoLwOSCVwi7GO9z0XpeADNFwAP2YIGdSgMFF8LDRWBwGB384B7sd8I1OO8B4oLhDEMo
rGHrMHeN611mAuoGEi4vD/xblRa7GKwbFuuBZ6wEEbNRw06EwYnLS1PznpcoPv5xf2BcQBkrAsRE
MLIlSZzdKp9gyWm9QJNHoOKm2JfAfoXrkK/cXa+i2b1e9kCO1cqBMZO5zA9B7n2B+14YYFkQfxaC
lsX5/mbPOk3HFABzmEFgZxJM1yCz3XOX+7xdNtPYzUiGMwEwO+dFk6DRJsCzngvN57+Clsj0rfEu
35pbFKMA1KF+8qgzbWg1n9rSRVY1dncUKP7CANaflsCjGyxpXmvRz6hGwqClnFNWG/a2LAC2WCog
akLTutS2hm+yF6xrq6Z503R+tmVPIO0Q9GTY1n5xkGO8Zvm2ObD1LPYAWUhttTbX3EoAzHSz9MlJ
m1rbuE41ptX9bQ5fQNyV7UC5P+AcFcPN2Np1QaABMXEgLPvh8z42BhB+AAwsXOEf2DeXIR5ciW/b
CBf3WsYjvgHdQruV+RWByK/t72wjO+DK7jaC1h3n/jvbe9wxd3RlaU5ySpsc59weOJALLuQUcBwI
tZt5s5nO7lu7+9Lw3qi8o/fvV0/g6TnQoNQdynMbVNwPZ/dByke+8pKX4CsuTzgNAOnw8VDZ7CcP
sc5HSvWek7sDYG9BYQ9g97LXIO0jmF3YsYF3rCPWwsbcOgEFL/O4d9zrMRi7tzVtYKu/QPE4UADj
D//uxw+yrKSueecxXwKEB5sGdd91243eAsSLAPQ2EP3orZxrpU/Z8Cqg+8/lXucbaN6NnDe4512A
+7kvoPk3733WIyt5egc/85b3uA6O3++id73SMIB+DKQh/qNL3/RtUjnXbf52G7ieqDmI/YuA3+7P
/u++BuS///KTPv1Ip9777DdtO5B9O3Ze+9R3jRd++icD6lB+tVd6vMVJS5d8TWcCH0cB7xd/Bpgj
9Ld/LOCA0UYBILgCtrcDa1d9GieAPZARGZhiQ0dG2LZ60Wd/0IB/FTCCKlCCOnCC/zd73ycCFwh/
0BV3sGeAd0d6MYCDrCcBSogCOpgDPEh0PhiA+LaCTuZflwcD09WBAKeANTgDNNGEJ/CEOBCFBEeB
Vfd6SBFrw4dWB4CASOiFbDN+FyCGJkCGN2CGE1hrMgiEVrgCLXgCWxiDyteFNDiHWYEBdlgCeGgD
evh7cPh3QCED4uZ056V6hTiDzLeAIViHnAh+/gLXf7N2hnyYiVWoA8BGhK33hlPYh+Z3iHSoiJ/4
ijnne1OHhn53iqHXA4EIeJc4eXEIi4mYAYtIAo1YA494i6VYgX4YdkNQiSF3XtZXf5v4hVGhAcU4
AsdIA8m4HkfYfs6IBKrYcgeQgg+YhLNogRuQjSKwjTPQjYUXiWqYe07Qi18njbTHAu4oi9a4ArbB
jiGwj0m1dweIi+q4i1MAjfVGXmnFjKBYjYiYAs4BkCAgkDAAj2Qnj81Ij1mgkNJlWGmoiS1AkXjR
ASTpARYJTrbojVzIaDcQhJT4c5gVkg85kum4ket4kyQIgdVFV6RIiA4Jchw5Bq1Gk7Rok/0o/okm
qZM5yJM25ZN7CJRGWXw2eAacloXUiJQRCY4ecJIdkJIugJHU8Y04GYtogGjBCJHX9wFeyQFg2QJi
+V0ayXBVaQlvyYRMSZVsmZdO6JQ0BJWQaJAqaJZ2KQMkSSFtuQF3qUYrGY+CWZbXmAmLSZEfkpga
sJgnRJDIt4xTmQFjBpNsMJl8qX23N5p36JfphXpSuH6uSFEMyAmimZS6CAKWmQGYmQJxaWNzqZfD
uAmxuZV0SQK1iQG3yTyNmZGPGZy96ZuGaZonJZzOaYyomViq+ZOYGJSe+Wuf8JvzWJqyKZIop5nz
t5uuuZyw2ZzfyZuJF53aOJ2QJ1g9yJqm/pidkbmd6AmcbYECw3kBxek24smB5EmfnQgK3Dmb65me
RzlB+xCBNxWfwOgBmQSac1CgymkC+2kB/akCCcCggKmMUpmLpOmPpEChQqmf7NmOUcCh1RmV19mZ
7SSiI3qfFXoCF1oBGfqBf7migcmZIFqSMBqj6IigPpoCNUoBN6qV6cd28omdLyqRp0Ci5akCRToB
R4qUSYqCLPecTvqkMqqeJiqk+ogFpxd5DjqNUaqUpgClYqaWaVkFqVKm5qilB4kKajqkKzClElCl
MSCBO/qhJfp2EqoHdSqnd3qiAdkFHcqSAUqokMmlQYqfQiilhlqRX0Cmq/mgZ9qojiqH/gLKpryH
qPEGp1kKc5q6qcK4ppzaplygdaLqdpEKobwwqE2GpwugpzhAfa2aj0kSqH9Qp2NGq7aaA6PIogDY
mqQ6o7PgqzMArGdAbLn6g6+an8GgpnbGrM16ZNZZrPN5rH8aq13qTss6qR8QrD3Ab93XittKIbwK
aN/KraealWbAb2Rpp93aCyQKata6Bhi3pEYZIOs6CBQKa/nKBkqKqU1ar9PapcA2sG3wrAHYHv9K
CNwpbQzbsNmKrg4JseMwsTlQsW5ArBhLk+URsR92n+XmsW/goS3qdyO7DrG5cCibso7Jo6gqreQg
mqK3AzELB8hJs/RaszfbnDmrAzsb/gdymZzRCq4ua5i6p7PiipJ8oJtI665Ku7SP6rRgupN9IHv8
2nPB5A/k2gVhGwU7p5FfC7Z5lwd8h7R1QbKMMLZbALdSsJl+yqhJu7FpG7Xn2rV2S7VWe3WEsLeY
ulISIbdZYLhV8I2EW7h5+wfAB00jgbhXILlW8JiwRBKUWwWZW7krC39uKwmbOwWhm7ja6i5DhbmN
WwghW0AtxRKjGwWvewWT17qum7qHwELyVBOx+wS7iwVNk7u6a7uKkDHZglEt0btNgLxZMCmU8hPK
uwTPu7wBZRTRmwTVe07NS73CCyafy5xIpzNycL1HIL7g64ESW752QL5FoL7om6Dn/tu+E7q98EsG
7DsE9Tu/KXC/QaC/+Hua39u/acC/P5CSvxBL9sFKHgdNv9S204QXQNW8ttAdBZxS+Pe5EtzAnqnA
PCDAPkDAGgyh0ytmsLTAGUzBjAFMGBzBI0vCxCIWFozBCWzCIuzAGyy/IExuK0zDcnLDwvTBLjUn
6GTAude9rvRKPNPCffm/FujDIVzEPHzCJozAKlzE2SvDTrzDclLFMixN1QTBCJzFCwwRIfzFUuzF
UZy9X+zEaQzGDRzEWMzGVBzGgPRadFzHdnzHeNxaURFQU/zGUKxwH9zHgpzCPvzHg6zDPkXIFHzI
WExNitzIbfzIjNzHhhzIkQzF/pMsyUTsMZZsxZ4cwz46wpnsyWKsyQ7Mx3K8yD+FTUasygSFwqPc
w2tMyVccy5n8yrDRyX58xXUGyyxsyrsczJCsyoj8xzscy7KMwsTcwzTMyGDMyzMczLYMzKWMxOeh
y6X8xCcMDNNMykOFzNBcy9Tcysw8zOUszstcyRQFw+j8xmW8zGphzb3gyOlszG3xwOpszrTczuD8
yd2sz+wMz6b8z87czvnsxvw8zrjBxGsszNFczHBszhF9yl3sytmMyKh8xkFczRudykLFzWXc0Q/t
yKxszyDtxSIdFhfdy7W1yQDsSwH90fFMxPL80nnQ0B+9zkxQ0zbd0z7900Ad/tRCPdREXdTvoa6/
4I8ubdRnsM+AbM86XcJMLQpOzdLhLNWgPNWfMChjrMV+rMInjcogHcdaTSMKfc7HTMhnXdVlbTSa
PMtJDdDQjMsO3dbDAMxZfdAVncgavdR2PRF4/dB6ndDe/NeV8M9QLdCELdeGTQlc3NeCvc17bdEw
jNONfdmYndmavdmc3dme/dmgHdqiPdqkXdqmfdqondqqvdqs3dqu/dqwHduyPdu0Xdu2fdu4ndu6
vdsbUV4IQG0a8NsYKF28DQnCLWwHF9zAXdzGDV3C9tvCTWfLTdzULd3Hfd3M/QeeRtzRDd1fN93R
Td3cjdzhnd3aHd7Y7Wrk/v3dE+bd3m3egeDe7K3c6e3c8g3fe3Dc493d4q3f3z3fyB3g4o3feuDb
z13d2z3c/y3dAu7fBP7gEB7hEj7hFF7hFn7hGJ4MebzhHN7hHg5bGX6oShzixGnDIc7BPYDiZa3i
O8DiU+3iOQDjRi3jN0DjRG3jqkritmniGY7jn6rjisnjGO7j8Ark/CnkF07k5mvkNorkFq7khsjk
JT7iUl6rTl7hUA6eVU6lV07hWV6TW87lVC7lX+6+YV7m5xjmGNrlE47mYarmaz7mTO7mWgvnRsrm
Ek7nTWnndy7nRq7n+cvnfQ64gj6o4Zq1ey7oVo59iO6pRX7mhplWkNqu/ku+5ZMp6Vg76W+u6KKZ
4DZQtGSOnp5OA6A+5/c56pQe5Xb+m6h+tTkO6Vfb6u9a6VVeoLKulQlY6N9664Xa6EnM6bvu4Kn6
46verrxOpE/7lYqep5R+7DSa7G657Is+7Pd46Jpe57ru6hgo7Djq62Mo7XXq7NDp7f4L7Npeb+dO
66Ge7ttO7epu6uxe7bOu6nBu6B8571oO6+4+hI7+7n+e6vze7dee6Nm+7wHf6wMf6Mtu7/IuqeTO
iOAO8AfH7Qea8L9e8Pg+8Qif63zO8O2O7A8vnQsv8RtH8bQJ7UE+8vEe3CbflSh/mRG/8hkg7sT4
8juu8gbfci3PAaX+/u8yz/IWavNTbu45zwE0f4NCf+Q4n/FGv/M1H/LtufT9DgJHPwE9D+QeD/Te
afHfLvW4Hmtbz/HF/vO+GPavbukkH40hcPU6nvVNf/JQj6JeL/AqIO5sT+Ju//YuH/ciTvRMX3l7
z/XljvFTD/Y8n/Rx7veF33pOf/cnnvZ3dvh8T6lzv/EtcOuO3+OQ72gmn/lDvvmR//SCD/GV7/Cj
7wGt7vlJDvqcz4+nH/WK//VaKOyq/+Ss3/oWUPtYfvu4L4KI3+SlD/KvT/X+rftezvuM7/uTP64x
X/QssN3G3+bIn/x4ufxQG/xfOvyA/3y/P+iEL/sp9tvRn+fTD/bj/h/heV/3CHD+EJ7+6t/9Yh77
dL9966/9lC//WlD1g9/xeI7+/Q8BS05a7cVZb979B0NxJEvzRDcgZVs3XF95pmv7xnNdinf/X/SA
Q2LReESShEmmsvmERqVTGNWKWV61W27XlfVCwWFy2Rwen41pddv9HrLhO/ncfseX6nnanv8HBPQL
ZBkkPEQ0M0x0YnR8VFuE/JCctLz8qcTM0Nz0/GzpBJ0QHTU97SgdVUVtdeV5rYqdpU2ttb3N1Q3a
5ez9jWX9FAYuviPeRDZeblO+dGaORpOGlrbWAsjW3ubu9v4GDxcfJy83575OV19nb3d/h4+Xn6ev
t7/Hz9ff5+/3FP8HGFDgQIIFDR5EmFDhQoYNi0UAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsu.gif

R0lGODlhAAIAAbMAAAAAAGNjpdbW1v8AAP//////////////////////////////////////////
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
jNzIjgwFEQAAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsv1.gif

R0lGODlhFgGtALMAAAAAAGNjpaWtrf8AAP//////////////////////////////////////////
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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsv2.gif

R0lGODlhEgGzALMAAAAAAGNjpaWtrf8AAP//////////////////////////////////////////
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
HZ5UN6A188Jts5tb2Ga2OtT97noq21Z/Jpa7igHEd8EbN2h8FrTvhS8f5DtfeBnjvvhNLXythAWZ
zNe6wPgvE7rImAF/AhEHRjAvFBwK81LWbwY+cMgo/Np58vbBTInwOwzbXvcKWL92C7GGSaRNAHcz
v9wF8WEiLOE8otTFLz5xjFM8YxFzI5U4NoiFMcfjHq94HUBuAoM9M2ArkY/GNS5Gkhc8ZOI497pP
hjKSkRnkGFbZxrjF8ra0PJAcKtmE5E2zI+RFZqUysstePkZ239XMNkPEzFQ+hJr37D93QJm+pMBz
hQ8h/oI5YwnD1vkzQgTd4WX+AdGJtrNOGH1ZQldhv0r7M6BXZMS3mvDR8EuPplPY6Up8+tKQ/tio
J61HOMfZ0agOtXFWzZVSn9nSp77IqJto6zzDOteb2DW9tPjVUwM72LsOtAVd/eqegvolwn4RsT2N
a0vnJNpsWmOxqw1rqWDbFdqm9q+tTblvpyXcpua2s2Ud6WSfOwvMbva2j11uYb+bc+sed7dhEW30
bCHeYjE2uZHX70VoAeAWEfi++d3v3Pw73xBfOMMLDmaEe0bh665Sw5tycH2Le+C32LgmLX5xdW/b
dSKfDlcbHfGMRzDlbL21x0/+cpHH3Nctp3nNG14HbJSme+bULt7Gp1QHoONc4jsX9soHbfRbZ6/h
N2d6zoNujX5HneXzBnkzon31Sjc9zyfk+kGx/vFPkRcvqVaG0sfu9Z7y+e1pV/uuM/f2s4et0HX/
3N33zve++/3vgA+84AdP+MIb/vCIV0EEAAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsv3.gif

R0lGODlhEAGuALMAAAAAAGNjpaWtrf8AAP//////////////////////////////////////////
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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsw.gif

R0lGODlhAAIAAbMAAAAAAABaAABjAAB7AACUAGNjpaUAAMYAANbW1v8AAP//////////////////
/////ywAAAAAAAIAAQAE/lDJSau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuDwEqNQ/d7sib7nzJX8dAIODMYSF
gH0liICHgRiPIo5zlJWQfJF7ipscgZmQei5/mZ8anqEbpYKolq1zdXmkF6N4nB60oqy6tbqqmie4
rsJwsBOxiIS2v8exiYzMqRnJzn6YjBSRx79719jI3cHTjdve1o+kz8bOjeYwCe/wEgkc8xT1E+/D
rX6J2/yz6vo1W/bvH7lZ4AJ+ExjQTkKC/Q76i9iQocVuEzM6DBexWseP/i7uhRA5j6QCkfriFASZ
raFBhTA1pjoHclnFPgNz3szoaRLLndgomhpo06JEoixQgrhXEp+8lJSaGXypB5OxdDzZYTR1FZlL
rapWCjzEiapMn0i7Quv002hPcUkvMG1agelJp0+hqlQ3VWhQq6H6FmUbNGtbUIUFf9LJKq3Mmjtx
MR58Sga8fHnrYbbn1G5evW+sHQaYOCZjx4VNC6asTCxrVGYBGz467vFBxTFn+xKh9K7v35ztmgQd
GvYzWanFVcPKDXXza4VWr8WpXG3XS47DQYd71d/W5+2sk4PLfUVvzXjr/qb7mbj79/B5y/18fj3w
3vHz689f3/dm9ZwF/rjfgAS6199J7AGYXnsFNuggfyPg92AWu01oYQeejXRhFxVu6CEG8cj3oRYd
jmjiicWhqOKKlpTI4oswcuFijDSKUcCNOOao44489ujjj0AGKeSQPIIwIyUE1DhgAXoxOSQAREYp
5ZRUVikkAQQEqWRKTELlJAJghikmmACMOaaEcWBp5ppdbilMm/p8uaaYZc6J5htqzmkmnG5awueb
ChSgJ5l63tlGnoOO+Wefcyzaipx61rmmoWogmqiijLriqJ+BDiqpmZSegSUBl+q5aaZunEoJpGt+
KmaoZVhaKpuocuplp7OGCesYsua6Z62VqNoorrnuGkavvv4K7LC3/gpaLBzIJqvssnEIKweriRrr
RbTSTkvtG9ZWS2y2h3LbrbffthEuHNgWuoa559KaLrhNjutuGvDGK++86tbr7KDaXpGvvvvyu8a6
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
ruzaru76rvAar/I6r/Rar/Z6r/iar8oaAQAAOw==

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsx.gif

R0lGODlhbgEhAbMAAFJSUmNjpf8AAP//////////////////////////////////////////////
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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsy.gif

R0lGODlhAAIAAbMAAAAAAAAAewCUAFJSlKUAAMYAAP8AAP//////////////////////////////
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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsb1.gif

R0lGODlhiAG+ALMAAAAAAAgICM5jAM7O//f39//OAP//zv//////////////////////////////
/////ywAAAAAiAG+AAAE/vDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuHxOr9vv+Lx+z+/7/4CBgoOEhYaH
iImKi4yNjo8HBZCTjAWWl5iSK5mZPpqUoDKcmBWXpaOfFKiWkawbpqqusauyobYttRmksbMWua0S
v76wE8TBmr+pt8sowqfAvNHSxcjKw9DUxK7OzN0nqNfY4sbH4OIX26mSu+md3u8l5tTz2e6no/QY
srWfpu278AKC4NYK37F8z3RZq2dPHbuFAiNyILgqH7mDChUajHSvmsSP/h+4CUs3DeEwfCORnSzH
CaTLktnQseKX6+KsiiuTzZT3sqfPn0CDCh1KtKjRo0iTKl3KtKnTp1CjSp1KteoaAVhs2gzGgpYn
qzSwZgHIEmfMm/bQdtraq63ajWBfiB1L1p81ZWTH6QxHkOW9hMm6ABg82NFcugDtvlqHt3G4aH13
duznMUxhAAMyE94MoNBhugWrMU6LkaZbhu4iV+b6sGxfKIUlYM5Mu/YAzoT5fAZdrmBocvsctjw5
/FzCcTH/sX2Sm8Js29Ch444dZzdv18ZRa6OsDyJGmRuFk9RCvcLz6OjTT++cxvr1stldbz97XKbG
4o3HXylv4Xz6/wDe/jZdGO6951dFKX2XHUXgJMjRX7/lpURzGvgX4IUXrodFgQb2RktKjJ3m2308
JXfXTnAlwV+FGLboInQBDOgEh3Exx94HFr6oI3oGqCcjETTWyMSKHeS445FIxohbD0EKiQSFIhiJ
5JE9ZlblAFdaCSAASm4WlpNSEBmClFOW6WKW6HXppQpNgjmEmFGaKaeW0F1pp2130hndmiW0iYif
a0CJAplzFirnZpqZAOifi5YBpwmEGvpfnnjSRqmeWXYpXZ/vNGrZjS5EKumo6QWg5H+gguCpIgKs
St6jKYhKanSXWkprbTHGiGWAqXrg6iK/VgHrCrLOOqeppurYKwfB/gKLxrAsFDsrmpTeiayuaOpZ
KgGqvtTqGILWIK2xGCI7Lqrd+tTsk8vacC6p1NJmKpe1VWtrhh+sC8m3W0Arw7vkZparf9mW2a4F
+lKSsA/+zgBwoVdeW++tARZs28EULKywxjeE28PDx3JJcMCJbsAxKCf/izEPIB/J2cR13rsrpjID
GAC3GaSMss7RrvwxyZoRFjPQe2rAcyhHQ9rwDi1vKTSG9tI8Ka85Q5V0lD4H0bR0TxPtMgZX28Lv
Dx4/OSeiXpt5M8JVhY1B2SpOiXbaZ7Nt1dgdZ33EuC/TPWqqbneatxWizu33rKAGDg/eoS5tNnqG
H07ujYoLdLLj/hNe3LXkRLNXeUSMKy2YgINxLnlnn3/ULJ9YRG663wCkDlLoIDynYROcyfb667J7
WwKhtwPB+gRb736kAHqDueq5wdMwfH/GHy7AbW762mjxamJeIdzQR5/29NRX7+uYxmafvGzcZ1C8
9xeCP0AA4ufr5/oXmp/q8+SzT7L74cc/fpG7y50K6Kc/9PDvfP6jnXm8h8ANELCAtuFf//yXLwcy
MFoQnJUEJ0hB66nvgsTK4Kg2yMEO/q97xmsgi0RYKBK+z4QjsM4DkaTCD7JQTi4sIQw7wLgZfi2E
NyxTDnW4Qx46B4QDDOKUhkjEIjJLLD7cUQ3fpsTjBQh+TiQB/laiqCwMVvFFTCxZFmMYRq9N8QJc
5FwZmzhGDsQuemdE4RcDtEY2tpFFrQqgF+cIoDq+8I5xyowfSRXHBfLxP4MsZBHPM0hJKZJ4h0xP
Ix8JQ//k8XCUPEAab5jJDuaokYfaYyTN1EkKGumSZhTlKOUGyECmUJWr/OEiSrmETbYok7YUIS3d
sMu4wRGWsewiI9ZDzGLizwPGBOIrlRlMWSriMgPEXGz4Q8lc4ouZzdQRFmepPfVp8nzTvB82TYfL
bNKwEekbE/H0Fk7zjJNz5TSnFNHZzbe504HfJOY7TwdMeVJtmPVEY38wBipw5m+ZSfTni7b5zM48
8mBEEicy/hFozX8mVKG3pKcxNyrA7S2JeObJzZIoisRYYdRFvWQDexw6gkImU5MwBSlJf7nPkxZt
mLKJqTpjJdB8OkenyCzpoGxaLkiwNEoD7OlRczpThJqUqBZFJ1BxlNT+MPWnTdVjTaFKm5TycqrI
rOo9lwrTrL4unlxVj1HBWiSx/rSsWD2oVi+a1ugwFKcqfKhSgUpWANKUrnW92FrzisalLWulfGXr
Cp061MDe1BF9Des9FWvPsSbWrOTsZ2C92obItvWtIKXqW8nq2cXO9amOFewjSotP0Oa0dqO97Jhw
A0/N1pWzKqVshSb72tohFq4ybantBjOwjebqWiJz0V1P/lDRAuI2ULr1pmuj603EFpS66nugyMxV
XI5+1I2p3dRqsWtVmU7zdystD2s7QABdjcpitWGnd8OrWsjGlKOgheZvhSvS3MWRW6WjWycDTN/n
quGoK7sudZozxQRXs6K0dG9qDZwGBLeWqTKqYdYGnMteEvi2awWudDGsX/KWNwfcau8mvSphrq7N
vmXdaGj12dIfAJiLuP2wTSn8rHX6jME9RWoQVIy4G7QYozx+VkFf6pzvCvlN2s2BjuWZ5AprTQgp
PgCRteVMIzcXaC+ehHfHTOZjAgHAAagby748uVbqgMi1umYPjrzKKrcSzawUHpsd6WYUa1nLyYoz
5IZA/uc5hrnPKN4ySosw5SraGdF/bm+ahybeIhSak5C28QGSJWcjNFqXmda0pGc2aCVcuoCHDjUP
CDBqtQ5pz4tW9aojDeg0Z+vRIjg1lwUs6yGwmtPxjcKnT9trUbcY1yXQteRSXWxNBxjZSmMftJtN
xWmbQMLwBZq1qR3SbUf7rNxmVzqXgK1l4yzcKjJzLScNO3TDRt1HKHcq3T2Fjq47bd6mNwnsHW9b
k4zZ+hYWvD/GbmPlO+DEGngO5P03hJOB3wQvssPP4GQdADvbyj33xCuscBcAO5QbhwPEZaDsjIac
DiMPVcG7fHKUd5wEF68ZulrOB5EFNAMfjzXN85BllfSN+wMMx7gdd66HlI9p5Vsi+h00XqSXXyDn
21I6QH9eAahXutdMV0HWv7B1pVF902Q6uNTBUPHCllrWXT9B2rmwdhgYfcpiHzvHw/XhuPuk7STA
exb0LmU+PVvuQWlen/keAsJbwfBC+DrgF8/4xjv+8WqHvOQnDwXEU/7ymLeB5TPP+c6zYPOeD73o
RQD60Zt+DhEAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsc1.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsa1.gif

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
QlH6p5mKURnwpRA1pW3qqaNKqJcxh/vES4Nqpov6o6pqT2vqRI6aqphKRaZaqk8UqIjIp4lKqq16
qGUqqkBqqkA6qrZ6iJWaT/Ikq50qp4tKpIUKSlSappvqGZSqT9X0rKvKqtMartRqp5kqUePKqNW6
rdcKq7k0rJJVFt1qrt+6q3FKrOPaq4pqpe5qr8cKrmFarfmqqqxaGZFKqtq6p8CaTxtFpasqU78a
scxaq+CKq5wUqU1KsEmkresaHPGqBB/rq58qqS0QsnRhskeAslygsmzBskbgslcAsz06szRbszZ7
szibszq7sy4KQCglRmh1AYEmaAlF/kNAy0r1U0MvsFmDNLRFG7RBixdKWwGjFbVUe7SwRLRH5bNI
+7REe0MEpVlJe1Bfa1CoMbVehFCixUxgGwJoW0xpK1Vhq1NNG7drOxpou0rlBFJVO1roNE4jlWgp
BYg/u0x+27eqdFPOJLZ6a7dN60xce7Zkm0jKJFBwe7XMZLnn5LZTdbhflEWay7hFa7Z6S0ah67WS
m0iYW7lvCLos5bQkdboY1Ll8C7ile7uii1Nca7slhbuYi7eT+7uuK7RjG7aFG7ubm7Z+a7zFC0ZW
JFJ8O7tzS7yUu0XJ1Lxza7VxkbeH9LnBq7bHe7pbG7wD9bzJy7QkRbera73d67tshusZ3Gu44ru4
zNu+yMtOv5tO82u/7xu45Ju9myu7OXUZTpu3IXW03ku9xCtS6VtUkZu552u+/Tu6dLW7jyZQj4u9
CaW9gMHBhOgD4/tCZUvAI9wFHrwIJyy1JewFKfwHLcyzMBzDMjzDNFzDNnzDOJzDOrzDPNzDPvzD
QBzEQjzERGwcEQAAADs=

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsill1.gif

R0lGODlhAAEAAbMAAACUAGtra8YAAP8AAP//////////////////////////////////////////
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
AAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/pvsill2.gif

R0lGODlhAAEAAbMAAAB7AACUAGtra8YAAP8AAP//////////////////////////////////////
/////ywAAAAAAAEAAQAE/rDISau9OOvNu/9gKI5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqP
yKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuHxOr9vv+Lx+z+/7/xkCgoMCN4SF
gGyCK4sdjQWPiWiRJ5SBiJCYkmeWmYePhxKfFJSdoROEpIOoq5tKo6KIjbOytZmqFq2ssby3vou0
rkmmtr/Fwb4XusixzM26wkXEvcjVxZfUmMDXvdHDmrvG2d2pudrH6N3q3kbT4u+g0OHw6eLO7EGf
9bTQ8ZfL5Z6di9cJ35SCuEAgNKhmYbIPDhlyAlchojKKEjNq3Mixo8eP/iBDihxJsqTJkyhTqlzJ
sqXLlzBjypxJs6bNmzhz6tzJs6fPn0CDCh1KtKjRo0iTKl16kgBTLwSiPt3itOpUqle5OM2qZStX
CgPCih1LtqzZs2jTql3Ltq3bt2GjDSA5V1hdkXc35QW5N1Ffj3//BOY4uE9hjYf3JJa4OE9jg4/v
RGY3uU5luZghs5Xrls/ljZ/RhM442kxphqfJpMa3Wkxrb6/BxLbr2eVsL7f11m6Zm0tvv7tZ/tYy
XHDwlcWxJDd8XOVyK88VN08ZnUp1x9NRXpeyXXL2k92hhLf83eR4J+fnpGeyPk57Je/fxEcyv019
I/fX5CeyP01/If+d/hEgEAOWUaAPB46RIA8LhtGgDg9+ESEOE3ZRoQ0XbnFZABxyuIGHBYBIgYgj
dhjADxkSJ4KIJFoAYoshnlgBizIyaNuKNcJYogYw0ojgjSHoGKOPMU5gYo1GIplkhyWSaOKSSm6Q
YhYbtviijFdKkKWLVmLppZZfFrllB1MqVwKTYKZZ5JpjcpljmGC2OSSaZAJ5Zphb5hnljHi+yaaS
Qkpp5wdE6qmmnGv+eWiffI5Q5hWVFcqoookmaSmlhooJJwePQjfCkU36mSiobtJI55xvmrpnBp1W
kWCgMbRqHRSwwpCXVyDhWsCrq8qwl64cAStrCwNEZaxUHh177LAs/vwakrDHAduRrsyuUK145ZV0
bQrbopctXd+O1O0J47IXLl7nhhQbAOx6AAAG74IQr62DojDvvBrga4K+xNa77wXsxhvwuwFLUHAB
BB+McLsGE+yrvyXwey/CEzhMscEUT6xxww/ztoLEFV+cccUFW5zxwCLz2yzEJICM8cYpj/xyBRPH
ynLLIcMss8AO62wxw/R6zILCB2vM88g1E23yC+Uu0TQJTycRtQhTH1E1CFcXkbUHWw/RNac3qxe2
HF8HUbYGZ6OYLl9rf5Q2Bm/3ELcFc+9QN1hju5c3HHfn0LcEf98QeOAYtg2Y4R0Nvrd8i7tBeA2K
C63H4zRELhzi/oRhDprmiHFOmueMgY6a6JCRzprplKEOm+qZTd64fa+zQfkMcNVu++24d/bVB9Lu
HkXvvj8BfPBNDE98ElYZf7wRxi4vhfLORy/99NRXb/312Gev/fbcd+/99+CHL/745Jdv/vnop6/+
+uy37/778Mcv//z012///fjnL4k+hgTUvUUeAKA/vAdAR2DkIvPgHjH4JxCBaKIUGDnFM1RBkAMK
BRb0GMctImEJeVhDg9tYB1Hc8cEMPqQiA+RgKyDov6KQcB8w3EAJN8iNEyLlhSC8RgvJEcN3JDAp
ODRhBRGYwyLSUIRDYWAJJZgMhEiQiU8ESAGzEpEp2lB9DrHiGBXTtxAtblF/YAyjGMdIxjKa8Yxo
REIEAAA7

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/worldgen.jpe

/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEP
ERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4e
Hh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAH+AoADASIA
AhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA
AAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWm
p6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEA
AwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSEx
BhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElK
U1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3
uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5z0O/
8P6bYXb6lbWd3POXBExZnjIc42qp+XI7njn2ruPBWnfDW6+Htreazq1zaa39nZJIgGcFgWQScHPP
2iBwoByLSYEjeMfRXi7SPCGi3V8E+GPhq5trazina5+w24/eSSOioU2ZP3c5HrWx4U0H4feIdGj1
Oy8D6LDC5Kqk2lQKwx7AHFd1HF06VSVRJrmts+3q+vkZ1acqlOMNNP8AgHztY+GPhbBeCC78XM4u
fMiLkb1sgBBiTcmPMb55cADb8hB5FT6l4e+Glw9rHZazZafB9ltzeu1y08yz7IRJFEdwU5YuS5Uo
PmwVAAr1u/uvA9na3Eknw98NGWO9mt0jjt7ZyyRShGYjAKsQchcEjBJ4Ga6/Q/CvgrU9DtNSHgjw
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

------=_NextPart_000_0000_01C0615B.DB988D20
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: file:///C:/TEMP/downloads/mrgamemaker/PVS%20-%20BSP%20Tutorial%20for%20Mr-GameMaker_files/gamemaker.gif

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

------=_NextPart_000_0000_01C0615B.DB988D20--
